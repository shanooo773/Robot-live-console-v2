"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_theia_scm_lib_browser_merge-editor_merge-editor_js-node_modules_theia_sc-59ad23"],{

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _objectWithoutPropertiesLoose)
/* harmony export */ });
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}


/***/ }),

/***/ "./node_modules/@theia/core/lib/browser/widgets/alert-message.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@theia/core/lib/browser/widgets/alert-message.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlertMessage = void 0;
const React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
const widget_1 = __webpack_require__(/*! ./widget */ "./node_modules/@theia/core/lib/browser/widgets/widget.js");
const AlertMessageIcon = {
    INFO: (0, widget_1.codicon)('info'),
    SUCCESS: (0, widget_1.codicon)('pass'),
    WARNING: (0, widget_1.codicon)('warning'),
    ERROR: (0, widget_1.codicon)('error')
};
class AlertMessage extends React.Component {
    render() {
        return React.createElement("div", { className: 'theia-alert-message-container' },
            React.createElement("div", { className: `theia-alert theia-${this.props.type.toLowerCase()}-alert` },
                React.createElement("div", { className: 'theia-message-header' },
                    React.createElement("i", { className: AlertMessageIcon[this.props.type] }),
                    this.props.header),
                React.createElement("div", { className: 'theia-message-content' }, this.props.children)));
    }
}
exports.AlertMessage = AlertMessage;


/***/ }),

/***/ "./node_modules/@theia/monaco/lib/browser/monaco-editor-peek-view-widget.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@theia/monaco/lib/browser/monaco-editor-peek-view-widget.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2024 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonacoEditorPeekViewWidget = exports.peekViewTitleInfoForeground = exports.peekViewTitleForeground = exports.peekViewTitleBackground = exports.peekViewBorder = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "./node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const peekView_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView */ "./node_modules/@theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView.js");
const actions_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/actions */ "./node_modules/@theia/monaco-editor-core/esm/vs/base/common/actions.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "./node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const instantiation_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/instantiation/common/instantiation */ "./node_modules/@theia/monaco-editor-core/esm/vs/platform/instantiation/common/instantiation.js");
const themeService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/theme/common/themeService */ "./node_modules/@theia/monaco-editor-core/esm/vs/platform/theme/common/themeService.js");
const color_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/color */ "./node_modules/@theia/monaco-editor-core/esm/vs/base/common/color.js");
var peekView_2 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView */ "./node_modules/@theia/monaco-editor-core/esm/vs/editor/contrib/peekView/browser/peekView.js");
Object.defineProperty(exports, "peekViewBorder", ({ enumerable: true, get: function () { return peekView_2.peekViewBorder; } }));
Object.defineProperty(exports, "peekViewTitleBackground", ({ enumerable: true, get: function () { return peekView_2.peekViewTitleBackground; } }));
Object.defineProperty(exports, "peekViewTitleForeground", ({ enumerable: true, get: function () { return peekView_2.peekViewTitleForeground; } }));
Object.defineProperty(exports, "peekViewTitleInfoForeground", ({ enumerable: true, get: function () { return peekView_2.peekViewTitleInfoForeground; } }));
class MonacoEditorPeekViewWidget {
    constructor(editor, options = {}, styles = {}) {
        this.editor = editor;
        this.styles = styles;
        this.toDispose = new core_1.DisposableCollection();
        this.onDidClose = this.toDispose.onDispose;
        this.themeService = standaloneServices_1.StandaloneServices.get(themeService_1.IThemeService);
        const that = this;
        this.toDispose.push(this.delegate = new class extends peekView_1.PeekViewWidget {
            get actionBar() {
                return this._actionbarWidget;
            }
            fillContainer(container) {
                super._fillContainer(container);
            }
            _fillContainer(container) {
                that.fillContainer(container);
            }
            fillHead(container, noCloseAction) {
                super._fillHead(container, noCloseAction);
            }
            _fillHead(container, noCloseAction) {
                that.fillHead(container, noCloseAction);
            }
            fillBody(container) {
                // super._fillBody is an abstract method
            }
            _fillBody(container) {
                that.fillBody(container);
            }
            ;
            doLayoutHead(heightInPixel, widthInPixel) {
                super._doLayoutHead(heightInPixel, widthInPixel);
            }
            _doLayoutHead(heightInPixel, widthInPixel) {
                that.doLayoutHead(heightInPixel, widthInPixel);
            }
            doLayoutBody(heightInPixel, widthInPixel) {
                super._doLayoutBody(heightInPixel, widthInPixel);
            }
            _doLayoutBody(heightInPixel, widthInPixel) {
                that.doLayoutBody(heightInPixel, widthInPixel);
            }
            onWidth(widthInPixel) {
                super._onWidth(widthInPixel);
            }
            _onWidth(widthInPixel) {
                that.onWidth(widthInPixel);
            }
            doRevealRange(range, isLastLine) {
                super.revealRange(range, isLastLine);
            }
            revealRange(range, isLastLine) {
                that.doRevealRange(that.editor['m2p'].asRange(range), isLastLine);
            }
            getBodyElement() {
                return this._bodyElement;
            }
            setBodyElement(element) {
                this._bodyElement = element;
            }
            getHeadElement() {
                return this._headElement;
            }
            setHeadElement(element) {
                this._headElement = element;
            }
            setCssClass(className, classToReplace) {
                super.setCssClass(className, classToReplace);
            }
        }(editor.getControl(), Object.assign({}, options, this.convertStyles(styles)), standaloneServices_1.StandaloneServices.get(instantiation_1.IInstantiationService)));
        this.toDispose.push(this.themeService.onDidColorThemeChange(() => this.style(this.styles)));
    }
    dispose() {
        this.toDispose.dispose();
    }
    create() {
        this.delegate.create();
    }
    setTitle(primaryHeading, secondaryHeading) {
        this.delegate.setTitle(primaryHeading, secondaryHeading);
    }
    style(styles) {
        this.delegate.style(this.convertStyles(this.styles = styles));
    }
    show(rangeOrPos, heightInLines) {
        this.delegate.show(this.convertRangeOrPosition(rangeOrPos), heightInLines);
    }
    hide() {
        this.delegate.hide();
    }
    clearActions() {
        var _a;
        (_a = this.delegate.actionBar) === null || _a === void 0 ? void 0 : _a.clear();
    }
    addAction(id, label, cssClass, enabled, actionCallback, options) {
        options = cssClass ? { icon: true, label: false, ...options } : { icon: false, label: true, ...options };
        const { actionBar } = this.delegate;
        if (!actionBar) {
            throw new Error('Action bar has not been created.');
        }
        const action = new actions_1.Action(id, label, cssClass, enabled, actionCallback);
        actionBar.push(action, options);
        return action;
    }
    fillContainer(container) {
        this.delegate.fillContainer(container);
    }
    fillHead(container, noCloseAction) {
        this.delegate.fillHead(container, noCloseAction);
    }
    fillBody(container) {
        this.delegate.fillBody(container);
    }
    doLayoutHead(heightInPixel, widthInPixel) {
        this.delegate.doLayoutHead(heightInPixel, widthInPixel);
    }
    doLayoutBody(heightInPixel, widthInPixel) {
        this.delegate.doLayoutBody(heightInPixel, widthInPixel);
    }
    onWidth(widthInPixel) {
        this.delegate.onWidth(widthInPixel);
    }
    doRevealRange(range, isLastLine) {
        this.delegate.doRevealRange(this.editor['p2m'].asRange(range), isLastLine);
    }
    get bodyElement() {
        return this.delegate.getBodyElement();
    }
    set bodyElement(element) {
        this.delegate.setBodyElement(element);
    }
    get headElement() {
        return this.delegate.getHeadElement();
    }
    set headElement(element) {
        this.delegate.setHeadElement(element);
    }
    setCssClass(className, classToReplace) {
        this.delegate.setCssClass(className, classToReplace);
    }
    convertStyles(styles) {
        return {
            frameColor: this.convertColor(styles.frameColor),
            arrowColor: this.convertColor(styles.arrowColor),
            headerBackgroundColor: this.convertColor(styles.headerBackgroundColor),
            primaryHeadingColor: this.convertColor(styles.primaryHeadingColor),
            secondaryHeadingColor: this.convertColor(styles.secondaryHeadingColor),
        };
    }
    convertColor(color) {
        if (color === undefined) {
            return undefined;
        }
        return this.themeService.getColorTheme().getColor(color) || color_1.Color.fromHex(color);
    }
    convertRangeOrPosition(arg) {
        const p2m = this.editor['p2m'];
        return vscode_languageserver_protocol_1.Range.is(arg) ? p2m.asRange(arg) : p2m.asPosition(arg);
    }
}
exports.MonacoEditorPeekViewWidget = MonacoEditorPeekViewWidget;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/decorations/scm-decorations-service.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/decorations/scm-decorations-service.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmDecorationsService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const dirty_diff_decorator_1 = __webpack_require__(/*! ../dirty-diff/dirty-diff-decorator */ "./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-decorator.js");
const diff_computer_1 = __webpack_require__(/*! ../dirty-diff/diff-computer */ "./node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const content_lines_1 = __webpack_require__(/*! ../dirty-diff/content-lines */ "./node_modules/@theia/scm/lib/browser/dirty-diff/content-lines.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "./node_modules/@theia/editor/lib/browser/index.js");
const scm_service_1 = __webpack_require__(/*! ../scm-service */ "./node_modules/@theia/scm/lib/browser/scm-service.js");
const throttle = __webpack_require__(/*! @theia/core/shared/lodash.throttle */ "./node_modules/@theia/core/shared/lodash.throttle/index.js");
let ScmDecorationsService = class ScmDecorationsService {
    constructor(decorator, scmService, editorManager, resourceProvider) {
        this.decorator = decorator;
        this.scmService = scmService;
        this.editorManager = editorManager;
        this.resourceProvider = resourceProvider;
        this.diffComputer = new diff_computer_1.DiffComputer();
        this.onDirtyDiffUpdateEmitter = new core_1.Emitter();
        this.onDirtyDiffUpdate = this.onDirtyDiffUpdateEmitter.event;
        const updateTasks = new Map();
        this.editorManager.onCreated(editorWidget => {
            const { editor } = editorWidget;
            if (!this.supportsDirtyDiff(editor)) {
                return;
            }
            const toDispose = new core_1.DisposableCollection();
            const updateTask = this.createUpdateTask(editor);
            updateTasks.set(editorWidget, updateTask);
            toDispose.push(editor.onDocumentContentChanged(() => updateTask()));
            toDispose.push(editorWidget.onDidChangeVisibility(visible => {
                if (visible) {
                    updateTask();
                }
            }));
            if (editor.onShouldDisplayDirtyDiffChanged) {
                toDispose.push(editor.onShouldDisplayDirtyDiffChanged(shouldDisplayDirtyDiff => {
                    if (shouldDisplayDirtyDiff) {
                        updateTask();
                    }
                    else {
                        const update = { editor, changes: [] };
                        this.decorator.applyDecorations(update);
                        this.onDirtyDiffUpdateEmitter.fire(update);
                    }
                }));
            }
            editorWidget.disposed.connect(() => {
                updateTask.cancel();
                updateTasks.delete(editorWidget);
                toDispose.dispose();
            });
            updateTask();
        });
        const runUpdateTasks = () => {
            for (const updateTask of updateTasks.values()) {
                updateTask();
            }
        };
        this.scmService.onDidAddRepository(({ provider }) => {
            var _a;
            provider.onDidChange(runUpdateTasks);
            (_a = provider.onDidChangeResources) === null || _a === void 0 ? void 0 : _a.call(provider, runUpdateTasks);
        });
        this.scmService.onDidChangeSelectedRepository(runUpdateTasks);
    }
    async applyEditorDecorations(editor) {
        if (!editor.shouldDisplayDirtyDiff()) {
            return;
        }
        const currentRepo = this.scmService.selectedRepository;
        if (currentRepo) {
            try {
                // Currently, the uri used here is specific to vscode.git; other SCM providers are thus not supported.
                // See https://github.com/eclipse-theia/theia/pull/13104#discussion_r1494540628 for a detailed discussion.
                const query = { path: editor.uri['codeUri'].fsPath, ref: '~' };
                const uri = editor.uri.withScheme(currentRepo.provider.id).withQuery(JSON.stringify(query));
                const previousResource = await this.resourceProvider(uri);
                try {
                    const previousContent = await previousResource.readContents();
                    if (!editor.shouldDisplayDirtyDiff()) { // check again; it might have changed in the meantime, since this is an async method
                        return;
                    }
                    const previousLines = content_lines_1.ContentLines.fromString(previousContent);
                    const currentLines = content_lines_1.ContentLines.fromTextEditorDocument(editor.document);
                    const dirtyDiff = this.diffComputer.computeDirtyDiff(content_lines_1.ContentLines.arrayLike(previousLines), content_lines_1.ContentLines.arrayLike(currentLines));
                    const update = { editor, previousRevisionUri: uri, ...dirtyDiff };
                    this.decorator.applyDecorations(update);
                    this.onDirtyDiffUpdateEmitter.fire(update);
                }
                finally {
                    previousResource.dispose();
                }
            }
            catch (e) {
                // Scm resource may not be found, do nothing.
            }
        }
    }
    supportsDirtyDiff(editor) {
        return editor.shouldDisplayDirtyDiff() || !!editor.onShouldDisplayDirtyDiffChanged;
    }
    createUpdateTask(editor) {
        return throttle(() => this.applyEditorDecorations(editor), 500);
    }
};
exports.ScmDecorationsService = ScmDecorationsService;
exports.ScmDecorationsService = ScmDecorationsService = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(dirty_diff_decorator_1.DirtyDiffDecorator)),
    tslib_1.__param(1, (0, inversify_1.inject)(scm_service_1.ScmService)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.EditorManager)),
    tslib_1.__param(3, (0, inversify_1.inject)(core_1.ResourceProvider)),
    tslib_1.__metadata("design:paramtypes", [dirty_diff_decorator_1.DirtyDiffDecorator,
        scm_service_1.ScmService,
        browser_1.EditorManager, Function])
], ScmDecorationsService);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/dirty-diff/content-lines.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/dirty-diff/content-lines.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContentLines = void 0;
var ContentLines;
(function (ContentLines) {
    const NL = '\n'.charCodeAt(0);
    const CR = '\r'.charCodeAt(0);
    function fromString(content) {
        const computeLineStarts = s => {
            const result = [0];
            for (let i = 0; i < s.length; i++) {
                const chr = s.charCodeAt(i);
                if (chr === CR) {
                    if (i + 1 < s.length && s.charCodeAt(i + 1) === NL) {
                        result[result.length] = i + 2;
                        i++;
                    }
                    else {
                        result[result.length] = i + 1;
                    }
                }
                else if (chr === NL) {
                    result[result.length] = i + 1;
                }
            }
            return result;
        };
        const lineStarts = computeLineStarts(content);
        return {
            length: lineStarts.length,
            getLineContent: line => {
                if (line >= lineStarts.length) {
                    throw new Error('line index out of bounds');
                }
                const start = lineStarts[line];
                let end = (line === lineStarts.length - 1) ? undefined : lineStarts[line + 1] - 1;
                if (!!end && content.charCodeAt(end - 1) === CR) {
                    end--; // ignore CR at the end
                }
                const lineContent = content.substring(start, end);
                return lineContent;
            }
        };
    }
    ContentLines.fromString = fromString;
    function fromTextEditorDocument(document) {
        return {
            length: document.lineCount,
            getLineContent: line => document.getLineContent(line + 1),
        };
    }
    ContentLines.fromTextEditorDocument = fromTextEditorDocument;
    function arrayLike(lines) {
        return new Proxy(lines, getProxyHandler());
    }
    ContentLines.arrayLike = arrayLike;
    function getProxyHandler() {
        return {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            get(target, p) {
                switch (p) {
                    case 'prototype':
                        return undefined;
                    case 'length':
                        return target.length;
                    case 'slice':
                        return (start, end) => {
                            if (start !== undefined) {
                                return [start, (end !== undefined ? end - 1 : target.length - 1)];
                            }
                            return [0, target.length - 1];
                        };
                    case Symbol.iterator:
                        return function* () {
                            for (let i = 0; i < target.length; i++) {
                                yield target.getLineContent(i);
                            }
                        };
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const index = Number.parseInt(p);
                if (Number.isInteger(index)) {
                    if (index >= 0 && index < target.length) {
                        const value = target.getLineContent(index);
                        if (value === undefined) {
                            console.log(target);
                        }
                        return value;
                    }
                    else {
                        return undefined;
                    }
                }
                throw new Error(`get ${String(p)} not implemented`);
            }
        };
    }
})(ContentLines || (exports.ContentLines = ContentLines = {}));


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineRange = exports.Change = exports.DiffComputer = void 0;
const jsdiff = __webpack_require__(/*! diff */ "./node_modules/diff/lib/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "./node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
class DiffComputer {
    computeDiff(previous, current) {
        const diffResult = diffArrays(previous, current);
        return diffResult;
    }
    computeDirtyDiff(previous, current) {
        const changes = [];
        const diffResult = this.computeDiff(previous, current);
        let currentRevisionLine = -1;
        let previousRevisionLine = -1;
        for (let i = 0; i < diffResult.length; i++) {
            const change = diffResult[i];
            const next = diffResult[i + 1];
            if (change.added) {
                // case: addition
                changes.push({ previousRange: LineRange.createEmptyLineRange(previousRevisionLine + 1), currentRange: toLineRange(change) });
                currentRevisionLine += change.count;
            }
            else if (change.removed && next && next.added) {
                const isFirstChange = i === 0;
                const isLastChange = i === diffResult.length - 2;
                const isNextEmptyLine = next.value.length > 0 && current[next.value[0]].length === 0;
                const isPrevEmptyLine = change.value.length > 0 && previous[change.value[0]].length === 0;
                if (isFirstChange && isNextEmptyLine) {
                    // special case: removing at the beginning
                    changes.push({ previousRange: toLineRange(change), currentRange: LineRange.createEmptyLineRange(0) });
                    previousRevisionLine += change.count;
                }
                else if (isFirstChange && isPrevEmptyLine) {
                    // special case: adding at the beginning
                    changes.push({ previousRange: LineRange.createEmptyLineRange(0), currentRange: toLineRange(next) });
                    currentRevisionLine += next.count;
                }
                else if (isLastChange && isNextEmptyLine) {
                    changes.push({ previousRange: toLineRange(change), currentRange: LineRange.createEmptyLineRange(currentRevisionLine + 2) });
                    previousRevisionLine += change.count;
                }
                else {
                    // default case is a modification
                    changes.push({ previousRange: toLineRange(change), currentRange: toLineRange(next) });
                    currentRevisionLine += next.count;
                    previousRevisionLine += change.count;
                }
                i++; // consume next eagerly
            }
            else if (change.removed && !(next && next.added)) {
                // case: removal
                changes.push({ previousRange: toLineRange(change), currentRange: LineRange.createEmptyLineRange(currentRevisionLine + 1) });
                previousRevisionLine += change.count;
            }
            else {
                // case: unchanged region
                currentRevisionLine += change.count;
                previousRevisionLine += change.count;
            }
        }
        return { changes };
    }
}
exports.DiffComputer = DiffComputer;
class ArrayDiff extends jsdiff.Diff {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    tokenize(value) {
        return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    join(value) {
        return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    removeEmpty(value) {
        return value;
    }
}
const arrayDiff = new ArrayDiff();
/**
 * Computes diff without copying data.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function diffArrays(oldArr, newArr) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return arrayDiff.diff(oldArr, newArr);
}
function toLineRange({ value }) {
    const [start, end] = value;
    return LineRange.create(start, end + 1);
}
var Change;
(function (Change) {
    function isAddition(change) {
        return LineRange.isEmpty(change.previousRange);
    }
    Change.isAddition = isAddition;
    function isRemoval(change) {
        return LineRange.isEmpty(change.currentRange);
    }
    Change.isRemoval = isRemoval;
    function isModification(change) {
        return !isAddition(change) && !isRemoval(change);
    }
    Change.isModification = isModification;
})(Change || (exports.Change = Change = {}));
var LineRange;
(function (LineRange) {
    function create(start, end) {
        if (start < 0 || end < 0 || start > end) {
            throw new Error(`Invalid line range: { start: ${start}, end: ${end} }`);
        }
        return { start, end };
    }
    LineRange.create = create;
    function createSingleLineRange(line) {
        return create(line, line + 1);
    }
    LineRange.createSingleLineRange = createSingleLineRange;
    function createEmptyLineRange(line) {
        return create(line, line);
    }
    LineRange.createEmptyLineRange = createEmptyLineRange;
    function isEmpty(range) {
        return range.start === range.end;
    }
    LineRange.isEmpty = isEmpty;
    function getStartPosition(range) {
        if (isEmpty(range)) {
            return getEndPosition(range);
        }
        return vscode_languageserver_protocol_1.Position.create(range.start, 0);
    }
    LineRange.getStartPosition = getStartPosition;
    function getEndPosition(range) {
        if (range.end < 1) {
            return vscode_languageserver_protocol_1.Position.create(0, 0);
        }
        return vscode_languageserver_protocol_1.Position.create(range.end - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE);
    }
    LineRange.getEndPosition = getEndPosition;
    function toRange(range) {
        return vscode_languageserver_protocol_1.Range.create(getStartPosition(range), getEndPosition(range));
    }
    LineRange.toRange = toRange;
    function getLineCount(range) {
        return range.end - range.start;
    }
    LineRange.getLineCount = getLineCount;
})(LineRange || (exports.LineRange = LineRange = {}));


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-decorator.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-decorator.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirtyDiffDecorator = exports.DirtyDiffDecorationType = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "./node_modules/@theia/editor/lib/browser/index.js");
const diff_computer_1 = __webpack_require__(/*! ./diff-computer */ "./node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
var DirtyDiffDecorationType;
(function (DirtyDiffDecorationType) {
    DirtyDiffDecorationType["AddedLine"] = "dirty-diff-added-line";
    DirtyDiffDecorationType["RemovedLine"] = "dirty-diff-removed-line";
    DirtyDiffDecorationType["ModifiedLine"] = "dirty-diff-modified-line";
})(DirtyDiffDecorationType || (exports.DirtyDiffDecorationType = DirtyDiffDecorationType = {}));
const AddedLineDecoration = {
    linesDecorationsClassName: 'dirty-diff-glyph dirty-diff-added-line',
    overviewRuler: {
        color: {
            id: 'editorOverviewRuler.addedForeground'
        },
        position: browser_1.OverviewRulerLane.Left,
    },
    minimap: {
        color: {
            id: 'minimapGutter.addedBackground'
        },
        position: browser_1.MinimapPosition.Gutter
    },
    isWholeLine: true
};
const RemovedLineDecoration = {
    linesDecorationsClassName: 'dirty-diff-glyph dirty-diff-removed-line',
    overviewRuler: {
        color: {
            id: 'editorOverviewRuler.deletedForeground'
        },
        position: browser_1.OverviewRulerLane.Left,
    },
    minimap: {
        color: {
            id: 'minimapGutter.deletedBackground'
        },
        position: browser_1.MinimapPosition.Gutter
    },
    isWholeLine: false
};
const ModifiedLineDecoration = {
    linesDecorationsClassName: 'dirty-diff-glyph dirty-diff-modified-line',
    overviewRuler: {
        color: {
            id: 'editorOverviewRuler.modifiedForeground'
        },
        position: browser_1.OverviewRulerLane.Left,
    },
    minimap: {
        color: {
            id: 'minimapGutter.modifiedBackground'
        },
        position: browser_1.MinimapPosition.Gutter
    },
    isWholeLine: true
};
function getEditorDecorationOptions(change) {
    if (diff_computer_1.Change.isAddition(change)) {
        return AddedLineDecoration;
    }
    if (diff_computer_1.Change.isRemoval(change)) {
        return RemovedLineDecoration;
    }
    return ModifiedLineDecoration;
}
let DirtyDiffDecorator = class DirtyDiffDecorator extends browser_1.EditorDecorator {
    applyDecorations(update) {
        const decorations = update.changes.map(change => this.toDeltaDecoration(change));
        this.setDecorations(update.editor, decorations);
    }
    toDeltaDecoration(change) {
        const range = diff_computer_1.LineRange.toRange(change.currentRange);
        const options = getEditorDecorationOptions(change);
        return { range, options };
    }
};
exports.DirtyDiffDecorator = DirtyDiffDecorator;
exports.DirtyDiffDecorator = DirtyDiffDecorator = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DirtyDiffDecorator);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-navigator.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-navigator.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2023 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirtyDiffController = exports.DirtyDiffNavigator = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "./node_modules/@theia/core/lib/browser/context-key-service.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "./node_modules/@theia/editor/lib/browser/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "./node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const diff_computer_1 = __webpack_require__(/*! ./diff-computer */ "./node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const dirty_diff_widget_1 = __webpack_require__(/*! ./dirty-diff-widget */ "./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js");
let DirtyDiffNavigator = class DirtyDiffNavigator {
    constructor() {
        this.controllers = new Map();
    }
    init() {
        const dirtyDiffVisible = this.contextKeyService.createKey('dirtyDiffVisible', false);
        this.editorManager.onActiveEditorChanged(editorWidget => {
            var _a;
            dirtyDiffVisible.set(editorWidget && ((_a = this.controllers.get(editorWidget.editor)) === null || _a === void 0 ? void 0 : _a.isShowingChange()));
        });
        this.editorManager.onCreated(editorWidget => {
            const { editor } = editorWidget;
            if (editor.uri.scheme !== 'file') {
                return;
            }
            const controller = this.createController(editor);
            controller.widgetFactory = props => {
                var _a;
                const widget = this.widgetFactory(props);
                if (widget.editor === ((_a = this.editorManager.activeEditor) === null || _a === void 0 ? void 0 : _a.editor)) {
                    dirtyDiffVisible.set(true);
                }
                widget.onDidClose(() => {
                    var _a;
                    if (widget.editor === ((_a = this.editorManager.activeEditor) === null || _a === void 0 ? void 0 : _a.editor)) {
                        dirtyDiffVisible.set(false);
                    }
                });
                return widget;
            };
            this.controllers.set(editor, controller);
            editorWidget.disposed.connect(() => {
                this.controllers.delete(editor);
                controller.dispose();
            });
        });
    }
    handleDirtyDiffUpdate(update) {
        const controller = this.controllers.get(update.editor);
        controller === null || controller === void 0 ? void 0 : controller.handleDirtyDiffUpdate(update);
    }
    canNavigate() {
        var _a;
        return !!((_a = this.activeController) === null || _a === void 0 ? void 0 : _a.canNavigate());
    }
    gotoNextChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.gotoNextChange();
    }
    gotoPreviousChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.gotoPreviousChange();
    }
    canShowChange() {
        var _a;
        return !!((_a = this.activeController) === null || _a === void 0 ? void 0 : _a.canShowChange());
    }
    showNextChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.showNextChange();
    }
    showPreviousChange() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.showPreviousChange();
    }
    isShowingChange() {
        var _a;
        return !!((_a = this.activeController) === null || _a === void 0 ? void 0 : _a.isShowingChange());
    }
    closeChangePeekView() {
        var _a;
        (_a = this.activeController) === null || _a === void 0 ? void 0 : _a.closeWidget();
    }
    get activeController() {
        var _a;
        const editor = (_a = this.editorManager.activeEditor) === null || _a === void 0 ? void 0 : _a.editor;
        return editor && this.controllers.get(editor);
    }
    createController(editor) {
        return new DirtyDiffController(editor);
    }
};
exports.DirtyDiffNavigator = DirtyDiffNavigator;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], DirtyDiffNavigator.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.EditorManager),
    tslib_1.__metadata("design:type", browser_1.EditorManager)
], DirtyDiffNavigator.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(dirty_diff_widget_1.DirtyDiffWidgetFactory),
    tslib_1.__metadata("design:type", Function)
], DirtyDiffNavigator.prototype, "widgetFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DirtyDiffNavigator.prototype, "init", null);
exports.DirtyDiffNavigator = DirtyDiffNavigator = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DirtyDiffNavigator);
class DirtyDiffController {
    constructor(editor) {
        this.editor = editor;
        this.toDispose = new core_1.DisposableCollection();
        editor.onMouseDown(this.handleEditorMouseDown, this, this.toDispose);
    }
    dispose() {
        this.closeWidget();
        this.toDispose.dispose();
    }
    handleDirtyDiffUpdate(dirtyDiff) {
        if (dirtyDiff.editor === this.editor) {
            this.dirtyDiff = dirtyDiff;
            if (this.widget) {
                this.widget.changes = dirtyDiff.changes;
            }
        }
    }
    canNavigate() {
        var _a;
        return !!((_a = this.changes) === null || _a === void 0 ? void 0 : _a.length);
    }
    gotoNextChange() {
        var _a;
        const { editor } = this;
        const index = this.findNextClosestChange(editor.cursor.line, false);
        const change = (_a = this.changes) === null || _a === void 0 ? void 0 : _a[index];
        if (change) {
            const position = diff_computer_1.LineRange.getStartPosition(change.currentRange);
            editor.cursor = position;
            editor.revealPosition(position, { vertical: 'auto' });
        }
    }
    gotoPreviousChange() {
        var _a;
        const { editor } = this;
        const index = this.findPreviousClosestChange(editor.cursor.line, false);
        const change = (_a = this.changes) === null || _a === void 0 ? void 0 : _a[index];
        if (change) {
            const position = diff_computer_1.LineRange.getStartPosition(change.currentRange);
            editor.cursor = position;
            editor.revealPosition(position, { vertical: 'auto' });
        }
    }
    canShowChange() {
        var _a;
        return !!(this.widget || this.widgetFactory && this.editor instanceof monaco_editor_1.MonacoEditor && ((_a = this.changes) === null || _a === void 0 ? void 0 : _a.length) && this.previousRevisionUri);
    }
    showNextChange() {
        var _a;
        if (this.widget) {
            this.widget.showNextChange();
        }
        else {
            (_a = (this.widget = this.createWidget())) === null || _a === void 0 ? void 0 : _a.showChange(this.findNextClosestChange(this.editor.cursor.line, true));
        }
    }
    showPreviousChange() {
        var _a;
        if (this.widget) {
            this.widget.showPreviousChange();
        }
        else {
            (_a = (this.widget = this.createWidget())) === null || _a === void 0 ? void 0 : _a.showChange(this.findPreviousClosestChange(this.editor.cursor.line, true));
        }
    }
    isShowingChange() {
        return !!this.widget;
    }
    closeWidget() {
        if (this.widget) {
            this.widget.dispose();
            this.widget = undefined;
        }
    }
    get changes() {
        var _a;
        return (_a = this.dirtyDiff) === null || _a === void 0 ? void 0 : _a.changes;
    }
    get previousRevisionUri() {
        var _a;
        return (_a = this.dirtyDiff) === null || _a === void 0 ? void 0 : _a.previousRevisionUri;
    }
    createWidget() {
        const { widgetFactory, editor, changes, previousRevisionUri } = this;
        if (widgetFactory && editor instanceof monaco_editor_1.MonacoEditor && (changes === null || changes === void 0 ? void 0 : changes.length) && previousRevisionUri) {
            const widget = widgetFactory({ editor, previousRevisionUri });
            widget.changes = changes;
            widget.onDidClose(() => {
                this.widget = undefined;
            });
            return widget;
        }
    }
    findNextClosestChange(line, inclusive) {
        var _a;
        const length = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.length;
        if (!length) {
            return -1;
        }
        for (let i = 0; i < length; i++) {
            const { currentRange } = this.changes[i];
            if (inclusive) {
                if (diff_computer_1.LineRange.getEndPosition(currentRange).line >= line) {
                    return i;
                }
            }
            else {
                if (diff_computer_1.LineRange.getStartPosition(currentRange).line > line) {
                    return i;
                }
            }
        }
        return 0;
    }
    findPreviousClosestChange(line, inclusive) {
        var _a;
        const length = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.length;
        if (!length) {
            return -1;
        }
        for (let i = length - 1; i >= 0; i--) {
            const { currentRange } = this.changes[i];
            if (inclusive) {
                if (diff_computer_1.LineRange.getStartPosition(currentRange).line <= line) {
                    return i;
                }
            }
            else {
                if (diff_computer_1.LineRange.getEndPosition(currentRange).line < line) {
                    return i;
                }
            }
        }
        return length - 1;
    }
    handleEditorMouseDown({ event, target }) {
        var _a, _b;
        if (event.button !== 0) {
            return;
        }
        const { range, type, element } = target;
        if (!range || type !== browser_1.MouseTargetType.GUTTER_LINE_DECORATIONS || !element || element.className.indexOf('dirty-diff-glyph') < 0) {
            return;
        }
        const gutterOffsetX = target.detail.offsetX - element.offsetLeft;
        if (gutterOffsetX < -3 || gutterOffsetX > 3) { // dirty diff decoration on hover is 6px wide
            return; // to avoid colliding with folding
        }
        const index = this.findNextClosestChange(range.start.line, true);
        if (index < 0) {
            return;
        }
        if (index === ((_a = this.widget) === null || _a === void 0 ? void 0 : _a.currentChangeIndex)) {
            this.closeWidget();
            return;
        }
        if (!this.widget) {
            this.widget = this.createWidget();
        }
        (_b = this.widget) === null || _b === void 0 ? void 0 : _b.showChange(index);
    }
}
exports.DirtyDiffController = DirtyDiffController;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2023 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DirtyDiffWidget = exports.DirtyDiffWidgetFactory = exports.DirtyDiffWidgetProps = exports.PLUGIN_SCM_CHANGE_TITLE_MENU = exports.SCM_CHANGE_TITLE_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "./node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "./node_modules/@theia/core/lib/browser/context-key-service.js");
const monaco_editor_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-provider */ "./node_modules/@theia/monaco/lib/browser/monaco-editor-provider.js");
const monaco_editor_peek_view_widget_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-peek-view-widget */ "./node_modules/@theia/monaco/lib/browser/monaco-editor-peek-view-widget.js");
const diff_computer_1 = __webpack_require__(/*! ./diff-computer */ "./node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const scm_colors_1 = __webpack_require__(/*! ../scm-colors */ "./node_modules/@theia/scm/lib/browser/scm-colors.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "./node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
exports.SCM_CHANGE_TITLE_MENU = ['scm-change-title-menu'];
/** Reserved for plugin contributions, corresponds to contribution point 'scm/change/title'. */
exports.PLUGIN_SCM_CHANGE_TITLE_MENU = ['plugin-scm-change-title-menu'];
exports.DirtyDiffWidgetProps = Symbol('DirtyDiffWidgetProps');
exports.DirtyDiffWidgetFactory = Symbol('DirtyDiffWidgetFactory');
let DirtyDiffWidget = class DirtyDiffWidget {
    constructor(props, editorProvider, contextKeyService, menuModelRegistry) {
        this.props = props;
        this.editorProvider = editorProvider;
        this.contextKeyService = contextKeyService;
        this.menuModelRegistry = menuModelRegistry;
        this.onDidCloseEmitter = new core_1.Emitter();
        this.onDidClose = this.onDidCloseEmitter.event;
        this.index = -1;
    }
    create() {
        this.peekView = new DirtyDiffPeekView(this);
        this.peekView.onDidClose(e => this.onDidCloseEmitter.fire(e));
        this.diffEditorPromise = this.peekView.create();
    }
    get changes() {
        var _a;
        return (_a = this._changes) !== null && _a !== void 0 ? _a : [];
    }
    set changes(changes) {
        this.handleChangedChanges(changes);
    }
    get editor() {
        return this.props.editor;
    }
    get uri() {
        return this.editor.uri;
    }
    get previousRevisionUri() {
        return this.props.previousRevisionUri;
    }
    get currentChange() {
        return this.changes[this.index];
    }
    get currentChangeIndex() {
        return this.index;
    }
    handleChangedChanges(updated) {
        if (!updated.length) {
            return this.dispose();
        }
        if (this.currentChange) {
            const { previousRange: { start, end } } = this.currentChange;
            // Same change or first after it.
            const newIndex = updated.findIndex(candidate => (candidate.previousRange.start === start && candidate.previousRange.end === end)
                || candidate.previousRange.start > start);
            if (newIndex !== -1) {
                this.index = newIndex;
            }
            else {
                this.index = Math.min(this.index, updated.length - 1);
            }
            this.showCurrentChange();
        }
        else {
            this.index = -1;
        }
        this._changes = updated;
        this.updateHeading();
    }
    async showChange(index) {
        await this.checkCreated();
        if (index >= 0 && index < this.changes.length) {
            this.index = index;
            this.showCurrentChange();
        }
    }
    showNextChange() {
        this.checkCreated();
        const index = this.index;
        const length = this.changes.length;
        if (length > 0 && (index < 0 || length > 1)) {
            this.index = index < 0 ? 0 : cycle(index, 1, length);
            this.showCurrentChange();
        }
    }
    showPreviousChange() {
        this.checkCreated();
        const index = this.index;
        const length = this.changes.length;
        if (length > 0 && (index < 0 || length > 1)) {
            this.index = index < 0 ? length - 1 : cycle(index, -1, length);
            this.showCurrentChange();
        }
    }
    async getContentWithSelectedChanges(predicate) {
        await this.checkCreated();
        const changes = this.changes.filter(predicate);
        const { diffEditor } = await this.diffEditorPromise;
        const diffEditorModel = diffEditor.getModel();
        return applyChanges(changes, diffEditorModel.original, diffEditorModel.modified);
    }
    dispose() {
        var _a;
        (_a = this.peekView) === null || _a === void 0 ? void 0 : _a.dispose();
        this.onDidCloseEmitter.dispose();
    }
    showCurrentChange() {
        this.updateHeading();
        const { previousRange, currentRange } = this.changes[this.index];
        this.peekView.show(vscode_languageserver_protocol_1.Position.create(diff_computer_1.LineRange.getEndPosition(currentRange).line, 0), this.computeHeightInLines());
        this.diffEditorPromise.then(({ diffEditor }) => {
            let startLine = diff_computer_1.LineRange.getStartPosition(currentRange).line;
            let endLine = diff_computer_1.LineRange.getEndPosition(currentRange).line;
            if (diff_computer_1.LineRange.isEmpty(currentRange)) { // the change is a removal
                ++endLine;
            }
            else if (!diff_computer_1.LineRange.isEmpty(previousRange)) { // the change is a modification
                --startLine;
                ++endLine;
            }
            diffEditor.revealLinesInCenter(startLine + 1, endLine + 1, // monaco line numbers are 1-based
            monaco.editor.ScrollType.Immediate);
        });
        this.editor.focus();
    }
    updateHeading() {
        this.peekView.setTitle(this.computePrimaryHeading(), this.computeSecondaryHeading());
    }
    computePrimaryHeading() {
        return this.uri.path.base;
    }
    computeSecondaryHeading() {
        const index = this.index + 1;
        const length = this.changes.length;
        return length > 1 ? core_1.nls.localizeByDefault('{0} of {1} changes', index, length) :
            core_1.nls.localizeByDefault('{0} of {1} change', index, length);
    }
    computeHeightInLines() {
        const editor = this.editor.getControl();
        const lineHeight = editor.getOption(monaco.editor.EditorOption.lineHeight);
        const editorHeight = editor.getLayoutInfo().height;
        const editorHeightInLines = Math.floor(editorHeight / lineHeight);
        const { previousRange, currentRange } = this.changes[this.index];
        const changeHeightInLines = diff_computer_1.LineRange.getLineCount(currentRange) + diff_computer_1.LineRange.getLineCount(previousRange);
        return Math.min(changeHeightInLines + /* padding */ 8, Math.floor(editorHeightInLines / 3));
    }
    async checkCreated() {
        return this.diffEditorPromise;
    }
};
exports.DirtyDiffWidget = DirtyDiffWidget;
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], DirtyDiffWidget.prototype, "create", null);
exports.DirtyDiffWidget = DirtyDiffWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(exports.DirtyDiffWidgetProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(monaco_editor_provider_1.MonacoEditorProvider)),
    tslib_1.__param(2, (0, inversify_1.inject)(context_key_service_1.ContextKeyService)),
    tslib_1.__param(3, (0, inversify_1.inject)(core_1.MenuModelRegistry)),
    tslib_1.__metadata("design:paramtypes", [Object, monaco_editor_provider_1.MonacoEditorProvider, Object, core_1.MenuModelRegistry])
], DirtyDiffWidget);
function cycle(index, offset, length) {
    return (index + offset + length) % length;
}
// adapted from https://github.com/microsoft/vscode/blob/823d54f86ee13eb357bc6e8e562e89d793f3c43b/extensions/git/src/staging.ts
function applyChanges(changes, original, modified) {
    const result = [];
    let currentLine = 1;
    for (const change of changes) {
        const { previousRange, currentRange } = change;
        const isInsertion = diff_computer_1.LineRange.isEmpty(previousRange);
        const isDeletion = diff_computer_1.LineRange.isEmpty(currentRange);
        const convert = (range) => {
            let startLineNumber;
            let endLineNumber;
            if (!diff_computer_1.LineRange.isEmpty(range)) {
                startLineNumber = range.start + 1;
                endLineNumber = range.end;
            }
            else {
                startLineNumber = range.start;
                endLineNumber = 0;
            }
            return [startLineNumber, endLineNumber];
        };
        const [originalStartLineNumber, originalEndLineNumber] = convert(previousRange);
        const [modifiedStartLineNumber, modifiedEndLineNumber] = convert(currentRange);
        let toLine = isInsertion ? originalStartLineNumber + 1 : originalStartLineNumber;
        let toCharacter = 1;
        // if this is a deletion at the very end of the document,
        // we need to account for a newline at the end of the last line,
        // which may have been deleted
        if (isDeletion && originalEndLineNumber === original.getLineCount()) {
            toLine--;
            toCharacter = original.getLineMaxColumn(toLine);
        }
        result.push(original.getValueInRange(new monaco.Range(currentLine, 1, toLine, toCharacter)));
        if (!isDeletion) {
            let fromLine = modifiedStartLineNumber;
            let fromCharacter = 1;
            // if this is an insertion at the very end of the document,
            // we must start the next range after the last character of the previous line,
            // in order to take the correct eol
            if (isInsertion && originalStartLineNumber === original.getLineCount()) {
                fromLine--;
                fromCharacter = modified.getLineMaxColumn(fromLine);
            }
            result.push(modified.getValueInRange(new monaco.Range(fromLine, fromCharacter, modifiedEndLineNumber + 1, 1)));
        }
        currentLine = isInsertion ? originalStartLineNumber + 1 : originalEndLineNumber + 1;
    }
    result.push(original.getValueInRange(new monaco.Range(currentLine, 1, original.getLineCount() + 1, 1)));
    return result.join('');
}
class DirtyDiffPeekView extends monaco_editor_peek_view_widget_1.MonacoEditorPeekViewWidget {
    constructor(widget) {
        super(widget.editor, { isResizeable: true, showArrow: true, frameWidth: 1, keepEditorSelection: true, className: 'dirty-diff' });
        this.widget = widget;
    }
    async create() {
        try {
            this.bodyElement = document.createElement('div');
            this.bodyElement.classList.add('body');
            const diffEditor = await this.widget.editorProvider.createEmbeddedDiffEditor(this.editor, this.bodyElement, this.widget.previousRevisionUri);
            this.diffEditor = diffEditor;
            this.toDispose.push(diffEditor);
            super.create();
            return new Promise(resolve => {
                // setTimeout is needed here because the non-side-by-side diff editor might still not have created the view zones;
                // otherwise, the first change shown might not be properly revealed in the diff editor.
                // see also https://github.com/microsoft/vscode/blob/b30900b56c4b3ca6c65d7ab92032651f4cb23f15/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.ts#L248
                const disposable = diffEditor.diffEditor.onDidUpdateDiff(() => setTimeout(() => {
                    resolve(diffEditor);
                    disposable.dispose();
                }));
            });
        }
        catch (e) {
            this.dispose();
            throw e;
        }
    }
    show(rangeOrPos, heightInLines) {
        const borderColor = this.getBorderColor();
        this.style({
            arrowColor: borderColor,
            frameColor: borderColor,
            headerBackgroundColor: monaco_editor_peek_view_widget_1.peekViewTitleBackground,
            primaryHeadingColor: monaco_editor_peek_view_widget_1.peekViewTitleForeground,
            secondaryHeadingColor: monaco_editor_peek_view_widget_1.peekViewTitleInfoForeground
        });
        this.updateActions();
        super.show(rangeOrPos, heightInLines);
    }
    getBorderColor() {
        const { currentChange } = this.widget;
        if (!currentChange) {
            return monaco_editor_peek_view_widget_1.peekViewBorder;
        }
        if (diff_computer_1.Change.isAddition(currentChange)) {
            return scm_colors_1.ScmColors.editorGutterAddedBackground;
        }
        else if (diff_computer_1.Change.isRemoval(currentChange)) {
            return scm_colors_1.ScmColors.editorGutterDeletedBackground;
        }
        else {
            return scm_colors_1.ScmColors.editorGutterModifiedBackground;
        }
    }
    updateActions() {
        this.clearActions();
        const { contextKeyService, menuModelRegistry } = this.widget;
        contextKeyService.with({ originalResourceScheme: this.widget.previousRevisionUri.scheme }, () => {
            for (const menuPath of [exports.SCM_CHANGE_TITLE_MENU, exports.PLUGIN_SCM_CHANGE_TITLE_MENU]) {
                const menu = menuModelRegistry.getMenu(menuPath);
                if (menu) {
                    for (const item of menu.children) {
                        if (core_1.CommandMenu.is(item)) {
                            const { id, label, icon } = item;
                            const itemPath = [...menuPath, id];
                            if (icon && item.isVisible(itemPath, contextKeyService, undefined, this.widget)) {
                                // Close editor on successful contributed action.
                                // https://github.com/microsoft/vscode/blob/1.99.3/src/vs/workbench/contrib/scm/browser/quickDiffWidget.ts#L357-L361
                                this.addAction(id, label, icon, item.isEnabled(itemPath, this.widget), () => {
                                    item.run(itemPath, this.widget).then(() => this.dispose());
                                });
                            }
                        }
                    }
                }
            }
        });
        this.addAction('dirtydiff.next', core_1.nls.localizeByDefault('Show Next Change'), (0, browser_1.codicon)('arrow-down'), true, () => this.widget.showNextChange());
        this.addAction('dirtydiff.previous', core_1.nls.localizeByDefault('Show Previous Change'), (0, browser_1.codicon)('arrow-up'), true, () => this.widget.showPreviousChange());
        this.addAction('peekview.close', core_1.nls.localizeByDefault('Close'), (0, browser_1.codicon)('close'), true, () => this.dispose());
    }
    fillContainer(container) {
        this.setCssClass('peekview-widget');
        this.headElement = document.createElement('div');
        this.headElement.classList.add('head');
        container.appendChild(this.headElement);
        container.appendChild(this.bodyElement);
        this.fillHead(this.headElement);
    }
    fillHead(container) {
        super.fillHead(container, true);
    }
    doLayoutBody(height, width) {
        super.doLayoutBody(height, width);
        this.layout(height, width);
        this.height = height;
    }
    onWidth(width) {
        super.onWidth(width);
        const { height } = this;
        if (height !== undefined) {
            this.layout(height, width);
        }
    }
    layout(height, width) {
        var _a;
        (_a = this.diffEditor) === null || _a === void 0 ? void 0 : _a.diffEditor.layout({ height, width });
    }
    doRevealRange(range) {
        this.editor.revealPosition(vscode_languageserver_protocol_1.Position.create(range.end.line, 0), { vertical: 'centerIfOutsideViewport' });
    }
}


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/merge-editor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/merge-editor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var MergeEditorSettings_1, MergeEditorOpenHandler_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorOpenHandler = exports.MergeEditor = exports.MergeEditorSettings = exports.MergeEditorLayoutMode = exports.MergeEditorUri = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const merge_editor_model_1 = __webpack_require__(/*! ./model/merge-editor-model */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-editor-model.js");
const merge_editor_panes_1 = __webpack_require__(/*! ./view/merge-editor-panes */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/index.js");
const merge_editor_view_zones_1 = __webpack_require__(/*! ./view/merge-editor-view-zones */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-view-zones.js");
const merge_editor_scroll_sync_1 = __webpack_require__(/*! ./view/merge-editor-scroll-sync */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-scroll-sync.js");
var MergeEditorUri;
(function (MergeEditorUri) {
    const SCHEME = 'merge-editor';
    function isMergeEditorUri(uri) {
        return uri.scheme === SCHEME;
    }
    MergeEditorUri.isMergeEditorUri = isMergeEditorUri;
    function encode({ baseUri, side1Uri, side2Uri, resultUri }) {
        return new core_1.URI().withScheme(SCHEME).withQuery(JSON.stringify([baseUri.toString(), side1Uri.toString(), side2Uri.toString(), resultUri.toString()]));
    }
    MergeEditorUri.encode = encode;
    function decode(uri) {
        if (uri.scheme !== SCHEME) {
            throw new Error(`The URI must have scheme ${SCHEME}. The URI was: ${uri}`);
        }
        const mergeUris = JSON.parse(uri.query);
        if (!Array.isArray(mergeUris) || !mergeUris.every(mergeUri => typeof mergeUri === 'string')) {
            throw new Error(`The URI ${uri} is not a valid URI for scheme ${SCHEME}`);
        }
        return {
            baseUri: new core_1.URI(mergeUris[0]),
            side1Uri: new core_1.URI(mergeUris[1]),
            side2Uri: new core_1.URI(mergeUris[2]),
            resultUri: new core_1.URI(mergeUris[3])
        };
    }
    MergeEditorUri.decode = decode;
})(MergeEditorUri || (exports.MergeEditorUri = MergeEditorUri = {}));
var MergeEditorLayoutMode;
(function (MergeEditorLayoutMode) {
    MergeEditorLayoutMode.DEFAULT = { kind: 'mixed', showBase: true, showBaseAtTop: false };
})(MergeEditorLayoutMode || (exports.MergeEditorLayoutMode = MergeEditorLayoutMode = {}));
let MergeEditorSettings = MergeEditorSettings_1 = class MergeEditorSettings {
    constructor() {
        this.layoutMode = MergeEditorLayoutMode.DEFAULT;
    }
    async load() {
        await Promise.allSettled([
            this.storageService.getData(MergeEditorSettings_1.LAYOUT_MODE, this.layoutMode).then(layoutMode => this.layoutMode = layoutMode),
        ]);
    }
    async save() {
        await Promise.allSettled([
            this.storageService.setData(MergeEditorSettings_1.LAYOUT_MODE, this.layoutMode),
        ]);
    }
};
exports.MergeEditorSettings = MergeEditorSettings;
MergeEditorSettings.LAYOUT_MODE = 'mergeEditor/layoutMode';
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StorageService),
    tslib_1.__metadata("design:type", Object)
], MergeEditorSettings.prototype, "storageService", void 0);
exports.MergeEditorSettings = MergeEditorSettings = MergeEditorSettings_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MergeEditorSettings);
let MergeEditor = class MergeEditor extends browser_1.BaseWidget {
    constructor() {
        super(...arguments);
        this.visibilityObservable = observable_1.SettableObservable.create(true);
        this.currentPaneObservable = observable_1.SettableObservable.create(undefined);
        this.layoutModeObservable = observable_1.SettableObservable.create(MergeEditorLayoutMode.DEFAULT, {
            isEqual: (a, b) => JSON.stringify(a) === JSON.stringify(b)
        });
        this.currentMergeRangeObservable = this.createCurrentMergeRangeObservable();
        this.selectionInBaseObservable = this.createSelectionInBaseObservable();
        this.layoutInitialized = false;
    }
    init() {
        this.addClass('theia-merge-editor');
        const { baseUri, side1Uri, side2Uri, resultUri } = this;
        this.id = MergeEditorUri.encode({ baseUri, side1Uri, side2Uri, resultUri }).toString();
        const setLabels = () => {
            this.title.label = core_1.nls.localizeByDefault('Merging: {0}', this.labelProvider.getName(resultUri));
            this.title.iconClass = this.labelProvider.getIcon(resultUri) + ' file-icon';
            this.resultPane.header.description = this.labelProvider.getLongName(resultUri);
        };
        setLabels();
        this.toDispose.push(this.labelProvider.onDidChange(event => {
            if (event.affects(resultUri)) {
                setLabels();
            }
        }));
        this.title.caption = resultUri.path.fsPath();
        this.title.closable = true;
        this.basePane.header.title.label = core_1.nls.localizeByDefault('Base');
        this.side1Pane.header.title.label = core_1.nls.localizeByDefault('Input 1');
        this.side2Pane.header.title.label = core_1.nls.localizeByDefault('Input 2');
        this.resultPane.header.title.label = core_1.nls.localizeByDefault('Result');
        this.panes.forEach(pane => pane.mergeEditor = this);
        const layout = this.layout = new browser_1.PanelLayout();
        this.verticalSplitPanel = new browser_1.SplitPanel({
            spacing: 1, // --theia-border-width
            orientation: 'vertical'
        });
        layout.addWidget(this.verticalSplitPanel);
        this.horizontalSplitPanel = new browser_1.SplitPanel({
            spacing: 1, // --theia-border-width
            orientation: 'horizontal'
        });
        this.verticalSplitPanel.addWidget(this.horizontalSplitPanel);
        this.layoutMode = this.settings.layoutMode;
        this.toDispose.push(this.scrollSync = this.createScrollSynchronizer());
        this.initCurrentPaneTracker();
    }
    createScrollSynchronizer() {
        return new merge_editor_scroll_sync_1.MergeEditorScrollSync(this);
    }
    initCurrentPaneTracker() {
        const focusTracker = new browser_1.FocusTracker();
        this.toDispose.push(focusTracker);
        focusTracker.currentChanged.connect((_, { oldValue, newValue }) => {
            oldValue === null || oldValue === void 0 ? void 0 : oldValue.removeClass('focused');
            newValue === null || newValue === void 0 ? void 0 : newValue.addClass('focused');
            this.currentPaneObservable.set(newValue || undefined);
        });
        this.panes.forEach(pane => focusTracker.add(pane));
    }
    ensureLayoutInitialized() {
        if (!this.layoutInitialized) {
            this.layoutInitialized = true;
            this.doInitializeLayout();
            this.onLayoutInitialized();
        }
    }
    doInitializeLayout() {
        this.toDispose.push(observable_1.Autorun.create(({ isFirstRun }) => {
            const { layoutMode } = this;
            const scrollState = this.scrollSync.storeScrollState();
            const currentPane = this.currentPaneObservable.getUntracked();
            this.applyLayoutMode(layoutMode);
            const pane = (currentPane === null || currentPane === void 0 ? void 0 : currentPane.isVisible) ? currentPane : this.resultPane;
            this.currentPaneObservable.set(pane);
            pane.activate();
            this.scrollSync.restoreScrollState(scrollState);
            if (!isFirstRun) {
                this.settings.layoutMode = layoutMode;
            }
        }));
        let storedState;
        this.toDispose.push(observable_1.ObservableUtils.autorunWithDisposables(({ toDispose }) => {
            if (this.isShown) {
                toDispose.push(this.createViewZones());
                if (storedState) {
                    const { currentPane, scrollState } = storedState;
                    storedState = undefined;
                    const pane = currentPane !== null && currentPane !== void 0 ? currentPane : this.resultPane;
                    this.currentPaneObservable.set(pane);
                    pane.activate();
                    this.scrollSync.restoreScrollState(scrollState);
                }
                else {
                    this.scrollSync.update();
                }
            }
            else {
                storedState = {
                    scrollState: this.scrollSync.storeScrollState(),
                    currentPane: this.currentPaneObservable.getUntracked()
                };
            }
        }));
    }
    onLayoutInitialized() {
        const shouldGoToInitialMergeRange = () => {
            var _a;
            const { cursorPosition } = (_a = this.currentPane) !== null && _a !== void 0 ? _a : this.resultPane;
            return cursorPosition.line === 0 && cursorPosition.character === 0;
        };
        if (shouldGoToInitialMergeRange()) {
            this.model.onInitialized.then(() => {
                if (!this.isDisposed && shouldGoToInitialMergeRange()) {
                    this.goToFirstMergeRange(mergeRange => !this.model.isMergeRangeHandled(mergeRange));
                }
            });
        }
    }
    onResize(msg) {
        super.onResize(msg);
        if (msg.width >= 0 && msg.height >= 0) {
            // Don't try to initialize layout until the merge editor itself is positioned.
            // Otherwise, SplitPanel.setRelativeSizes might not work properly when initializing layout.
            this.ensureLayoutInitialized();
        }
    }
    get isShown() {
        return this.visibilityObservable.get();
    }
    get currentPane() {
        return this.currentPaneObservable.get();
    }
    createCurrentMergeRangeObservable() {
        return observable_1.DerivedObservable.create(() => {
            const { currentPane } = this;
            if (!currentPane) {
                return undefined;
            }
            const { cursorLine } = currentPane;
            return this.model.mergeRanges.find(mergeRange => {
                const lineRange = currentPane.getLineRangeForMergeRange(mergeRange);
                return lineRange.isEmpty ? lineRange.startLineNumber === cursorLine : lineRange.containsLine(cursorLine);
            });
        });
    }
    get currentMergeRange() {
        return this.currentMergeRangeObservable.get();
    }
    createSelectionInBaseObservable() {
        return observable_1.DerivedObservable.create(() => {
            var _a;
            const { currentPane } = this;
            return (_a = currentPane === null || currentPane === void 0 ? void 0 : currentPane.selection) === null || _a === void 0 ? void 0 : _a.map(range => {
                if (currentPane === this.side1Pane) {
                    return this.model.translateSideRangeToBase(range, 1);
                }
                if (currentPane === this.side2Pane) {
                    return this.model.translateSideRangeToBase(range, 2);
                }
                if (currentPane === this.resultPane) {
                    return this.model.translateResultRangeToBase(range);
                }
                return range;
            });
        });
    }
    get selectionInBase() {
        return this.selectionInBaseObservable.get();
    }
    get panes() {
        return [this.basePane, this.side1Pane, this.side2Pane, this.resultPane];
    }
    get baseUri() {
        return this.basePane.editor.uri;
    }
    get side1Uri() {
        return this.side1Pane.editor.uri;
    }
    get side1Title() {
        return this.side1Pane.header.title.label;
    }
    get side2Uri() {
        return this.side2Pane.editor.uri;
    }
    get side2Title() {
        return this.side2Pane.header.title.label;
    }
    get resultUri() {
        return this.resultPane.editor.uri;
    }
    storeState() {
        const getSideState = ({ header }) => ({
            title: header.title.label,
            description: header.description,
            detail: header.detail
        });
        return {
            layoutMode: this.layoutMode,
            side1State: getSideState(this.side1Pane),
            side2State: getSideState(this.side2Pane)
        };
    }
    restoreState(state) {
        const { layoutMode, side1State, side2State } = state;
        if (layoutMode) {
            this.layoutMode = layoutMode;
        }
        const restoreSideState = ({ header }, { title, description, detail }) => {
            if (title) {
                header.title.label = title;
            }
            if (description) {
                header.description = description;
            }
            if (detail) {
                header.detail = detail;
            }
        };
        if (side1State) {
            restoreSideState(this.side1Pane, side1State);
        }
        if (side2State) {
            restoreSideState(this.side2Pane, side2State);
        }
    }
    get saveable() {
        return this.resultPane.editor.document;
    }
    getResourceUri() {
        return this.resultUri;
    }
    createMoveToUri(resourceUri) {
        const { baseUri, side1Uri, side2Uri, resultUri } = this;
        return MergeEditorUri.encode({ baseUri, side1Uri, side2Uri, resultUri: resultUri.withPath(resourceUri.path) });
    }
    getTrackableWidgets() {
        return this.panes.map(pane => pane.editorWidget);
    }
    goToFirstMergeRange(predicate = () => true) {
        var _a;
        const firstMergeRange = this.model.mergeRanges.find(mergeRange => predicate(mergeRange));
        if (firstMergeRange) {
            const pane = (_a = this.currentPane) !== null && _a !== void 0 ? _a : this.resultPane;
            pane.goToMergeRange(firstMergeRange);
        }
    }
    goToNextMergeRange(predicate = () => true) {
        var _a;
        const pane = (_a = this.currentPane) !== null && _a !== void 0 ? _a : this.resultPane;
        const lineNumber = pane.cursorLine;
        const nextMergeRange = this.model.mergeRanges.find(mergeRange => predicate(mergeRange) && pane.getLineRangeForMergeRange(mergeRange).startLineNumber > lineNumber) ||
            this.model.mergeRanges.find(mergeRange => predicate(mergeRange));
        if (nextMergeRange) {
            pane.goToMergeRange(nextMergeRange);
        }
    }
    goToPreviousMergeRange(predicate = () => true) {
        var _a;
        const pane = (_a = this.currentPane) !== null && _a !== void 0 ? _a : this.resultPane;
        const lineNumber = pane.cursorLine;
        const previousMergeRange = core_1.ArrayUtils.findLast(this.model.mergeRanges, mergeRange => predicate(mergeRange) && pane.getLineRangeForMergeRange(mergeRange).endLineNumberExclusive <= lineNumber) ||
            core_1.ArrayUtils.findLast(this.model.mergeRanges, mergeRange => predicate(mergeRange));
        if (previousMergeRange) {
            pane.goToMergeRange(previousMergeRange);
        }
    }
    get layoutMode() {
        return this.layoutModeObservable.get();
    }
    set layoutMode(value) {
        this.layoutModeObservable.set(value);
    }
    get layoutKind() {
        return this.layoutMode.kind;
    }
    set layoutKind(kind) {
        this.layoutMode = {
            ...this.layoutMode,
            kind
        };
    }
    get isShowingBase() {
        return this.layoutMode.showBase;
    }
    get isShowingBaseAtTop() {
        const { layoutMode } = this;
        return layoutMode.showBase && layoutMode.showBaseAtTop;
    }
    toggleShowBase() {
        const { layoutMode } = this;
        this.layoutMode = {
            ...layoutMode,
            showBase: !layoutMode.showBase
        };
    }
    toggleShowBaseTop() {
        const { layoutMode } = this;
        const isToggled = layoutMode.showBase && layoutMode.showBaseAtTop;
        this.layoutMode = {
            ...layoutMode,
            showBaseAtTop: true,
            showBase: !isToggled,
        };
    }
    toggleShowBaseCenter() {
        const { layoutMode } = this;
        const isToggled = layoutMode.showBase && !layoutMode.showBaseAtTop;
        this.layoutMode = {
            ...layoutMode,
            showBaseAtTop: false,
            showBase: !isToggled,
        };
    }
    get shouldAlignResult() {
        return this.layoutKind === 'columns';
    }
    get shouldAlignBase() {
        const { layoutMode } = this;
        return layoutMode.kind === 'mixed' && layoutMode.showBase && !layoutMode.showBaseAtTop;
    }
    applyLayoutMode(layoutMode) {
        const oldVerticalSplitWidgets = [...this.verticalSplitPanel.widgets];
        if (!layoutMode.showBase) {
            // eslint-disable-next-line no-null/no-null
            this.basePane.parent = null;
        }
        this.horizontalSplitPanel.insertWidget(0, this.side1Pane);
        this.horizontalSplitPanel.insertWidget(2, this.side2Pane);
        let horizontalSplitRatio = [50, 50];
        let verticalSplitRatio;
        if (layoutMode.kind === 'columns') {
            horizontalSplitRatio = [33, 34, 33];
            verticalSplitRatio = [100];
            this.horizontalSplitPanel.insertWidget(1, this.resultPane);
            if (layoutMode.showBase) {
                verticalSplitRatio = [30, 70];
                this.verticalSplitPanel.insertWidget(0, this.basePane);
            }
        }
        else {
            verticalSplitRatio = [45, 55];
            if (layoutMode.showBase) {
                if (layoutMode.showBaseAtTop) {
                    verticalSplitRatio = [30, 33, 37];
                    this.verticalSplitPanel.insertWidget(0, this.basePane);
                }
                else {
                    horizontalSplitRatio = [33, 34, 33];
                    this.horizontalSplitPanel.insertWidget(1, this.basePane);
                }
            }
            this.verticalSplitPanel.insertWidget(2, this.resultPane);
        }
        this.horizontalSplitPanel.setRelativeSizes(horizontalSplitRatio);
        // Keep the existing vertical split ratio if the layout mode change has not affected the vertical split layout.
        if (!core_1.ArrayUtils.equals(oldVerticalSplitWidgets, this.verticalSplitPanel.widgets)) {
            this.verticalSplitPanel.setRelativeSizes(verticalSplitRatio);
        }
    }
    createViewZones() {
        const { baseViewZones, side1ViewZones, side2ViewZones, resultViewZones } = this.viewZoneComputer.computeViewZones(this);
        const toDispose = new core_1.DisposableCollection();
        const addViewZones = (pane, viewZones) => {
            const editor = pane.editor.getControl();
            const viewZoneIds = [];
            toDispose.push(core_1.Disposable.create(() => {
                editor.changeViewZones(accessor => {
                    for (const viewZoneId of viewZoneIds) {
                        accessor.removeZone(viewZoneId);
                    }
                });
            }));
            editor.changeViewZones(accessor => {
                const ctx = {
                    createViewZone: viewZone => viewZoneIds.push(accessor.addZone(viewZone)),
                    register: disposable => toDispose.push(disposable)
                };
                for (const viewZone of viewZones) {
                    viewZone.create(ctx);
                }
            });
        };
        addViewZones(this.basePane, baseViewZones);
        addViewZones(this.side1Pane, side1ViewZones);
        addViewZones(this.side2Pane, side2ViewZones);
        addViewZones(this.resultPane, resultViewZones);
        return toDispose;
    }
    onBeforeHide(msg) {
        this.visibilityObservable.set(false);
    }
    onAfterShow(msg) {
        this.visibilityObservable.set(true);
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        const { currentPane } = this;
        if (currentPane) {
            currentPane.activate();
        }
        else {
            this.resultPane.activate();
        }
    }
};
exports.MergeEditor = MergeEditor;
tslib_1.__decorate([
    (0, inversify_1.inject)(merge_editor_model_1.MergeEditorModel),
    tslib_1.__metadata("design:type", merge_editor_model_1.MergeEditorModel)
], MergeEditor.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(merge_editor_panes_1.MergeEditorBasePane),
    tslib_1.__metadata("design:type", merge_editor_panes_1.MergeEditorBasePane)
], MergeEditor.prototype, "basePane", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(merge_editor_panes_1.MergeEditorSide1Pane),
    tslib_1.__metadata("design:type", merge_editor_panes_1.MergeEditorSide1Pane)
], MergeEditor.prototype, "side1Pane", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(merge_editor_panes_1.MergeEditorSide2Pane),
    tslib_1.__metadata("design:type", merge_editor_panes_1.MergeEditorSide2Pane)
], MergeEditor.prototype, "side2Pane", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(merge_editor_panes_1.MergeEditorResultPane),
    tslib_1.__metadata("design:type", merge_editor_panes_1.MergeEditorResultPane)
], MergeEditor.prototype, "resultPane", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(merge_editor_view_zones_1.MergeEditorViewZoneComputer),
    tslib_1.__metadata("design:type", merge_editor_view_zones_1.MergeEditorViewZoneComputer)
], MergeEditor.prototype, "viewZoneComputer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(MergeEditorSettings),
    tslib_1.__metadata("design:type", MergeEditorSettings)
], MergeEditor.prototype, "settings", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], MergeEditor.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], MergeEditor.prototype, "init", null);
exports.MergeEditor = MergeEditor = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MergeEditor);
let MergeEditorOpenHandler = MergeEditorOpenHandler_1 = class MergeEditorOpenHandler extends browser_1.NavigatableWidgetOpenHandler {
    constructor() {
        super(...arguments);
        this.id = MergeEditorOpenHandler_1.ID;
        this.label = core_1.nls.localizeByDefault('Merge Editor');
    }
    canHandle(uri, options) {
        return MergeEditorUri.isMergeEditorUri(uri) ? 1000 : 0;
    }
    open(uri, options) {
        return super.open(uri, options);
    }
    async getOrCreateWidget(uri, options) {
        const widget = await super.getOrCreateWidget(uri, options);
        if (options === null || options === void 0 ? void 0 : options.widgetState) {
            widget.restoreState(options.widgetState);
        }
        return widget;
    }
};
exports.MergeEditorOpenHandler = MergeEditorOpenHandler;
MergeEditorOpenHandler.ID = 'merge-editor-opener';
exports.MergeEditorOpenHandler = MergeEditorOpenHandler = MergeEditorOpenHandler_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MergeEditorOpenHandler);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/model/line-range.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/model/line-range.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/model/lineRange.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineRange = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "./node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
/**
 * Represents a range of whole lines of text. Line numbers are zero-based.
 */
class LineRange {
    static compareByStart(a, b) {
        return a.startLineNumber - b.startLineNumber;
    }
    static fromLineNumbers(startLineNumber, endExclusiveLineNumber) {
        return new LineRange(startLineNumber, endExclusiveLineNumber - startLineNumber);
    }
    constructor(
    /** A zero-based number of the start line. The range starts exactly at the beginning of this line. */
    startLineNumber, lineCount) {
        this.startLineNumber = startLineNumber;
        this.lineCount = lineCount;
        if (startLineNumber < 0 || lineCount < 0) {
            throw new Error('Invalid line range: ' + this.toString());
        }
    }
    join(other) {
        return LineRange.fromLineNumbers(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    /** A zero-based number of the end line. The range ends just before the beginning of this line. */
    get endLineNumberExclusive() {
        return this.startLineNumber + this.lineCount;
    }
    get isEmpty() {
        return this.lineCount === 0;
    }
    /**
     * Returns `false` if there is at least one line between `this` and `other`.
     */
    touches(other) {
        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    isAfter(other) {
        return this.startLineNumber >= other.endLineNumberExclusive;
    }
    isBefore(other) {
        return other.startLineNumber >= this.endLineNumberExclusive;
    }
    delta(lineDelta) {
        return new LineRange(this.startLineNumber + lineDelta, this.lineCount);
    }
    deltaStart(lineDelta) {
        return new LineRange(this.startLineNumber + lineDelta, this.lineCount - lineDelta);
    }
    deltaEnd(lineDelta) {
        return new LineRange(this.startLineNumber, this.lineCount + lineDelta);
    }
    toString() {
        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    equals(other) {
        return this.startLineNumber === other.startLineNumber && this.lineCount === other.lineCount;
    }
    contains(other) {
        return this.startLineNumber <= other.startLineNumber && other.endLineNumberExclusive <= this.endLineNumberExclusive;
    }
    containsLine(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    getLines(document) {
        const result = new Array(this.lineCount);
        for (let i = 0; i < this.lineCount; i++) {
            result[i] = document.getLineContent(this.startLineNumber + i + 1); // note that getLineContent expects a one-based line number
        }
        return result;
    }
    toRange() {
        return vscode_languageserver_protocol_1.Range.create(this.startLineNumber, 0, this.endLineNumberExclusive, 0);
    }
    toInclusiveRange() {
        if (this.isEmpty) {
            return undefined;
        }
        return vscode_languageserver_protocol_1.Range.create(this.startLineNumber, 0, this.endLineNumberExclusive - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE);
    }
    toInclusiveRangeOrEmpty() {
        if (this.isEmpty) {
            return vscode_languageserver_protocol_1.Range.create(this.startLineNumber, 0, this.startLineNumber, 0);
        }
        return vscode_languageserver_protocol_1.Range.create(this.startLineNumber, 0, this.endLineNumberExclusive - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE);
    }
}
exports.LineRange = LineRange;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/model/live-diff.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/model/live-diff.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/model/textModelDiffs.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LiveDiff = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const range_mapping_1 = __webpack_require__(/*! ./range-mapping */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-mapping.js");
const line_range_1 = __webpack_require__(/*! ./line-range */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/line-range.js");
class LiveDiff {
    constructor(originalDocument, modifiedDocument, diffComputer) {
        this.originalDocument = originalDocument;
        this.modifiedDocument = modifiedDocument;
        this.diffComputer = diffComputer;
        this.recomputeCount = 0;
        this.stateObservable = observable_1.SettableObservable.create(0 /* LiveDiffState.Initializing */);
        this.changesObservable = observable_1.SettableObservable.create([]);
        this.toDispose = new core_1.DisposableCollection();
        const recomputeSignal = observable_1.ObservableSignal.create();
        this.toDispose.push(observable_1.Autorun.create(() => {
            recomputeSignal.get();
            this.recompute();
        }));
        this.toDispose.push(originalDocument.onDidChangeContent(() => recomputeSignal.trigger()));
        this.toDispose.push(modifiedDocument.onDidChangeContent(() => recomputeSignal.trigger()));
    }
    dispose() {
        this.toDispose.dispose();
    }
    get state() {
        return this.stateObservable.get();
    }
    get changes() {
        return this.changesObservable.get();
    }
    recompute() {
        const recomputeCount = ++this.recomputeCount;
        if (this.stateObservable.getUntracked() !== 0 /* LiveDiffState.Initializing */) { // untracked to avoid an infinite change loop in the autorun
            this.stateObservable.set(2 /* LiveDiffState.Updating */);
        }
        this.diffComputer.computeDiff(new core_1.URI(this.originalDocument.uri), new core_1.URI(this.modifiedDocument.uri)).then(diff => {
            if (this.toDispose.disposed || this.originalDocument.isDisposed() || this.modifiedDocument.isDisposed()) {
                return;
            }
            if (recomputeCount !== this.recomputeCount) {
                // There is a newer recompute call
                return;
            }
            const toLineRange = (r) => new line_range_1.LineRange(r.start, r.end - r.start);
            const changes = diff === null || diff === void 0 ? void 0 : diff.changes.map(change => {
                var _a;
                return new range_mapping_1.DetailedLineRangeMapping(toLineRange(change.left), this.originalDocument, toLineRange(change.right), this.modifiedDocument, (_a = change.innerChanges) === null || _a === void 0 ? void 0 : _a.map(innerChange => new range_mapping_1.RangeMapping(innerChange.left, innerChange.right)));
            });
            observable_1.Observable.update(() => {
                if (changes) {
                    this.stateObservable.set(1 /* LiveDiffState.UpToDate */);
                    this.changesObservable.set(changes);
                }
                else {
                    this.stateObservable.set(3 /* LiveDiffState.Error */);
                }
            });
        });
    }
}
exports.LiveDiff = LiveDiff;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-editor-model.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-editor-model.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/model/mergeEditorModel.ts,
// https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/view/viewModel.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeRangeData = exports.MergeEditorModel = exports.MergeEditorModelProps = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const diff_1 = __webpack_require__(/*! @theia/core/lib/common/diff */ "./node_modules/@theia/core/lib/common/diff.js");
const monaco_to_protocol_converter_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-to-protocol-converter */ "./node_modules/@theia/monaco/lib/browser/monaco-to-protocol-converter.js");
const merge_range_1 = __webpack_require__(/*! ./merge-range */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-range.js");
const range_mapping_1 = __webpack_require__(/*! ./range-mapping */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-mapping.js");
const live_diff_1 = __webpack_require__(/*! ./live-diff */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/live-diff.js");
const line_range_1 = __webpack_require__(/*! ./line-range */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/line-range.js");
const range_editing_1 = __webpack_require__(/*! ./range-editing */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-editing.js");
exports.MergeEditorModelProps = Symbol('MergeEditorModelProps');
let MergeEditorModel = class MergeEditorModel {
    constructor() {
        this.toDispose = new core_1.DisposableCollection();
        this.shouldRecomputeHandledState = true;
        this.mergeRangesObservable = observable_1.DerivedObservable.create(() => this.computeMergeRanges());
        this.mergeRangesDataObservable = observable_1.DerivedObservable.create(() => new Map(this.mergeRanges.map(mergeRange => [mergeRange, this.newMergeRangeData()])));
        // #region Line Range Mapping
        this.side1ToResultLineRangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentLineRangeMap(this.computeSideToResultDiff(this.side1Changes, this.resultChanges)));
        this.resultToSide1LineRangeMapObservable = observable_1.DerivedObservable.create(() => this.side1ToResultLineRangeMap.reverse());
        this.side2ToResultLineRangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentLineRangeMap(this.computeSideToResultDiff(this.side2Changes, this.resultChanges)));
        this.resultToSide2LineRangeMapObservable = observable_1.DerivedObservable.create(() => this.side2ToResultLineRangeMap.reverse());
        this.baseToSide1LineRangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentLineRangeMap(this.side1Changes));
        this.side1ToBaseLineRangeMapObservable = observable_1.DerivedObservable.create(() => this.baseToSide1LineRangeMap.reverse());
        this.baseToSide2LineRangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentLineRangeMap(this.side2Changes));
        this.side2ToBaseLineRangeMapObservable = observable_1.DerivedObservable.create(() => this.baseToSide2LineRangeMap.reverse());
        this.baseToResultLineRangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentLineRangeMap(this.resultChanges));
        this.resultToBaseLineRangeMapObservable = observable_1.DerivedObservable.create(() => this.baseToResultLineRangeMap.reverse());
        // #endregion
        // #region Range Mapping
        this.baseToSide1RangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentRangeMap(this.side1Changes.flatMap(change => change.rangeMappings)));
        this.side1ToBaseRangeMapObservable = observable_1.DerivedObservable.create(() => this.baseToSide1RangeMap.reverse());
        this.baseToSide2RangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentRangeMap(this.side2Changes.flatMap(change => change.rangeMappings)));
        this.side2ToBaseRangeMapObservable = observable_1.DerivedObservable.create(() => this.baseToSide2RangeMap.reverse());
        this.baseToResultRangeMapObservable = observable_1.DerivedObservable.create(() => this.newDocumentRangeMap(this.resultChanges.flatMap(change => change.rangeMappings)));
        this.resultToBaseRangeMapObservable = observable_1.DerivedObservable.create(() => this.baseToResultRangeMap.reverse());
        // #endregion
        this.diffComputingStateObservable = observable_1.DerivedObservable.create(() => this.getDiffComputingState(this.side1LiveDiff, this.side2LiveDiff, this.resultLiveDiff));
        this.diffComputingStateForSidesObservable = observable_1.DerivedObservable.create(() => this.getDiffComputingState(this.side1LiveDiff, this.side2LiveDiff));
        this.isUpToDateObservable = observable_1.DerivedObservable.create(() => this.diffComputingStateObservable.get() === 1 /* DiffComputingState.UpToDate */);
        this.unhandledMergeRangesCountObservable = observable_1.DerivedObservable.create(() => {
            let result = 0;
            const mergeRangesData = this.mergeRangesDataObservable.get();
            for (const mergeRangeData of mergeRangesData.values()) {
                if (!mergeRangeData.isHandledObservable.get()) {
                    result++;
                }
            }
            return result;
        });
    }
    get mergeRanges() {
        return this.mergeRangesObservable.get();
    }
    get side1ToResultLineRangeMap() {
        return this.side1ToResultLineRangeMapObservable.get();
    }
    get resultToSide1LineRangeMap() {
        return this.resultToSide1LineRangeMapObservable.get();
    }
    get side2ToResultLineRangeMap() {
        return this.side2ToResultLineRangeMapObservable.get();
    }
    get resultToSide2LineRangeMap() {
        return this.resultToSide2LineRangeMapObservable.get();
    }
    get baseToSide1LineRangeMap() {
        return this.baseToSide1LineRangeMapObservable.get();
    }
    get side1ToBaseLineRangeMap() {
        return this.side1ToBaseLineRangeMapObservable.get();
    }
    get baseToSide2LineRangeMap() {
        return this.baseToSide2LineRangeMapObservable.get();
    }
    get side2ToBaseLineRangeMap() {
        return this.side2ToBaseLineRangeMapObservable.get();
    }
    get baseToResultLineRangeMap() {
        return this.baseToResultLineRangeMapObservable.get();
    }
    get resultToBaseLineRangeMap() {
        return this.resultToBaseLineRangeMapObservable.get();
    }
    get baseToSide1RangeMap() {
        return this.baseToSide1RangeMapObservable.get();
    }
    get side1ToBaseRangeMap() {
        return this.side1ToBaseRangeMapObservable.get();
    }
    get baseToSide2RangeMap() {
        return this.baseToSide2RangeMapObservable.get();
    }
    get side2ToBaseRangeMap() {
        return this.side2ToBaseRangeMapObservable.get();
    }
    get baseToResultRangeMap() {
        return this.baseToResultRangeMapObservable.get();
    }
    get resultToBaseRangeMap() {
        return this.resultToBaseRangeMapObservable.get();
    }
    get unhandledMergeRangesCount() {
        return this.unhandledMergeRangesCountObservable.get();
    }
    get onInitialized() {
        return this._onInitialized;
    }
    get baseDocument() {
        return this.props.baseEditor.document;
    }
    get side1Document() {
        return this.props.side1Editor.document;
    }
    get side2Document() {
        return this.props.side2Editor.document;
    }
    get resultDocument() {
        return this.props.resultEditor.document;
    }
    get resultEditor() {
        return this.props.resultEditor;
    }
    get side1Changes() {
        return this.side1LiveDiff.changes;
    }
    get side2Changes() {
        return this.side2LiveDiff.changes;
    }
    get resultChanges() {
        return this.resultLiveDiff.changes;
    }
    init() {
        this.toDispose.push(this.side1LiveDiff = this.newLiveDiff(this.baseDocument, this.side1Document));
        this.toDispose.push(this.side2LiveDiff = this.newLiveDiff(this.baseDocument, this.side2Document));
        this.toDispose.push(this.resultLiveDiff = this.newLiveDiff(this.baseDocument, this.resultDocument));
        this.toDispose.push(observable_1.Observable.keepObserved(this.mergeRangesDataObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.side1ToResultLineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.resultToSide1LineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.side2ToResultLineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.resultToSide2LineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.baseToSide1LineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.side1ToBaseLineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.baseToSide2LineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.side2ToBaseLineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.baseToResultLineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.resultToBaseLineRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.baseToSide1RangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.side1ToBaseRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.baseToSide2RangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.side2ToBaseRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.baseToResultRangeMapObservable));
        this.toDispose.push(observable_1.Observable.keepObserved(this.resultToBaseRangeMapObservable));
        const initializePromise = this.doInit();
        this._onInitialized = observable_1.ObservableUtils.waitForState(this.isUpToDateObservable).then(() => initializePromise);
        initializePromise.then(() => {
            this.toDispose.push(observable_1.Autorun.create(() => {
                if (!this.isUpToDateObservable.get()) {
                    return;
                }
                observable_1.Observable.update(() => {
                    const mergeRangesData = this.mergeRangesDataObservable.get();
                    for (const [mergeRange, mergeRangeData] of mergeRangesData) {
                        const state = this.computeMergeRangeStateFromResult(mergeRange);
                        mergeRangeData.resultStateObservable.set(state);
                        if (this.shouldRecomputeHandledState) {
                            mergeRangeData.isHandledObservable.set(state !== 'Base');
                        }
                    }
                    this.shouldRecomputeHandledState = false;
                });
            }, {
                willHandleChange: ctx => {
                    if (ctx.isChangeOf(this.mergeRangesDataObservable)) {
                        this.shouldRecomputeHandledState = true;
                    }
                    return true;
                }
            }));
            const attachedHistory = new AttachedHistory(this.resultDocument);
            this.toDispose.push(attachedHistory);
            this.toDispose.push(this.resultDocument.textEditorModel.onDidChangeContent(event => {
                if (event.isRedoing || event.isUndoing) {
                    return;
                }
                // Mark merge ranges affected by content changes as handled.
                const mergeRanges = [];
                for (const change of event.changes) {
                    const { start, end } = this.translateResultRangeToBase(this.m2p.asRange(change.range));
                    const affectedMergeRanges = this.findMergeRanges(new line_range_1.LineRange(start.line, end.line - start.line));
                    for (const mergeRange of affectedMergeRanges) {
                        if (!this.isMergeRangeHandled(mergeRange)) {
                            mergeRanges.push(mergeRange);
                        }
                    }
                }
                if (mergeRanges.length === 0) {
                    return;
                }
                const markMergeRangesAsHandled = (handled) => {
                    observable_1.Observable.update(() => {
                        const mergeRangesData = this.mergeRangesDataObservable.get();
                        for (const mergeRange of mergeRanges) {
                            const mergeRangeData = mergeRangesData.get(mergeRange);
                            if (mergeRangeData) {
                                mergeRangeData.isHandledObservable.set(handled);
                            }
                        }
                    });
                };
                const element = {
                    redo: () => {
                        markMergeRangesAsHandled(true);
                    },
                    undo: () => {
                        markMergeRangesAsHandled(false);
                    }
                };
                attachedHistory.pushAttachedHistoryElement(element);
                element.redo();
            }));
        });
    }
    computeMergeRangeStateFromResult(mergeRange) {
        const resultRange = this.getLineRangeInResult(mergeRange);
        const existingLines = resultRange.getLines(this.resultDocument);
        const states = [
            'Base',
            'Side1',
            'Side2',
            'Side1Side2Smart',
            'Side2Side1Smart',
            'Side1Side2',
            'Side2Side1'
        ];
        for (const state of states) {
            const edit = mergeRange.getBaseRangeEdit(state);
            if (core_1.ArrayUtils.equals(edit.newLines, existingLines)) {
                return state;
            }
        }
        return 'Unrecognized';
    }
    async doInit() {
        var _a;
        if ((_a = this.props.options) === null || _a === void 0 ? void 0 : _a.resetResult) {
            await this.reset();
        }
    }
    dispose() {
        this.toDispose.dispose();
    }
    isDisposed() {
        return this.toDispose.disposed;
    }
    async reset() {
        await observable_1.ObservableUtils.waitForState(this.diffComputingStateForSidesObservable, state => state === 1 /* DiffComputingState.UpToDate */);
        this.shouldRecomputeHandledState = true;
        this.resultDocument.textEditorModel.setValue(this.computeAutoMergedResult());
    }
    computeAutoMergedResult() {
        const baseLines = this.baseDocument.textEditorModel.getLinesContent();
        const side1Lines = this.side1Document.textEditorModel.getLinesContent();
        const side2Lines = this.side2Document.textEditorModel.getLinesContent();
        const resultLines = [];
        function appendLinesToResult(documentLines, lineRange) {
            for (let i = lineRange.startLineNumber; i < lineRange.endLineNumberExclusive; i++) {
                resultLines.push(documentLines[i]);
            }
        }
        let baseStartLineNumber = 0;
        for (const mergeRange of this.mergeRanges) {
            appendLinesToResult(baseLines, line_range_1.LineRange.fromLineNumbers(baseStartLineNumber, mergeRange.baseRange.startLineNumber));
            if (mergeRange.side1Changes.length === 0) {
                appendLinesToResult(side2Lines, mergeRange.side2Range);
            }
            else if (mergeRange.side2Changes.length === 0) {
                appendLinesToResult(side1Lines, mergeRange.side1Range);
            }
            else if (mergeRange.isEqualChange) {
                appendLinesToResult(side1Lines, mergeRange.side1Range);
            }
            else {
                appendLinesToResult(baseLines, mergeRange.baseRange);
            }
            baseStartLineNumber = mergeRange.baseRange.endLineNumberExclusive;
        }
        appendLinesToResult(baseLines, line_range_1.LineRange.fromLineNumbers(baseStartLineNumber, baseLines.length));
        return resultLines.join(this.resultDocument.textEditorModel.getEOL());
    }
    computeMergeRanges() {
        return merge_range_1.MergeRange.computeMergeRanges(this.side1Changes, this.side2Changes, this.baseDocument, this.side1Document, this.side2Document);
    }
    hasMergeRange(mergeRange) {
        return this.mergeRangesDataObservable.get().has(mergeRange);
    }
    getMergeRangeData(mergeRange) {
        const mergeRangeData = this.mergeRangesDataObservable.get().get(mergeRange);
        if (!mergeRangeData) {
            throw new Error('Unknown merge range');
        }
        return mergeRangeData;
    }
    getMergeRangeResultState(mergeRange) {
        return this.getMergeRangeData(mergeRange).resultStateObservable.get();
    }
    applyMergeRangeAcceptedState(mergeRange, state) {
        if (!this.isUpToDateObservable.get()) {
            throw new Error('Cannot apply merge range accepted state while updating');
        }
        if (state !== 'Base' && this.getMergeRangeResultState(mergeRange) === 'Unrecognized') {
            throw new Error('Cannot apply merge range accepted state to an unrecognized result state');
        }
        const { originalRange: baseRange, modifiedRange: resultRange } = this.getResultLineRangeMapping(mergeRange);
        let newLines;
        if (state === 'Base') {
            newLines = baseRange.getLines(this.baseDocument);
        }
        else {
            if (!baseRange.equals(mergeRange.baseRange)) {
                throw new Error('Assertion error');
            }
            newLines = mergeRange.getBaseRangeEdit(state).newLines;
        }
        const resultEdit = new range_editing_1.LineRangeEdit(resultRange, newLines);
        const editOperation = resultEdit.toRangeEdit(this.resultDocument.lineCount).toMonacoEdit();
        const cursorState = this.resultEditor.getControl().getSelections();
        this.resultDocument.textEditorModel.pushStackElement();
        this.resultDocument.textEditorModel.pushEditOperations(cursorState, [editOperation], () => cursorState);
        this.resultDocument.textEditorModel.pushStackElement();
    }
    isMergeRangeHandled(mergeRange) {
        return this.getMergeRangeData(mergeRange).isHandledObservable.get();
    }
    getLineRangeInResult(mergeRange) {
        return this.getResultLineRangeMapping(mergeRange).modifiedRange;
    }
    getResultLineRangeMapping(mergeRange) {
        const projectLine = (lineNumber) => {
            let offset = 0;
            const changes = this.resultChanges;
            for (const change of changes) {
                const { originalRange } = change;
                if (originalRange.containsLine(lineNumber) || originalRange.endLineNumberExclusive === lineNumber) {
                    return change;
                }
                else if (originalRange.endLineNumberExclusive < lineNumber) {
                    offset = change.modifiedRange.endLineNumberExclusive - originalRange.endLineNumberExclusive;
                }
                else {
                    break;
                }
            }
            return lineNumber + offset;
        };
        let startBase = mergeRange.baseRange.startLineNumber;
        let startResult = projectLine(startBase);
        if (typeof startResult !== 'number') {
            startBase = startResult.originalRange.startLineNumber;
            startResult = startResult.modifiedRange.startLineNumber;
        }
        let endExclusiveBase = mergeRange.baseRange.endLineNumberExclusive;
        let endExclusiveResult = projectLine(endExclusiveBase);
        if (typeof endExclusiveResult !== 'number') {
            endExclusiveBase = endExclusiveResult.originalRange.endLineNumberExclusive;
            endExclusiveResult = endExclusiveResult.modifiedRange.endLineNumberExclusive;
        }
        return new range_mapping_1.LineRangeMapping(line_range_1.LineRange.fromLineNumbers(startBase, endExclusiveBase), line_range_1.LineRange.fromLineNumbers(startResult, endExclusiveResult));
    }
    translateBaseRangeToSide(range, side) {
        const rangeMap = side === 1 ? this.baseToSide1RangeMap : this.baseToSide2RangeMap;
        return rangeMap.projectRange(range).modifiedRange;
    }
    translateSideRangeToBase(range, side) {
        const rangeMap = side === 1 ? this.side1ToBaseRangeMap : this.side2ToBaseRangeMap;
        return rangeMap.projectRange(range).modifiedRange;
    }
    translateBaseRangeToResult(range) {
        return this.baseToResultRangeMap.projectRange(range).modifiedRange;
    }
    translateResultRangeToBase(range) {
        return this.resultToBaseRangeMap.projectRange(range).modifiedRange;
    }
    findMergeRanges(baseRange) {
        return this.mergeRanges.filter(mergeRange => mergeRange.baseRange.touches(baseRange));
    }
    computeSideToResultDiff(sideChanges, resultChanges) {
        return range_mapping_1.DocumentLineRangeMap.betweenModifiedSides(sideChanges, resultChanges).lineRangeMappings;
    }
    newMergeRangeData() {
        return new MergeRangeData();
    }
    newLiveDiff(originalDocument, modifiedDocument) {
        return new live_diff_1.LiveDiff(originalDocument, modifiedDocument, this.diffComputer);
    }
    newDocumentLineRangeMap(lineRangeMappings) {
        return new range_mapping_1.DocumentLineRangeMap(lineRangeMappings);
    }
    newDocumentRangeMap(rangeMappings) {
        return new range_mapping_1.DocumentRangeMap(rangeMappings);
    }
    getDiffComputingState(...liveDiffs) {
        const liveDiffStates = liveDiffs.map(liveDiff => liveDiff.state);
        if (liveDiffStates.some(state => state === 0 /* LiveDiffState.Initializing */)) {
            return 0 /* DiffComputingState.Initializing */;
        }
        if (liveDiffStates.some(state => state === 2 /* LiveDiffState.Updating */)) {
            return 2 /* DiffComputingState.Updating */;
        }
        return 1 /* DiffComputingState.UpToDate */;
    }
};
exports.MergeEditorModel = MergeEditorModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.MergeEditorModelProps),
    tslib_1.__metadata("design:type", Object)
], MergeEditorModel.prototype, "props", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(diff_1.DiffComputer),
    tslib_1.__metadata("design:type", Object)
], MergeEditorModel.prototype, "diffComputer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_to_protocol_converter_1.MonacoToProtocolConverter),
    tslib_1.__metadata("design:type", monaco_to_protocol_converter_1.MonacoToProtocolConverter)
], MergeEditorModel.prototype, "m2p", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], MergeEditorModel.prototype, "init", null);
exports.MergeEditorModel = MergeEditorModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MergeEditorModel);
class MergeRangeData {
    constructor() {
        this.resultStateObservable = observable_1.SettableObservable.create('Base');
        this.isHandledObservable = observable_1.SettableObservable.create(false);
    }
}
exports.MergeRangeData = MergeRangeData;
class AttachedHistory {
    constructor(model) {
        this.model = model;
        this.toDispose = new core_1.DisposableCollection();
        this.attachedHistory = [];
        let previousAltId = this.model.textEditorModel.getAlternativeVersionId();
        this.toDispose.push(model.textEditorModel.onDidChangeContent(event => {
            const currentAltId = model.textEditorModel.getAlternativeVersionId();
            if (event.isRedoing) {
                for (const item of this.attachedHistory) {
                    if (previousAltId < item.altId && item.altId <= currentAltId) {
                        item.element.redo();
                    }
                }
            }
            else if (event.isUndoing) {
                for (let i = this.attachedHistory.length - 1; i >= 0; i--) {
                    const item = this.attachedHistory[i];
                    if (currentAltId < item.altId && item.altId <= previousAltId) {
                        item.element.undo();
                    }
                }
            }
            else {
                // The user destroyed the redo stack by performing a non redo/undo operation.
                while (this.attachedHistory.length > 0
                    && this.attachedHistory[this.attachedHistory.length - 1].altId > previousAltId) {
                    this.attachedHistory.pop();
                }
            }
            previousAltId = currentAltId;
        }));
    }
    dispose() {
        this.toDispose.dispose();
    }
    pushAttachedHistoryElement(element) {
        this.attachedHistory.push({ altId: this.model.textEditorModel.getAlternativeVersionId(), element });
    }
}


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-range.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-range.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/model/modifiedBaseRange.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeRangeAcceptedState = exports.MergeRange = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "./node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const range_mapping_1 = __webpack_require__(/*! ./range-mapping */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-mapping.js");
const range_editing_1 = __webpack_require__(/*! ./range-editing */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-editing.js");
const range_utils_1 = __webpack_require__(/*! ./range-utils */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-utils.js");
/**
 * Describes modifications in side 1 and side 2 for a specific range in base.
 */
class MergeRange {
    static computeMergeRanges(side1Diff, side2Diff, baseDocument, side1Document, side2Document) {
        const alignments = range_mapping_1.MappingAlignment.computeAlignments(side1Diff, side2Diff);
        return alignments.map(alignment => new MergeRange(alignment.baseRange, baseDocument, alignment.side1Range, alignment.side1Mappings, side1Document, alignment.side2Range, alignment.side2Mappings, side2Document));
    }
    constructor(baseRange, baseDocument, side1Range, side1Changes, side1Document, side2Range, side2Changes, side2Document) {
        this.baseRange = baseRange;
        this.baseDocument = baseDocument;
        this.side1Range = side1Range;
        this.side1Changes = side1Changes;
        this.side1Document = side1Document;
        this.side2Range = side2Range;
        this.side2Changes = side2Changes;
        this.side2Document = side2Document;
        this.side1CombinedChange = range_mapping_1.DetailedLineRangeMapping.join(this.side1Changes);
        this.side2CombinedChange = range_mapping_1.DetailedLineRangeMapping.join(this.side2Changes);
        this.isEqualChange = core_1.ArrayUtils.equals(this.side1Changes, this.side2Changes, (a, b) => a.getLineEdit().equals(b.getLineEdit()));
        if (side1Changes.length === 0 && side2Changes.length === 0) {
            throw new Error('At least one change is expected');
        }
    }
    getModifiedRange(side) {
        return side === 1 ? this.side1Range : this.side2Range;
    }
    getCombinedChange(side) {
        return side === 1 ? this.side1CombinedChange : this.side2CombinedChange;
    }
    getChanges(side) {
        return side === 1 ? this.side1Changes : this.side2Changes;
    }
    get isConflicting() {
        return this.side1Changes.length > 0 && this.side2Changes.length > 0 && !this.isEqualChange;
    }
    canBeSmartCombined(firstSide) {
        return this.isConflicting && this.smartCombineChanges(firstSide) !== undefined;
    }
    get isSmartCombinationOrderRelevant() {
        const edit1 = this.smartCombineChanges(1);
        const edit2 = this.smartCombineChanges(2);
        if (!edit1 || !edit2) {
            return false;
        }
        return !edit1.equals(edit2);
    }
    getBaseRangeEdit(state) {
        if (state === 'Base') {
            return new range_editing_1.LineRangeEdit(this.baseRange, this.baseRange.getLines(this.baseDocument));
        }
        if (state === 'Side1') {
            return new range_editing_1.LineRangeEdit(this.baseRange, this.side1Range.getLines(this.side1Document));
        }
        if (state === 'Side2') {
            return new range_editing_1.LineRangeEdit(this.baseRange, this.side2Range.getLines(this.side2Document));
        }
        let edit;
        const firstSide = state.startsWith('Side1') ? 1 : 2;
        if (state.endsWith('Smart')) {
            edit = this.smartCombineChanges(firstSide);
        }
        if (!edit) {
            edit = this.dumbCombineChanges(firstSide);
        }
        return edit;
    }
    smartCombineChanges(firstSide) {
        if (firstSide === 1 && this.smartCombinationEdit1) {
            return this.smartCombinationEdit1.value;
        }
        else if (firstSide === 2 && this.smartCombinationEdit2) {
            return this.smartCombinationEdit2.value;
        }
        const combinedChanges = this.side1Changes.flatMap(change => change.rangeMappings.map(rangeMapping => ({ rangeMapping, side: 1 }))).concat(this.side2Changes.flatMap(change => change.rangeMappings.map(rangeMapping => ({ rangeMapping, side: 2 })))).sort((a, b) => {
            let result = range_utils_1.RangeUtils.compareUsingStarts(a.rangeMapping.originalRange, b.rangeMapping.originalRange);
            if (result === 0) {
                const sideWeight = (side) => side === firstSide ? 1 : 2;
                result = sideWeight(a.side) - sideWeight(b.side);
            }
            return result;
        });
        const sortedEdits = combinedChanges.map(change => {
            const modifiedDocument = change.side === 1 ? this.side1Document : this.side2Document;
            return new range_editing_1.RangeEdit(change.rangeMapping.originalRange, modifiedDocument.getText(change.rangeMapping.modifiedRange));
        });
        const edit = this.editsToLineRangeEdit(this.baseRange, sortedEdits, this.baseDocument);
        if (firstSide === 1) {
            this.smartCombinationEdit1 = { value: edit };
        }
        else {
            this.smartCombinationEdit2 = { value: edit };
        }
        return edit;
    }
    editsToLineRangeEdit(range, sortedEdits, document) {
        let text = '';
        const startsLineBefore = range.startLineNumber > 0;
        let currentPosition = startsLineBefore
            ? vscode_languageserver_protocol_1.Position.create(range.startLineNumber - 1, document.getLineMaxColumn((range.startLineNumber - 1) + 1) // note that getLineMaxColumn expects a 1-based line number
            )
            : vscode_languageserver_protocol_1.Position.create(range.startLineNumber, 0);
        for (const edit of sortedEdits) {
            const diffStart = edit.range.start;
            if (!range_utils_1.PositionUtils.isBeforeOrEqual(currentPosition, diffStart)) {
                return undefined;
            }
            let originalText = document.getText(vscode_languageserver_protocol_1.Range.create(currentPosition, diffStart));
            if (diffStart.line >= document.lineCount) {
                // getText doesn't include this virtual line break, as the document ends the line before.
                // endsLineAfter will be false.
                originalText += '\n';
            }
            text += originalText;
            text += edit.newText;
            currentPosition = edit.range.end;
        }
        const endsLineAfter = range.endLineNumberExclusive < document.lineCount;
        const end = endsLineAfter ?
            vscode_languageserver_protocol_1.Position.create(range.endLineNumberExclusive, 0) :
            vscode_languageserver_protocol_1.Position.create(range.endLineNumberExclusive - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE);
        text += document.getText(vscode_languageserver_protocol_1.Range.create(currentPosition, end));
        const lines = text.split(/\r\n|\r|\n/);
        if (startsLineBefore) {
            if (lines[0] !== '') {
                return undefined;
            }
            lines.shift();
        }
        if (endsLineAfter) {
            if (lines[lines.length - 1] !== '') {
                return undefined;
            }
            lines.pop();
        }
        return new range_editing_1.LineRangeEdit(range, lines);
    }
    dumbCombineChanges(firstSide) {
        if (firstSide === 1 && this.dumbCombinationEdit1) {
            return this.dumbCombinationEdit1;
        }
        else if (firstSide === 2 && this.dumbCombinationEdit2) {
            return this.dumbCombinationEdit2;
        }
        const modifiedLines1 = this.side1Range.getLines(this.side1Document);
        const modifiedLines2 = this.side2Range.getLines(this.side2Document);
        const combinedLines = firstSide === 1 ? modifiedLines1.concat(modifiedLines2) : modifiedLines2.concat(modifiedLines1);
        const edit = new range_editing_1.LineRangeEdit(this.baseRange, combinedLines);
        if (firstSide === 1) {
            this.dumbCombinationEdit1 = edit;
        }
        else {
            this.dumbCombinationEdit2 = edit;
        }
        return edit;
    }
}
exports.MergeRange = MergeRange;
var MergeRangeAcceptedState;
(function (MergeRangeAcceptedState) {
    function addSide(state, side, options) {
        if (state === 'Base') {
            return side === 1 ? 'Side1' : 'Side2';
        }
        if (state.includes('Side' + side)) {
            return state;
        }
        if (side === 2) {
            return (options === null || options === void 0 ? void 0 : options.smartCombination) ? 'Side1Side2Smart' : 'Side1Side2';
        }
        else {
            return (options === null || options === void 0 ? void 0 : options.smartCombination) ? 'Side2Side1Smart' : 'Side2Side1';
        }
    }
    MergeRangeAcceptedState.addSide = addSide;
    function removeSide(state, side) {
        if (!state.includes('Side' + side)) {
            return state;
        }
        if (state === 'Side' + side) {
            return 'Base';
        }
        return side === 1 ? 'Side2' : 'Side1';
    }
    MergeRangeAcceptedState.removeSide = removeSide;
})(MergeRangeAcceptedState || (exports.MergeRangeAcceptedState = MergeRangeAcceptedState = {}));


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-editing.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/model/range-editing.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/model/editing.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RangeEdit = exports.LineRangeEdit = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "./node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
/**
 * Represents an edit, expressed in whole lines:
 * At (before) {@link LineRange.startLineNumber}, delete {@link LineRange.lineCount} many lines and insert {@link newLines}.
 */
class LineRangeEdit {
    constructor(range, newLines) {
        this.range = range;
        this.newLines = newLines;
    }
    equals(other) {
        return this.range.equals(other.range) && core_1.ArrayUtils.equals(this.newLines, other.newLines);
    }
    toRangeEdit(documentLineCount) {
        if (this.range.endLineNumberExclusive < documentLineCount) {
            return new RangeEdit(vscode_languageserver_protocol_1.Range.create(this.range.startLineNumber, 0, this.range.endLineNumberExclusive, 0), this.newLines.map(s => s + '\n').join(''));
        }
        if (this.range.startLineNumber === 0) {
            return new RangeEdit(vscode_languageserver_protocol_1.Range.create(0, 0, documentLineCount - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE), this.newLines.join('\n'));
        }
        return new RangeEdit(vscode_languageserver_protocol_1.Range.create(this.range.startLineNumber - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE, documentLineCount - 1, vscode_languageserver_protocol_1.uinteger.MAX_VALUE), this.newLines.map(s => '\n' + s).join(''));
    }
}
exports.LineRangeEdit = LineRangeEdit;
class RangeEdit {
    constructor(range, newText) {
        this.range = range;
        this.newText = newText;
    }
    toMonacoEdit() {
        const { start, end } = this.range;
        return {
            range: {
                startLineNumber: start.line + 1,
                startColumn: start.character + 1,
                endLineNumber: end.line + 1,
                endColumn: end.character + 1
            },
            text: this.newText
        };
    }
}
exports.RangeEdit = RangeEdit;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-mapping.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/model/range-mapping.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/model/mapping.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentRangeMap = exports.RangeMapping = exports.DetailedLineRangeMapping = exports.MappingAlignment = exports.DocumentLineRangeMap = exports.LineRangeMapping = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const editor_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor */ "./node_modules/@theia/editor/lib/browser/editor.js");
const line_range_1 = __webpack_require__(/*! ./line-range */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/line-range.js");
const range_editing_1 = __webpack_require__(/*! ./range-editing */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-editing.js");
const range_utils_1 = __webpack_require__(/*! ./range-utils */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-utils.js");
/**
 * Maps a line range in the original text document to a line range in the modified text document.
 */
class LineRangeMapping {
    static join(mappings) {
        return mappings.reduce((acc, cur) => acc ? acc.join(cur) : cur, undefined);
    }
    constructor(originalRange, modifiedRange) {
        this.originalRange = originalRange;
        this.modifiedRange = modifiedRange;
    }
    toString() {
        return `${this.originalRange.toString()} -> ${this.modifiedRange.toString()}`;
    }
    join(other) {
        return new LineRangeMapping(this.originalRange.join(other.originalRange), this.modifiedRange.join(other.modifiedRange));
    }
    addModifiedLineDelta(delta) {
        return new LineRangeMapping(this.originalRange, this.modifiedRange.delta(delta));
    }
    addOriginalLineDelta(delta) {
        return new LineRangeMapping(this.originalRange.delta(delta), this.modifiedRange);
    }
    reverse() {
        return new LineRangeMapping(this.modifiedRange, this.originalRange);
    }
}
exports.LineRangeMapping = LineRangeMapping;
/**
 * Represents a total monotonous mapping of line ranges in one document to another document.
 */
class DocumentLineRangeMap {
    static betweenModifiedSides(side1Diff, side2Diff) {
        const alignments = MappingAlignment.computeAlignments(side1Diff, side2Diff);
        const mappings = alignments.map(alignment => new LineRangeMapping(alignment.side1Range, alignment.side2Range));
        return new DocumentLineRangeMap(mappings);
    }
    constructor(
    /**
     * The line range mappings that define this document mapping.
     * The number of lines between two adjacent original ranges must equal the number of lines between their corresponding modified ranges.
     */
    lineRangeMappings) {
        this.lineRangeMappings = lineRangeMappings;
        if (!core_1.ArrayUtils.checkAdjacentItems(lineRangeMappings, (m1, m2) => m1.originalRange.isBefore(m2.originalRange) && m1.modifiedRange.isBefore(m2.modifiedRange) &&
            m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive)) {
            throw new Error('Illegal line range mappings');
        }
    }
    /**
     * @param lineNumber 0-based line number in the original text document
     */
    projectLine(lineNumber) {
        const lastBefore = core_1.ArrayUtils.findLast(this.lineRangeMappings, m => m.originalRange.startLineNumber <= lineNumber);
        if (!lastBefore) {
            return new LineRangeMapping(new line_range_1.LineRange(lineNumber, 1), new line_range_1.LineRange(lineNumber, 1));
        }
        if (lastBefore.originalRange.containsLine(lineNumber)) {
            return lastBefore;
        }
        return new LineRangeMapping(new line_range_1.LineRange(lineNumber, 1), new line_range_1.LineRange(lineNumber + lastBefore.modifiedRange.endLineNumberExclusive - lastBefore.originalRange.endLineNumberExclusive, 1));
    }
    reverse() {
        return new DocumentLineRangeMap(this.lineRangeMappings.map(m => m.reverse()));
    }
}
exports.DocumentLineRangeMap = DocumentLineRangeMap;
/**
 * Aligns mappings for two modified sides with a common base range.
 */
class MappingAlignment {
    static computeAlignments(side1Mappings, side2Mappings) {
        const combinedMappings = side1Mappings.map(mapping => ({ source: 0, mapping })).concat(side2Mappings.map(mapping => ({ source: 1, mapping }))).sort((a, b) => line_range_1.LineRange.compareByStart(a.mapping.originalRange, b.mapping.originalRange));
        const currentMappings = [new Array(), new Array()];
        const currentDelta = [0, 0];
        const alignments = new Array();
        function pushAlignment(baseRange) {
            const mapping1 = LineRangeMapping.join(currentMappings[0]) || new LineRangeMapping(baseRange, baseRange.delta(currentDelta[0]));
            const mapping2 = LineRangeMapping.join(currentMappings[1]) || new LineRangeMapping(baseRange, baseRange.delta(currentDelta[1]));
            function getAlignedModifiedRange(m) {
                const startDelta = baseRange.startLineNumber - m.originalRange.startLineNumber;
                const endDelta = baseRange.endLineNumberExclusive - m.originalRange.endLineNumberExclusive;
                return new line_range_1.LineRange(m.modifiedRange.startLineNumber + startDelta, m.modifiedRange.lineCount - startDelta + endDelta);
            }
            alignments.push(new MappingAlignment(baseRange, getAlignedModifiedRange(mapping1), currentMappings[0], getAlignedModifiedRange(mapping2), currentMappings[1]));
            currentMappings[0] = [];
            currentMappings[1] = [];
        }
        let currentBaseRange;
        for (const current of combinedMappings) {
            const { originalRange, modifiedRange } = current.mapping;
            if (currentBaseRange && !currentBaseRange.touches(originalRange)) {
                pushAlignment(currentBaseRange);
                currentBaseRange = undefined;
            }
            currentBaseRange = currentBaseRange ? currentBaseRange.join(originalRange) : originalRange;
            currentMappings[current.source].push(current.mapping);
            currentDelta[current.source] = modifiedRange.endLineNumberExclusive - originalRange.endLineNumberExclusive;
        }
        if (currentBaseRange) {
            pushAlignment(currentBaseRange);
        }
        return alignments;
    }
    constructor(baseRange, side1Range, side1Mappings, side2Range, side2Mappings) {
        this.baseRange = baseRange;
        this.side1Range = side1Range;
        this.side1Mappings = side1Mappings;
        this.side2Range = side2Range;
        this.side2Mappings = side2Mappings;
    }
    toString() {
        return `${this.side1Range} <- ${this.baseRange} -> ${this.side2Range}`;
    }
}
exports.MappingAlignment = MappingAlignment;
/**
 * A line range mapping with inner range mappings.
 */
class DetailedLineRangeMapping extends LineRangeMapping {
    static join(mappings) {
        return mappings.reduce((acc, cur) => acc ? acc.join(cur) : cur, undefined);
    }
    constructor(originalRange, originalDocument, modifiedRange, modifiedDocument, rangeMappings) {
        super(originalRange, modifiedRange);
        this.originalDocument = originalDocument;
        this.modifiedDocument = modifiedDocument;
        this.rangeMappings = rangeMappings || [new RangeMapping(originalRange.toRange(), modifiedRange.toRange())];
    }
    join(other) {
        return new DetailedLineRangeMapping(this.originalRange.join(other.originalRange), this.originalDocument, this.modifiedRange.join(other.modifiedRange), this.modifiedDocument);
    }
    addModifiedLineDelta(delta) {
        return new DetailedLineRangeMapping(this.originalRange, this.originalDocument, this.modifiedRange.delta(delta), this.modifiedDocument, this.rangeMappings.map(m => m.addModifiedLineDelta(delta)));
    }
    addOriginalLineDelta(delta) {
        return new DetailedLineRangeMapping(this.originalRange.delta(delta), this.originalDocument, this.modifiedRange, this.modifiedDocument, this.rangeMappings.map(m => m.addOriginalLineDelta(delta)));
    }
    reverse() {
        return new DetailedLineRangeMapping(this.modifiedRange, this.modifiedDocument, this.originalRange, this.originalDocument, this.rangeMappings.map(m => m.reverse()));
    }
    getLineEdit() {
        return new range_editing_1.LineRangeEdit(this.originalRange, this.getModifiedLines());
    }
    getReverseLineEdit() {
        return new range_editing_1.LineRangeEdit(this.modifiedRange, this.getOriginalLines());
    }
    getModifiedLines() {
        return this.modifiedRange.getLines(this.modifiedDocument);
    }
    getOriginalLines() {
        return this.originalRange.getLines(this.originalDocument);
    }
}
exports.DetailedLineRangeMapping = DetailedLineRangeMapping;
/**
 * Maps a range in the original text document to a range in the modified text document.
 */
class RangeMapping {
    constructor(originalRange, modifiedRange) {
        this.originalRange = originalRange;
        this.modifiedRange = modifiedRange;
    }
    toString() {
        function rangeToString(range) {
            return `[${range.start.line}:${range.start.character}, ${range.end.line}:${range.end.character})`;
        }
        return `${rangeToString(this.originalRange)} -> ${rangeToString(this.modifiedRange)}`;
    }
    addModifiedLineDelta(deltaLines) {
        return new RangeMapping(this.originalRange, editor_1.Range.create(this.modifiedRange.start.line + deltaLines, this.modifiedRange.start.character, this.modifiedRange.end.line + deltaLines, this.modifiedRange.end.character));
    }
    addOriginalLineDelta(deltaLines) {
        return new RangeMapping(editor_1.Range.create(this.originalRange.start.line + deltaLines, this.originalRange.start.character, this.originalRange.end.line + deltaLines, this.originalRange.end.character), this.modifiedRange);
    }
    reverse() {
        return new RangeMapping(this.modifiedRange, this.originalRange);
    }
}
exports.RangeMapping = RangeMapping;
/**
 * Represents a total monotonous mapping of ranges in one document to another document.
 */
class DocumentRangeMap {
    constructor(
    /**
     * The range mappings that define this document mapping.
     */
    rangeMappings) {
        this.rangeMappings = rangeMappings;
        if (!core_1.ArrayUtils.checkAdjacentItems(rangeMappings, (m1, m2) => range_utils_1.RangeUtils.isBeforeOrTouching(m1.originalRange, m2.originalRange) &&
            range_utils_1.RangeUtils.isBeforeOrTouching(m1.modifiedRange, m2.modifiedRange))) {
            throw new Error('Illegal range mappings');
        }
    }
    /**
     * @param position position in the original text document
     */
    projectPosition(position) {
        const lastBefore = core_1.ArrayUtils.findLast(this.rangeMappings, m => range_utils_1.PositionUtils.isBeforeOrEqual(m.originalRange.start, position));
        if (!lastBefore) {
            return new RangeMapping(editor_1.Range.create(position, position), editor_1.Range.create(position, position));
        }
        if (range_utils_1.RangeUtils.containsPosition(lastBefore.originalRange, position)) {
            return lastBefore;
        }
        const relativePosition = range_utils_1.PositionUtils.relativize(lastBefore.originalRange.end, position);
        const modifiedRangePosition = range_utils_1.PositionUtils.resolve(lastBefore.modifiedRange.end, relativePosition);
        return new RangeMapping(editor_1.Range.create(position, position), editor_1.Range.create(modifiedRangePosition, modifiedRangePosition));
    }
    /**
     * @param range range in the original text document
     */
    projectRange(range) {
        const start = this.projectPosition(range.start);
        const end = this.projectPosition(range.end);
        return new RangeMapping(range_utils_1.RangeUtils.union(start.originalRange, end.originalRange), range_utils_1.RangeUtils.union(start.modifiedRange, end.modifiedRange));
    }
    reverse() {
        return new DocumentRangeMap(this.rangeMappings.map(m => m.reverse()));
    }
}
exports.DocumentRangeMap = DocumentRangeMap;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-utils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/model/range-utils.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/model/rangeUtils.ts,
// https://github.com/microsoft/vscode/blob/1.96.3/src/vs/editor/common/core/range.ts,
// https://github.com/microsoft/vscode/blob/1.96.3/src/vs/editor/common/core/position.ts,
// https://github.com/microsoft/vscode/blob/1.96.3/src/vs/editor/common/core/textLength.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PositionUtils = exports.RangeUtils = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "./node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
var RangeUtils;
(function (RangeUtils) {
    function isEmpty(range) {
        return range.start.line === range.end.line && range.start.character === range.end.character;
    }
    RangeUtils.isEmpty = isEmpty;
    function containsPosition(range, position) {
        if (position.line < range.start.line || position.line > range.end.line) {
            return false;
        }
        if (position.line === range.start.line && position.character < range.start.character) {
            return false;
        }
        if (position.line === range.end.line && position.character >= range.end.character) {
            return false;
        }
        return true;
    }
    RangeUtils.containsPosition = containsPosition;
    function isBeforeOrTouching(range, other) {
        return (range.end.line < other.start.line ||
            (range.end.line === other.start.line &&
                range.end.character <= other.start.character));
    }
    RangeUtils.isBeforeOrTouching = isBeforeOrTouching;
    function union(range, other) {
        const start = PositionUtils.isBeforeOrEqual(range.start, other.start) ? range.start : other.start;
        const end = PositionUtils.isBeforeOrEqual(range.end, other.end) ? other.end : range.end;
        return { start, end };
    }
    RangeUtils.union = union;
    /**
     * A function that compares ranges, useful for sorting ranges.
     * It will first compare ranges on the start position and then on the end position.
     */
    function compareUsingStarts(range, other) {
        if (range.start.line === other.start.line) {
            if (range.start.character === other.start.character) {
                if (range.end.line === other.end.line) {
                    return range.end.character - other.end.character;
                }
                return range.end.line - other.end.line;
            }
            return range.start.character - other.start.character;
        }
        return range.start.line - other.start.line;
    }
    RangeUtils.compareUsingStarts = compareUsingStarts;
})(RangeUtils || (exports.RangeUtils = RangeUtils = {}));
var PositionUtils;
(function (PositionUtils) {
    function isBeforeOrEqual(position, other) {
        return compare(position, other) <= 0;
    }
    PositionUtils.isBeforeOrEqual = isBeforeOrEqual;
    function compare(position, other) {
        if (position.line === other.line) {
            return position.character - other.character;
        }
        return position.line - other.line;
    }
    PositionUtils.compare = compare;
    /**
     * Given two positions, computes the relative position of the greater position against the lesser position.
     */
    function relativize(position, other) {
        if (compare(position, other) > 0) {
            [position, other] = [other, position];
        }
        if (position.line === other.line) {
            return vscode_languageserver_protocol_1.Position.create(0, other.character - position.character);
        }
        else {
            return vscode_languageserver_protocol_1.Position.create(other.line - position.line, other.character);
        }
    }
    PositionUtils.relativize = relativize;
    /**
     * Resolves the given relative position against the given position and returns the resulting position.
     */
    function resolve(position, relativePosition) {
        if (relativePosition.line === 0) {
            return vscode_languageserver_protocol_1.Position.create(position.line, position.character + relativePosition.character);
        }
        else {
            return vscode_languageserver_protocol_1.Position.create(position.line + relativePosition.line, relativePosition.character);
        }
    }
    PositionUtils.resolve = resolve;
})(PositionUtils || (exports.PositionUtils = PositionUtils = {}));


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/diff-spacers.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/diff-spacers.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiffSpacerService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
let DiffSpacerService = class DiffSpacerService {
    computeDiffSpacers(changes, originalLineCount) {
        const lineMapping = [];
        const originalSpacers = [];
        const modifiedSpacers = [];
        let originalLine = 0;
        let deltaSum = 0;
        for (const { originalRange, modifiedRange } of changes) {
            while (originalLine < originalRange.startLineNumber + Math.min(originalRange.lineCount, modifiedRange.lineCount)) {
                lineMapping[originalLine] = originalLine + deltaSum;
                originalLine++;
            }
            const delta = modifiedRange.lineCount - originalRange.lineCount;
            deltaSum += delta;
            if (delta > 0) {
                originalSpacers[originalLine] = delta;
            }
            if (delta < 0) {
                modifiedSpacers[modifiedRange.endLineNumberExclusive] = -delta;
                originalLine += -delta;
            }
        }
        while (originalLine <= originalLineCount) {
            lineMapping[originalLine] = originalLine + deltaSum;
            originalLine++;
        }
        return { originalSpacers, modifiedSpacers, lineMapping };
    }
    /**
     * Combines multiple {@link DiffSpacers} objects into a {@link CombinedMultiDiffSpacers} object with the appropriately adjusted spacers.
     * The given {@link DiffSpacers} objects are not modified.
     *
     * It is assumed that all of the given {@link DiffSpacers} objects have been computed from diffs against the same original side.
     */
    combineMultiDiffSpacers(multiDiffSpacers) {
        var _a, _b;
        if (multiDiffSpacers.length < 2) {
            throw new Error('At least two items are required');
        }
        this.checkLineMappingsHaveEqualLength(multiDiffSpacers);
        const originalSpacers = [];
        const modifiedSides = [];
        for (const { modifiedSpacers, lineMapping } of multiDiffSpacers) {
            const modifiedSpacersCopy = modifiedSpacers.concat(); // note: copying by concat() preserves empty slots of the sparse array
            modifiedSides.push({ modifiedSpacers: modifiedSpacersCopy, lineMapping });
        }
        const originalLineCount = modifiedSides[0].lineMapping.length;
        for (let originalLine = 0; originalLine < originalLineCount; originalLine++) {
            const max = Math.max(...multiDiffSpacers.map(diffSpacers => { var _a; return (_a = diffSpacers.originalSpacers[originalLine]) !== null && _a !== void 0 ? _a : 0; }));
            if (max > 0) {
                originalSpacers[originalLine] = max;
                for (let i = 0; i < multiDiffSpacers.length; i++) {
                    const delta = max - ((_a = multiDiffSpacers[i].originalSpacers[originalLine]) !== null && _a !== void 0 ? _a : 0);
                    if (delta > 0) {
                        const { modifiedSpacers, lineMapping } = modifiedSides[i];
                        const modifiedLine = this.projectLine(originalLine, lineMapping);
                        modifiedSpacers[modifiedLine] = ((_b = modifiedSpacers[modifiedLine]) !== null && _b !== void 0 ? _b : 0) + delta;
                    }
                }
            }
        }
        return { originalSpacers, modifiedSides };
    }
    /**
     * Given a {@link CombinedMultiDiffSpacers} object, excludes the original side, returning the modified sides with the appropriately adjusted spacers.
     * The given {@link CombinedMultiDiffSpacers} object is not modified.
     */
    excludeOriginalSide({ modifiedSides }) {
        if (modifiedSides.length < 2) {
            throw new Error('At least two modified sides are required');
        }
        this.checkLineMappingsHaveEqualLength(modifiedSides);
        const modifiedSidesCopy = [];
        for (const { modifiedSpacers } of modifiedSides) {
            const modifiedSpacersCopy = modifiedSpacers.concat(); // note: copying by concat() preserves empty slots of the sparse array
            modifiedSidesCopy.push({ modifiedSpacers: modifiedSpacersCopy });
        }
        // When the original side is excluded, the adjoining spacers in the modified sides can be deflated by removing their intersecting parts.
        const originalLineCount = modifiedSides[0].lineMapping.length;
        for (let originalLine = 0; originalLine < originalLineCount; originalLine++) {
            if (modifiedSides.every(({ lineMapping }) => lineMapping[originalLine] === undefined)) {
                modifiedSides.forEach(({ lineMapping }, index) => {
                    const modifiedLine = this.projectLine(originalLine, lineMapping);
                    const { modifiedSpacers } = modifiedSidesCopy[index];
                    modifiedSpacers[modifiedLine]--;
                });
            }
        }
        return { modifiedSides: modifiedSidesCopy };
    }
    checkLineMappingsHaveEqualLength(items) {
        if (!core_1.ArrayUtils.checkAdjacentItems(items, (item1, item2) => item1.lineMapping.length === item2.lineMapping.length)) {
            throw new Error('Line mappings must have equal length');
        }
    }
    projectLine(originalLine, lineMapping) {
        let modifiedLine;
        const originalLineCount = lineMapping.length;
        while (originalLine < originalLineCount) {
            modifiedLine = lineMapping[originalLine++];
            if (modifiedLine !== undefined) {
                return modifiedLine;
            }
        }
        throw new Error('Assertion failed');
    }
};
exports.DiffSpacerService = DiffSpacerService;
exports.DiffSpacerService = DiffSpacerService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DiffSpacerService);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./merge-editor-pane */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./merge-editor-pane-header */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane-header.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./merge-editor-base-pane */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-base-pane.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./merge-editor-side-pane */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-side-pane.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./merge-editor-result-pane */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-result-pane.js"), exports);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-base-pane.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-base-pane.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorBasePane = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const merge_editor_pane_1 = __webpack_require__(/*! ./merge-editor-pane */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane.js");
let MergeEditorBasePane = class MergeEditorBasePane extends merge_editor_pane_1.MergeEditorPane {
    constructor() {
        super();
        this.addClass('base');
    }
    getLineRangeForMergeRange(mergeRange) {
        return mergeRange.baseRange;
    }
    translateBaseRange(range) {
        return range;
    }
    onAfterMergeEditorSet() {
        super.onAfterMergeEditorSet();
        this.toDispose.push(observable_1.Autorun.create(() => {
            const { currentPane, side1Pane, side1Title, side2Pane, side2Title } = this.mergeEditor;
            this.header.description = currentPane === this ? '' : core_1.nls.localizeByDefault('Comparing with {0}', currentPane === side1Pane ? side1Title : currentPane === side2Pane ? side2Title : core_1.nls.localizeByDefault('Result'));
        }));
    }
    computeEditorDecorations() {
        const result = [];
        const { model, currentPane, side1Pane, side2Pane, currentMergeRange } = this.mergeEditor;
        for (const mergeRange of model.mergeRanges) {
            const lineRange = mergeRange.baseRange;
            result.push(this.toMergeRangeDecoration(lineRange, {
                isHandled: model.isMergeRangeHandled(mergeRange),
                isFocused: mergeRange === currentMergeRange,
                isAfterEnd: lineRange.startLineNumber > model.baseDocument.lineCount,
            }));
        }
        if (currentPane !== this) {
            const changes = currentPane === side1Pane ? model.side1Changes : currentPane === side2Pane ? model.side2Changes : model.resultChanges;
            result.push(...this.toChangeDecorations(changes, { diffSide: 'original' }));
        }
        return result;
    }
};
exports.MergeEditorBasePane = MergeEditorBasePane;
exports.MergeEditorBasePane = MergeEditorBasePane = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], MergeEditorBasePane);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane-header.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane-header.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorPaneHeader = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "./node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const label_parser_1 = __webpack_require__(/*! @theia/core/lib/browser/label-parser */ "./node_modules/@theia/core/lib/browser/label-parser.js");
let MergeEditorPaneHeader = class MergeEditorPaneHeader extends browser_1.ReactWidget {
    constructor() {
        super(...arguments);
        this._description = '';
        this._detail = '';
        this.handleToolbarClick = (event) => event.nativeEvent.stopImmediatePropagation();
    }
    get description() {
        return this._description;
    }
    set description(description) {
        this._description = description;
        this.update();
    }
    get detail() {
        return this._detail;
    }
    set detail(detail) {
        this._detail = detail;
        this.update();
    }
    get toolbarItems() {
        return this._toolbarItems;
    }
    set toolbarItems(toolbarItems) {
        this._toolbarItems = toolbarItems;
        this.update();
    }
    init() {
        this.addClass('header');
        this.scrollOptions = undefined;
        this.node.tabIndex = -1;
        this.toDispose.push((0, browser_1.onDomEvent)(this.node, 'click', () => this.activate()));
        this.title.changed.connect(this.update, this);
    }
    onActivateRequest(msg) {
        var _a;
        super.onActivateRequest(msg);
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.activate();
    }
    render() {
        return (React.createElement(React.Fragment, null,
            React.createElement("span", { className: 'title' }, this.renderWithIcons(this.title.label)),
            React.createElement("span", { className: 'description' }, this.renderWithIcons(this.description)),
            React.createElement("span", { className: 'detail' }, this.renderWithIcons(this.detail)),
            React.createElement("span", { className: 'toolbar', onClick: this.handleToolbarClick }, this.toolbarItems.map(toolbarItem => this.renderToolbarItem(toolbarItem)))));
    }
    renderWithIcons(text) {
        const result = [];
        const labelParts = this.labelParser.parse(text);
        labelParts.forEach((labelPart, index) => {
            if (typeof labelPart === 'string') {
                result.push(labelPart);
            }
            else {
                result.push(React.createElement("span", { key: index, className: (0, browser_1.codicon)(labelPart.name) }));
            }
        });
        return result;
    }
    renderToolbarItem({ id, label, tooltip, className, onClick }) {
        return React.createElement("span", { key: id, title: tooltip, onClick: onClick, className: className }, label);
    }
};
exports.MergeEditorPaneHeader = MergeEditorPaneHeader;
tslib_1.__decorate([
    (0, inversify_1.inject)(label_parser_1.LabelParser),
    tslib_1.__metadata("design:type", label_parser_1.LabelParser)
], MergeEditorPaneHeader.prototype, "labelParser", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], MergeEditorPaneHeader.prototype, "init", null);
exports.MergeEditorPaneHeader = MergeEditorPaneHeader = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MergeEditorPaneHeader);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorPane = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "./node_modules/@theia/editor/lib/browser/index.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "./node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const monaco_to_protocol_converter_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-to-protocol-converter */ "./node_modules/@theia/monaco/lib/browser/monaco-to-protocol-converter.js");
const monaco_editor_core_1 = __webpack_require__(/*! @theia/monaco-editor-core */ "./node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const merge_editor_pane_header_1 = __webpack_require__(/*! ./merge-editor-pane-header */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane-header.js");
const range_utils_1 = __webpack_require__(/*! ../../model/range-utils */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/range-utils.js");
const scm_colors_1 = __webpack_require__(/*! ../../../scm-colors */ "./node_modules/@theia/scm/lib/browser/scm-colors.js");
let MergeEditorPane = class MergeEditorPane extends browser_1.BoxPanel {
    get editor() {
        return monaco_editor_1.MonacoEditor.get(this.editorWidget);
    }
    constructor() {
        super({ spacing: 0 });
        this.toDispose = new core_1.DisposableCollection();
        this.addClass('editor-pane');
    }
    init() {
        this.cursorPositionObservable = observable_1.ObservableFromEvent.create(this.editor.onCursorPositionChanged, () => this.editor.cursor);
        this.cursorLineObservable = observable_1.DerivedObservable.create(() => this.cursorPositionObservable.get().line);
        this.selectionObservable = observable_1.ObservableFromEvent.create(this.editor.getControl().onDidChangeCursorSelection, () => {
            const selections = this.editor.getControl().getSelections();
            return selections === null || selections === void 0 ? void 0 : selections.map(selection => this.m2p.asRange(selection));
        });
        browser_1.BoxPanel.setStretch(this.header, 0);
        browser_1.BoxPanel.setStretch(this.editorWidget, 1);
        this.addWidget(this.header);
        this.addWidget(this.editorWidget);
    }
    dispose() {
        super.dispose();
        this.toDispose.dispose();
    }
    get mergeEditor() {
        return this._mergeEditor;
    }
    set mergeEditor(mergeEditor) {
        if (this._mergeEditor) {
            throw new Error('Merge editor has already been set');
        }
        this._mergeEditor = mergeEditor;
        this.onAfterMergeEditorSet();
    }
    onAfterMergeEditorSet() {
        this.initContextKeys();
        const toolbarItems = observable_1.DerivedObservable.create(() => this.getToolbarItems());
        this.toDispose.push(observable_1.Autorun.create(() => {
            this.header.toolbarItems = toolbarItems.get();
        }));
        this.initSelectionSynchronizer();
        let decorationIds = [];
        const decorations = observable_1.DerivedObservable.create(() => this.computeEditorDecorations());
        const isVisible = observable_1.ObservableFromEvent.create(this.editorWidget.onDidChangeVisibility, () => this.editorWidget.isVisible);
        this.toDispose.push(observable_1.Autorun.create(() => {
            if (this.mergeEditor.isShown && isVisible.get()) {
                decorationIds = this.editor.deltaDecorations({ oldDecorations: decorationIds, newDecorations: decorations.get() });
            }
        }));
        this.toDispose.push(core_1.Disposable.create(() => decorationIds = this.editor.deltaDecorations({ oldDecorations: decorationIds, newDecorations: [] })));
    }
    get cursorPosition() {
        return this.cursorPositionObservable.get();
    }
    get cursorLine() {
        return this.cursorLineObservable.get();
    }
    get selection() {
        return this.selectionObservable.get();
    }
    goToMergeRange(mergeRange, options) {
        var _a;
        const { editor } = this;
        const { startLineNumber, endLineNumberExclusive } = this.getLineRangeForMergeRange(mergeRange);
        editor.cursor = { line: startLineNumber, character: 0 };
        const reveal = (_a = options === null || options === void 0 ? void 0 : options.reveal) !== null && _a !== void 0 ? _a : true;
        if (reveal) {
            editor.getControl().revealLinesNearTop(startLineNumber + 1, endLineNumberExclusive + 1);
        }
    }
    getToolbarItems() {
        return [];
    }
    computeEditorDecorations() {
        return [];
    }
    toMergeRangeDecoration(lineRange, { isHandled, isFocused, isAfterEnd }) {
        const blockClassNames = ['merge-range'];
        let blockPadding = [0, 0, 0, 0];
        if (isHandled) {
            blockClassNames.push('handled');
        }
        if (isFocused) {
            blockClassNames.push('focused');
            blockPadding = [0, 2, 0, 2];
        }
        return {
            range: lineRange.toInclusiveRangeOrEmpty(),
            options: {
                blockClassName: blockClassNames.join(' '),
                blockPadding,
                blockIsAfterEnd: isAfterEnd,
                minimap: {
                    position: browser_2.MinimapPosition.Gutter,
                    color: { id: isHandled ? scm_colors_1.ScmColors.handledConflictMinimapOverviewRulerColor : scm_colors_1.ScmColors.unhandledConflictMinimapOverviewRulerColor },
                },
                overviewRuler: {
                    position: browser_2.OverviewRulerLane.Center,
                    color: { id: isHandled ? scm_colors_1.ScmColors.handledConflictMinimapOverviewRulerColor : scm_colors_1.ScmColors.unhandledConflictMinimapOverviewRulerColor },
                },
                showIfCollapsed: true,
                stickiness: browser_2.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            }
        };
    }
    toChangeDecorations(changes, { diffSide }) {
        const result = [];
        for (const change of changes) {
            const changeRange = (diffSide === 'original' ? change.originalRange : change.modifiedRange).toInclusiveRange();
            if (changeRange) {
                result.push({
                    range: changeRange,
                    options: {
                        className: 'diff',
                        isWholeLine: true,
                        stickiness: browser_2.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    }
                });
            }
            for (const rangeMapping of change.rangeMappings) {
                const range = diffSide === 'original' ? rangeMapping.originalRange : rangeMapping.modifiedRange;
                result.push({
                    range,
                    options: {
                        className: range_utils_1.RangeUtils.isEmpty(range) ? 'diff-empty-word' : 'diff-word',
                        showIfCollapsed: true,
                        stickiness: browser_2.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    },
                });
            }
        }
        return result;
    }
    initContextKeys() {
        const editor = this.editor.getControl();
        editor.createContextKey('isMergeEditor', true);
        editor.createContextKey('mergeEditorBaseUri', this.mergeEditor.baseUri.toString());
        editor.createContextKey('mergeEditorResultUri', this.mergeEditor.resultUri.toString());
    }
    initSelectionSynchronizer() {
        const selectionObservable = observable_1.DerivedObservable.create(() => {
            const { selectionInBase, currentPane } = this.mergeEditor;
            if (!selectionInBase || currentPane === this) {
                return [];
            }
            return selectionInBase.map(range => this.translateBaseRange(range));
        });
        this.toDispose.push(observable_1.Autorun.create(() => {
            const selection = selectionObservable.get();
            if (selection.length) {
                this.editor.getControl().setSelections(selection.map(({ start, end }) => new monaco_editor_core_1.Selection(start.line + 1, start.character + 1, end.line + 1, end.character + 1)));
            }
        }));
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.editorWidget.activate();
    }
};
exports.MergeEditorPane = MergeEditorPane;
tslib_1.__decorate([
    (0, inversify_1.inject)(merge_editor_pane_header_1.MergeEditorPaneHeader),
    tslib_1.__metadata("design:type", merge_editor_pane_header_1.MergeEditorPaneHeader)
], MergeEditorPane.prototype, "header", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorWidget),
    tslib_1.__metadata("design:type", browser_2.EditorWidget)
], MergeEditorPane.prototype, "editorWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_to_protocol_converter_1.MonacoToProtocolConverter),
    tslib_1.__metadata("design:type", monaco_to_protocol_converter_1.MonacoToProtocolConverter)
], MergeEditorPane.prototype, "m2p", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], MergeEditorPane.prototype, "init", null);
exports.MergeEditorPane = MergeEditorPane = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], MergeEditorPane);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-result-pane.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-result-pane.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorResultPane = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const merge_editor_pane_1 = __webpack_require__(/*! ./merge-editor-pane */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane.js");
let MergeEditorResultPane = class MergeEditorResultPane extends merge_editor_pane_1.MergeEditorPane {
    constructor() {
        super();
        this.addClass('result');
    }
    initContextKeys() {
        super.initContextKeys();
        this.editor.getControl().createContextKey('isMergeResultEditor', true);
    }
    getLineRangeForMergeRange(mergeRange) {
        return this.mergeEditor.model.getLineRangeInResult(mergeRange);
    }
    translateBaseRange(range) {
        return this.mergeEditor.model.translateBaseRangeToResult(range);
    }
    goToNextUnhandledMergeRange() {
        this.mergeEditor.goToNextMergeRange(mergeRange => !this.mergeEditor.model.isMergeRangeHandled(mergeRange));
        this.mergeEditor.activate();
    }
    reset() {
        new browser_1.ConfirmDialog({
            title: core_1.nls.localize('theia/scm/mergeEditor/resetConfirmationTitle', 'Do you really want to reset the merge result in this editor?'),
            msg: core_1.nls.localize('theia/scm/mergeEditor/resetConfirmationMessage', 'This action cannot be undone.'),
            ok: browser_1.Dialog.YES,
            cancel: browser_1.Dialog.NO,
        }).open().then(async (confirmed) => {
            if (confirmed) {
                this.activate();
                const { model } = this.mergeEditor;
                await model.reset();
                await observable_1.ObservableUtils.waitForState(model.isUpToDateObservable);
                this.mergeEditor.goToFirstMergeRange(mergeRange => !model.isMergeRangeHandled(mergeRange));
            }
        }).catch(e => console.error(e));
    }
    getToolbarItems() {
        const { model } = this.mergeEditor;
        const { unhandledMergeRangesCount } = model;
        return [
            {
                id: 'nextConflict',
                label: unhandledMergeRangesCount === 1 ?
                    core_1.nls.localizeByDefault('{0} Conflict Remaining', unhandledMergeRangesCount) :
                    core_1.nls.localizeByDefault('{0} Conflicts Remaining ', unhandledMergeRangesCount),
                tooltip: unhandledMergeRangesCount ?
                    core_1.nls.localizeByDefault('Go to next conflict') :
                    core_1.nls.localizeByDefault('All conflicts handled, the merge can be completed now.'),
                className: browser_1.ACTION_ITEM + (unhandledMergeRangesCount ? '' : ' ' + browser_1.DISABLED_CLASS),
                onClick: unhandledMergeRangesCount ?
                    () => this.goToNextUnhandledMergeRange() :
                    undefined
            },
            {
                id: 'reset',
                tooltip: core_1.nls.localizeByDefault('Reset'),
                className: (0, browser_1.codicon)('discard', true),
                onClick: () => this.reset()
            }
        ];
    }
    computeEditorDecorations() {
        const result = [];
        const { model, currentMergeRange } = this.mergeEditor;
        for (const mergeRange of model.mergeRanges) {
            if (mergeRange) {
                const lineRange = model.getLineRangeInResult(mergeRange);
                result.push(this.toMergeRangeDecoration(lineRange, {
                    isHandled: model.isMergeRangeHandled(mergeRange),
                    isFocused: mergeRange === currentMergeRange,
                    isAfterEnd: lineRange.startLineNumber > model.resultDocument.lineCount,
                }));
            }
        }
        result.push(...this.toChangeDecorations(model.resultChanges, { diffSide: 'modified' }));
        return result;
    }
};
exports.MergeEditorResultPane = MergeEditorResultPane;
exports.MergeEditorResultPane = MergeEditorResultPane = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], MergeEditorResultPane);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-side-pane.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-side-pane.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorSide2Pane = exports.MergeEditorSide1Pane = exports.MergeEditorSidePane = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const merge_range_1 = __webpack_require__(/*! ../../model/merge-range */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-range.js");
const merge_editor_pane_1 = __webpack_require__(/*! ./merge-editor-pane */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-panes/merge-editor-pane.js");
let MergeEditorSidePane = class MergeEditorSidePane extends merge_editor_pane_1.MergeEditorPane {
    constructor() {
        super();
        this.addClass('side');
    }
    getLineRangeForMergeRange(mergeRange) {
        return mergeRange.getModifiedRange(this.mergeSide);
    }
    translateBaseRange(range) {
        return this.mergeEditor.model.translateBaseRangeToSide(range, this.mergeSide);
    }
    async acceptAllChanges() {
        const { model, resultPane } = this.mergeEditor;
        resultPane.activate();
        const selections = resultPane.editor.getControl().getSelections();
        for (const mergeRange of model.mergeRanges) {
            await observable_1.ObservableUtils.waitForState(model.isUpToDateObservable);
            resultPane.goToMergeRange(mergeRange, { reveal: false });
            let state = model.getMergeRangeResultState(mergeRange);
            if (state === 'Unrecognized') {
                state = 'Base';
            }
            model.applyMergeRangeAcceptedState(mergeRange, merge_range_1.MergeRangeAcceptedState.addSide(state, this.mergeSide));
        }
        if (selections) {
            resultPane.editor.getControl().setSelections(selections);
        }
    }
    compareWithBase() {
        let label = this.labelProvider.getName(this.editor.uri);
        if (label) {
            label += ': ';
        }
        label += `${core_1.nls.localizeByDefault('Base')} ⟷ ${this.header.title.label}`;
        const options = { selection: { start: this.editor.cursor } };
        (0, browser_1.open)(this.openerService, browser_1.DiffUris.encode(this.mergeEditor.baseUri, this.editor.uri, label), options).catch(e => {
            console.error(e);
        });
    }
    getToolbarItems() {
        return [
            {
                id: 'acceptAllChanges',
                tooltip: core_1.nls.localizeByDefault(this.mergeSide === 1 ? 'Accept All Changes from Left' : 'Accept All Changes from Right'),
                className: (0, browser_1.codicon)('check-all', true),
                onClick: () => this.acceptAllChanges()
            },
            {
                id: 'compareWithBase',
                tooltip: core_1.nls.localizeByDefault('Compare With Base'),
                className: (0, browser_1.codicon)('compare-changes', true),
                onClick: () => this.compareWithBase()
            }
        ];
    }
    computeEditorDecorations() {
        const result = [];
        const { model, currentMergeRange } = this.mergeEditor;
        const document = this.mergeSide === 1 ? model.side1Document : model.side2Document;
        for (const mergeRange of model.mergeRanges) {
            const lineRange = mergeRange.getModifiedRange(this.mergeSide);
            result.push(this.toMergeRangeDecoration(lineRange, {
                isHandled: model.isMergeRangeHandled(mergeRange),
                isFocused: mergeRange === currentMergeRange,
                isAfterEnd: lineRange.startLineNumber > document.lineCount,
            }));
        }
        const changes = this.mergeSide === 1 ? model.side1Changes : model.side2Changes;
        result.push(...this.toChangeDecorations(changes, { diffSide: 'modified' }));
        return result;
    }
};
exports.MergeEditorSidePane = MergeEditorSidePane;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], MergeEditorSidePane.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.OpenerService),
    tslib_1.__metadata("design:type", Object)
], MergeEditorSidePane.prototype, "openerService", void 0);
exports.MergeEditorSidePane = MergeEditorSidePane = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], MergeEditorSidePane);
let MergeEditorSide1Pane = class MergeEditorSide1Pane extends MergeEditorSidePane {
    constructor() {
        super();
        this.mergeSide = 1;
        this.addClass('side1');
    }
};
exports.MergeEditorSide1Pane = MergeEditorSide1Pane;
exports.MergeEditorSide1Pane = MergeEditorSide1Pane = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], MergeEditorSide1Pane);
let MergeEditorSide2Pane = class MergeEditorSide2Pane extends MergeEditorSidePane {
    constructor() {
        super();
        this.mergeSide = 2;
        this.addClass('side2');
    }
};
exports.MergeEditorSide2Pane = MergeEditorSide2Pane;
exports.MergeEditorSide2Pane = MergeEditorSide2Pane = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], MergeEditorSide2Pane);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-scroll-sync.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-scroll-sync.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/view/scrollSynchronizer.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorScrollSync = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
class MergeEditorScrollSync {
    constructor(mergeEditor) {
        this.mergeEditor = mergeEditor;
        this.toDispose = new core_1.DisposableCollection();
        this.isSyncing = false;
        const { side1Pane, side2Pane, resultPane, basePane } = mergeEditor;
        const syncingHandler = (handler) => (event) => {
            if (this.isSyncing) {
                return;
            }
            this.isSyncing = true;
            try {
                handler(event);
            }
            finally {
                this.isSyncing = false;
            }
        };
        this.toDispose.push(side1Pane.editor.getControl().onDidScrollChange(syncingHandler(event => {
            if (event.scrollTopChanged) {
                this.handleSide1ScrollTopChanged(event.scrollTop);
            }
            if (event.scrollLeftChanged) {
                basePane.editor.getControl().setScrollLeft(event.scrollLeft);
                side2Pane.editor.getControl().setScrollLeft(event.scrollLeft);
                resultPane.editor.getControl().setScrollLeft(event.scrollLeft);
            }
        })));
        this.toDispose.push(side2Pane.editor.getControl().onDidScrollChange(syncingHandler(event => {
            if (event.scrollTopChanged) {
                this.handleSide2ScrollTopChanged(event.scrollTop);
            }
            if (event.scrollLeftChanged) {
                basePane.editor.getControl().setScrollLeft(event.scrollLeft);
                side1Pane.editor.getControl().setScrollLeft(event.scrollLeft);
                resultPane.editor.getControl().setScrollLeft(event.scrollLeft);
            }
        })));
        this.toDispose.push(resultPane.editor.getControl().onDidScrollChange(syncingHandler(event => {
            if (event.scrollTopChanged) {
                this.handleResultScrollTopChanged(event.scrollTop);
            }
            if (event.scrollLeftChanged) {
                basePane.editor.getControl().setScrollLeft(event.scrollLeft);
                side1Pane.editor.getControl().setScrollLeft(event.scrollLeft);
                side2Pane.editor.getControl().setScrollLeft(event.scrollLeft);
            }
        })));
        this.toDispose.push(basePane.editor.getControl().onDidScrollChange(syncingHandler(event => {
            if (event.scrollTopChanged) {
                this.handleBaseScrollTopChanged(event.scrollTop);
            }
            if (event.scrollLeftChanged) {
                side1Pane.editor.getControl().setScrollLeft(event.scrollLeft);
                side2Pane.editor.getControl().setScrollLeft(event.scrollLeft);
                resultPane.editor.getControl().setScrollLeft(event.scrollLeft);
            }
        })));
    }
    dispose() {
        this.toDispose.dispose();
    }
    storeScrollState() {
        return this.mergeEditor.side1Pane.editor.getControl().getScrollTop();
    }
    restoreScrollState(state) {
        if (typeof state === 'number') {
            const scrollTop = this.mergeEditor.side1Pane.editor.getControl().getScrollTop();
            if (state !== scrollTop) {
                this.mergeEditor.side1Pane.editor.getControl().setScrollTop(state);
            }
            else {
                this.update();
            }
        }
    }
    update() {
        if (this.isSyncing) {
            return;
        }
        this.isSyncing = true;
        try {
            const scrollTop = this.mergeEditor.side1Pane.editor.getControl().getScrollTop();
            this.handleSide1ScrollTopChanged(scrollTop);
        }
        finally {
            this.isSyncing = false;
        }
    }
    handleSide1ScrollTopChanged(scrollTop) {
        const { side1Pane, side2Pane, resultPane, basePane, shouldAlignBase, shouldAlignResult, model } = this.mergeEditor;
        side2Pane.editor.getControl().setScrollTop(scrollTop);
        if (shouldAlignResult) {
            resultPane.editor.getControl().setScrollTop(scrollTop);
        }
        else {
            const targetScrollTop = this.computeTargetScrollTop(side1Pane.editor, resultPane.editor, model.side1ToResultLineRangeMap);
            resultPane.editor.getControl().setScrollTop(targetScrollTop);
        }
        if (shouldAlignBase) {
            basePane.editor.getControl().setScrollTop(scrollTop);
        }
        else {
            const targetScrollTop = this.computeTargetScrollTop(side1Pane.editor, basePane.editor, model.side1ToBaseLineRangeMap);
            basePane.editor.getControl().setScrollTop(targetScrollTop);
        }
    }
    handleSide2ScrollTopChanged(scrollTop) {
        const { side1Pane, side2Pane, resultPane, basePane, shouldAlignBase, shouldAlignResult, model } = this.mergeEditor;
        side1Pane.editor.getControl().setScrollTop(scrollTop);
        if (shouldAlignResult) {
            resultPane.editor.getControl().setScrollTop(scrollTop);
        }
        else {
            const targetScrollTop = this.computeTargetScrollTop(side2Pane.editor, resultPane.editor, model.side2ToResultLineRangeMap);
            resultPane.editor.getControl().setScrollTop(targetScrollTop);
        }
        if (shouldAlignBase) {
            basePane.editor.getControl().setScrollTop(scrollTop);
        }
        else {
            const targetScrollTop = this.computeTargetScrollTop(side2Pane.editor, basePane.editor, model.side2ToBaseLineRangeMap);
            basePane.editor.getControl().setScrollTop(targetScrollTop);
        }
    }
    handleResultScrollTopChanged(scrollTop) {
        const { side1Pane, side2Pane, resultPane, basePane, shouldAlignBase, shouldAlignResult, model } = this.mergeEditor;
        if (shouldAlignResult) {
            side1Pane.editor.getControl().setScrollTop(scrollTop);
            side2Pane.editor.getControl().setScrollTop(scrollTop);
        }
        else {
            const targetScrollTop = this.computeTargetScrollTop(resultPane.editor, side1Pane.editor, model.resultToSide1LineRangeMap);
            side1Pane.editor.getControl().setScrollTop(targetScrollTop);
            side2Pane.editor.getControl().setScrollTop(targetScrollTop);
            if (shouldAlignBase) {
                basePane.editor.getControl().setScrollTop(targetScrollTop);
            }
        }
        if (!shouldAlignBase) {
            const targetScrollTop = this.computeTargetScrollTop(resultPane.editor, basePane.editor, model.resultToBaseLineRangeMap);
            basePane.editor.getControl().setScrollTop(targetScrollTop);
        }
    }
    handleBaseScrollTopChanged(scrollTop) {
        const { side1Pane, side2Pane, resultPane, basePane, shouldAlignBase, shouldAlignResult, model } = this.mergeEditor;
        if (shouldAlignBase) {
            side1Pane.editor.getControl().setScrollTop(scrollTop);
            side2Pane.editor.getControl().setScrollTop(scrollTop);
        }
        else {
            const targetScrollTop = this.computeTargetScrollTop(basePane.editor, side1Pane.editor, model.baseToSide1LineRangeMap);
            side1Pane.editor.getControl().setScrollTop(targetScrollTop);
            side2Pane.editor.getControl().setScrollTop(targetScrollTop);
            if (shouldAlignResult) {
                resultPane.editor.getControl().setScrollTop(targetScrollTop);
            }
        }
        if (!shouldAlignResult) {
            const targetScrollTop = this.computeTargetScrollTop(basePane.editor, resultPane.editor, model.baseToResultLineRangeMap);
            resultPane.editor.getControl().setScrollTop(targetScrollTop);
        }
    }
    computeTargetScrollTop(sourceEditor, targetEditor, lineRangeMap) {
        const visibleRanges = sourceEditor.getVisibleRanges();
        if (visibleRanges.length === 0) {
            return 0;
        }
        const topLineNumber = visibleRanges[0].start.line;
        const scrollTop = sourceEditor.getControl().getScrollTop();
        let sourceStartTopPx;
        let sourceEndPx;
        let targetStartTopPx;
        let targetEndPx;
        if (topLineNumber === 0 && scrollTop <= sourceEditor.getControl().getTopForLineNumber(1)) { // special case: scrollTop is before or at the top of the first line
            sourceStartTopPx = 0;
            sourceEndPx = sourceEditor.getControl().getTopForLineNumber(1);
            targetStartTopPx = 0;
            targetEndPx = targetEditor.getControl().getTopForLineNumber(1);
        }
        else {
            const { originalRange: sourceRange, modifiedRange: targetRange } = lineRangeMap.projectLine(Math.max(topLineNumber - 1, 0));
            sourceStartTopPx = sourceEditor.getControl().getTopForLineNumber(sourceRange.startLineNumber + 1);
            sourceEndPx = sourceEditor.getControl().getTopForLineNumber(sourceRange.endLineNumberExclusive + 1);
            targetStartTopPx = targetEditor.getControl().getTopForLineNumber(targetRange.startLineNumber + 1);
            targetEndPx = targetEditor.getControl().getTopForLineNumber(targetRange.endLineNumberExclusive + 1);
        }
        const factor = Math.min(sourceEndPx === sourceStartTopPx ? 0 : (scrollTop - sourceStartTopPx) / (sourceEndPx - sourceStartTopPx), 1);
        const targetScrollTop = targetStartTopPx + (targetEndPx - targetStartTopPx) * factor;
        return targetScrollTop;
    }
}
exports.MergeEditorScrollSync = MergeEditorScrollSync;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-view-zones.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-editor-view-zones.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeEditorSpacerZone = exports.MergeEditorActionZonePlaceholder = exports.MergeEditorActionZone = exports.MergeEditorViewZoneComputer = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "./node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const merge_range_actions_1 = __webpack_require__(/*! ./merge-range-actions */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-range-actions.js");
const diff_spacers_1 = __webpack_require__(/*! ./diff-spacers */ "./node_modules/@theia/scm/lib/browser/merge-editor/view/diff-spacers.js");
let MergeEditorViewZoneComputer = class MergeEditorViewZoneComputer {
    computeViewZones(mergeEditor) {
        const baseViewZones = [];
        const side1ViewZones = [];
        const side2ViewZones = [];
        const resultViewZones = [];
        const { model, shouldAlignResult, shouldAlignBase } = mergeEditor;
        for (const mergeRange of model.mergeRanges) {
            const { side1Pane, side2Pane, resultPane } = mergeEditor;
            const actions = this.newMergeRangeActions(mergeEditor, mergeRange);
            let resultActionZoneHeight = this.getActionZoneMinHeight(resultPane);
            if (actions.hasSideActions || (shouldAlignResult && actions.hasResultActions)) {
                let actionZoneHeight = Math.max(this.getActionZoneMinHeight(side1Pane), this.getActionZoneMinHeight(side2Pane));
                if (shouldAlignResult) {
                    resultActionZoneHeight = actionZoneHeight = Math.max(actionZoneHeight, resultActionZoneHeight);
                }
                side1ViewZones.push(this.newActionZone(side1Pane, actions.side1ActionsObservable, mergeRange.side1Range.startLineNumber - 1, actionZoneHeight));
                side2ViewZones.push(this.newActionZone(side2Pane, actions.side2ActionsObservable, mergeRange.side2Range.startLineNumber - 1, actionZoneHeight));
                if (shouldAlignBase) {
                    baseViewZones.push(this.newActionZonePlaceholder(mergeRange.baseRange.startLineNumber - 1, actionZoneHeight));
                }
            }
            if (actions.hasResultActions) {
                resultViewZones.push(this.newActionZone(resultPane, actions.resultActionsObservable, model.getLineRangeInResult(mergeRange).startLineNumber - 1, resultActionZoneHeight));
            }
            else if (shouldAlignResult && actions.hasSideActions) {
                resultViewZones.push(this.newActionZonePlaceholder(model.getLineRangeInResult(mergeRange).startLineNumber - 1, resultActionZoneHeight));
            }
        }
        const baseLineCount = model.baseDocument.lineCount;
        const multiDiffSpacers = [];
        multiDiffSpacers.push(this.diffSpacerService.computeDiffSpacers(model.side1Changes, baseLineCount));
        multiDiffSpacers.push(this.diffSpacerService.computeDiffSpacers(model.side2Changes, baseLineCount));
        if (shouldAlignResult) {
            multiDiffSpacers.push(this.diffSpacerService.computeDiffSpacers(model.resultChanges, baseLineCount));
        }
        const combinedMultiDiffSpacers = this.diffSpacerService.combineMultiDiffSpacers(multiDiffSpacers);
        if (shouldAlignBase) {
            this.createSpacerZones(combinedMultiDiffSpacers.originalSpacers, baseViewZones);
        }
        const { modifiedSides } = shouldAlignBase ? combinedMultiDiffSpacers : this.diffSpacerService.excludeOriginalSide(combinedMultiDiffSpacers);
        this.createSpacerZones(modifiedSides[0].modifiedSpacers, side1ViewZones);
        this.createSpacerZones(modifiedSides[1].modifiedSpacers, side2ViewZones);
        if (shouldAlignResult) {
            this.createSpacerZones(modifiedSides[2].modifiedSpacers, resultViewZones);
        }
        return { baseViewZones, side1ViewZones, side2ViewZones, resultViewZones };
    }
    createSpacerZones(spacers, viewZones) {
        const lineNumbers = Object.keys(spacers).map(Number); // note: spacers is a sparse array
        for (const lineNumber of lineNumbers) {
            const heightInLines = spacers[lineNumber];
            if (heightInLines) {
                viewZones.push(this.newSpacerZone(lineNumber - 1, heightInLines));
            }
        }
    }
    newMergeRangeActions(mergeEditor, mergeRange) {
        return new merge_range_actions_1.MergeRangeActions(mergeEditor, mergeRange);
    }
    getActionZoneMinHeight(pane) {
        return pane.editor.getControl().getOption(monaco.editor.EditorOption.lineHeight);
    }
    newActionZone(pane, actions, afterLineNumber, heightInPx) {
        return new MergeEditorActionZone(pane, actions, afterLineNumber, heightInPx);
    }
    newActionZonePlaceholder(afterLineNumber, heightInPx) {
        return new MergeEditorActionZonePlaceholder(afterLineNumber, heightInPx);
    }
    newSpacerZone(afterLineNumber, heightInLines) {
        return new MergeEditorSpacerZone(afterLineNumber, heightInLines);
    }
};
exports.MergeEditorViewZoneComputer = MergeEditorViewZoneComputer;
tslib_1.__decorate([
    (0, inversify_1.inject)(diff_spacers_1.DiffSpacerService),
    tslib_1.__metadata("design:type", diff_spacers_1.DiffSpacerService)
], MergeEditorViewZoneComputer.prototype, "diffSpacerService", void 0);
exports.MergeEditorViewZoneComputer = MergeEditorViewZoneComputer = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MergeEditorViewZoneComputer);
class MergeEditorActionZone {
    constructor(pane, actionsObservable, afterLineNumber, heightInPx) {
        this.pane = pane;
        this.actionsObservable = actionsObservable;
        this.afterLineNumber = afterLineNumber;
        this.heightInPx = heightInPx;
    }
    create(ctx) {
        const overlayWidgetNode = document.createElement('div');
        overlayWidgetNode.className = 'action-zone';
        ctx.createViewZone({
            domNode: document.createElement('div'),
            afterLineNumber: this.afterLineNumber + 1, // + 1, since line numbers in Monaco are 1-based
            heightInPx: this.heightInPx,
            onComputedHeight: height => overlayWidgetNode.style.height = `${height}px`,
            onDomNodeTop: top => overlayWidgetNode.style.top = `${top}px`
        });
        const editor = this.pane.editor.getControl();
        const setLeftPosition = () => overlayWidgetNode.style.left = editor.getLayoutInfo().contentLeft + 'px';
        setLeftPosition();
        ctx.register(editor.onDidLayoutChange(setLeftPosition));
        const overlayWidgetId = `mergeEditorActionZone${MergeEditorActionZone.counter++}`;
        const overlayWidget = {
            getId: () => overlayWidgetId,
            getDomNode: () => overlayWidgetNode,
            // eslint-disable-next-line no-null/no-null
            getPosition: () => null
        };
        editor.addOverlayWidget(overlayWidget);
        ctx.register(core_1.Disposable.create(() => {
            editor.removeOverlayWidget(overlayWidget);
        }));
        const actionContainer = document.createElement('div');
        actionContainer.className = 'codelens-decoration';
        overlayWidgetNode.appendChild(actionContainer);
        ctx.register(observable_1.Autorun.create(() => this.renderActions(actionContainer, this.actionsObservable.get())));
    }
    ;
    renderActions(parent, actions) {
        const children = [];
        let isFirst = true;
        for (const action of actions) {
            if (isFirst) {
                isFirst = false;
            }
            else {
                const actionSeparator = document.createElement('span');
                actionSeparator.append('\u00a0|\u00a0');
                children.push(actionSeparator);
            }
            const title = this.getActionTitle(action);
            if (action.run) {
                const actionLink = document.createElement('a');
                actionLink.role = 'button';
                actionLink.onclick = () => action.run();
                if (action.tooltip) {
                    actionLink.title = action.tooltip;
                }
                actionLink.append(title);
                children.push(actionLink);
            }
            else {
                const actionLabel = document.createElement('span');
                if (action.tooltip) {
                    actionLabel.title = action.tooltip;
                }
                actionLabel.append(title);
                children.push(actionLabel);
            }
        }
        parent.innerText = ''; // reset children
        parent.append(...children);
    }
    getActionTitle(action) {
        return action.text;
    }
}
exports.MergeEditorActionZone = MergeEditorActionZone;
MergeEditorActionZone.counter = 0;
class MergeEditorActionZonePlaceholder {
    constructor(afterLineNumber, heightInPx) {
        this.afterLineNumber = afterLineNumber;
        this.heightInPx = heightInPx;
    }
    create(ctx) {
        const domNode = document.createElement('div');
        domNode.className = 'action-zone-placeholder';
        ctx.createViewZone({
            afterLineNumber: this.afterLineNumber + 1, // + 1, since line numbers in Monaco are 1-based
            heightInPx: this.heightInPx,
            domNode
        });
    }
}
exports.MergeEditorActionZonePlaceholder = MergeEditorActionZonePlaceholder;
class MergeEditorSpacerZone {
    constructor(afterLineNumber, heightInLines) {
        this.afterLineNumber = afterLineNumber;
        this.heightInLines = heightInLines;
    }
    create(ctx) {
        const domNode = document.createElement('div');
        domNode.className = 'diagonal-fill';
        ctx.createViewZone({
            afterLineNumber: this.afterLineNumber + 1, // + 1, since line numbers in Monaco are 1-based
            heightInLines: this.heightInLines,
            domNode
        });
    }
}
exports.MergeEditorSpacerZone = MergeEditorSpacerZone;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-range-actions.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/merge-editor/view/merge-range-actions.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2025 1C-Soft LLC and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/1.96.3/src/vs/workbench/contrib/mergeEditor/browser/view/conflictActions.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeRangeActions = void 0;
const observable_1 = __webpack_require__(/*! @theia/core/lib/common/observable */ "./node_modules/@theia/core/lib/common/observable/index.js");
const merge_range_1 = __webpack_require__(/*! ../model/merge-range */ "./node_modules/@theia/scm/lib/browser/merge-editor/model/merge-range.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
class MergeRangeActions {
    get hasSideActions() { return this.hasSideActionsObservable.get(); }
    get hasResultActions() { return this.hasResultActionsObservable.get(); }
    constructor(mergeEditor, mergeRange) {
        this.mergeEditor = mergeEditor;
        this.mergeRange = mergeRange;
        this.side1ActionsObservable = observable_1.DerivedObservable.create(() => this.getActionsForSide(1));
        this.side2ActionsObservable = observable_1.DerivedObservable.create(() => this.getActionsForSide(2));
        this.resultActionsObservable = observable_1.DerivedObservable.create(() => this.getResultActions());
        this.hasSideActionsObservable = observable_1.DerivedObservable.create(() => this.side1ActionsObservable.get().length + this.side2ActionsObservable.get().length > 0);
        this.hasResultActionsObservable = observable_1.DerivedObservable.create(() => this.resultActionsObservable.get().length > 0);
    }
    getActionsForSide(side) {
        const { mergeEditor, mergeRange } = this;
        const { model, side1Title, side2Title } = mergeEditor;
        if (!model.hasMergeRange(mergeRange)) {
            return [];
        }
        const result = [];
        const sideTitle = side === 1 ? side1Title : side2Title;
        const state = model.getMergeRangeResultState(mergeRange);
        if (state !== 'Unrecognized' && !state.includes('Side' + side)) {
            if (state !== 'Base' || mergeRange.getChanges(side).length) {
                result.push({
                    text: core_1.nls.localizeByDefault('Accept {0}', sideTitle),
                    tooltip: core_1.nls.localizeByDefault('Accept {0} in the result document.', sideTitle),
                    run: () => this.applyMergeRangeAcceptedState(mergeRange, merge_range_1.MergeRangeAcceptedState.addSide(state, side))
                });
            }
            if (mergeRange.canBeSmartCombined(side)) {
                result.push({
                    text: mergeRange.isSmartCombinationOrderRelevant ?
                        core_1.nls.localizeByDefault('Accept Combination ({0} First)', sideTitle) :
                        core_1.nls.localizeByDefault('Accept Combination'),
                    tooltip: core_1.nls.localizeByDefault('Accept an automatic combination of both sides in the result document.'),
                    run: () => this.applyMergeRangeAcceptedState(mergeRange, merge_range_1.MergeRangeAcceptedState.addSide(side === 1 ? 'Side1' : 'Side2', side === 1 ? 2 : 1, { smartCombination: true }))
                });
            }
        }
        return result;
    }
    getResultActions() {
        const { mergeEditor, mergeRange } = this;
        const { model, side1Title, side2Title } = mergeEditor;
        if (!model.hasMergeRange(mergeRange)) {
            return [];
        }
        const result = [];
        const state = model.getMergeRangeResultState(mergeRange);
        if (state === 'Unrecognized') {
            result.push({
                text: core_1.nls.localizeByDefault('Manual Resolution'),
                tooltip: core_1.nls.localizeByDefault('This conflict has been resolved manually.')
            });
            result.push({
                text: core_1.nls.localizeByDefault('Reset to base'),
                tooltip: core_1.nls.localizeByDefault('Reset this conflict to the common ancestor of both the right and left changes.'),
                run: () => this.applyMergeRangeAcceptedState(mergeRange, 'Base')
            });
        }
        else if (state === 'Base') {
            result.push({
                text: core_1.nls.localizeByDefault('No Changes Accepted'),
                tooltip: core_1.nls.localizeByDefault('The current resolution of this conflict equals the common ancestor of both the right and left changes.')
            });
            if (!model.isMergeRangeHandled(mergeRange)) {
                result.push({
                    text: core_1.nls.localizeByDefault('Mark as Handled'),
                    run: () => this.applyMergeRangeAcceptedState(mergeRange, state)
                });
            }
        }
        else {
            const labels = [];
            const stateToggles = [];
            if (state.includes('Side1')) {
                labels.push(side1Title);
                stateToggles.push({
                    text: core_1.nls.localizeByDefault('Remove {0}', side1Title),
                    tooltip: core_1.nls.localizeByDefault('Remove {0} from the result document.', side1Title),
                    run: () => this.applyMergeRangeAcceptedState(mergeRange, merge_range_1.MergeRangeAcceptedState.removeSide(state, 1))
                });
            }
            if (state.includes('Side2')) {
                labels.push(side2Title);
                stateToggles.push({
                    text: core_1.nls.localizeByDefault('Remove {0}', side2Title),
                    tooltip: core_1.nls.localizeByDefault('Remove {0} from the result document.', side2Title),
                    run: () => this.applyMergeRangeAcceptedState(mergeRange, merge_range_1.MergeRangeAcceptedState.removeSide(state, 2))
                });
            }
            if (state.startsWith('Side2')) {
                labels.reverse();
                stateToggles.reverse();
            }
            if (labels.length) {
                result.push({
                    text: labels.join(' + ')
                });
            }
            result.push(...stateToggles);
        }
        return result;
    }
    async applyMergeRangeAcceptedState(mergeRange, state) {
        const { model, resultPane } = this.mergeEditor;
        resultPane.activate();
        await observable_1.ObservableUtils.waitForState(model.isUpToDateObservable);
        resultPane.goToMergeRange(mergeRange, { reveal: false }); // set the cursor state that will be restored when undoing the operation
        model.applyMergeRangeAcceptedState(mergeRange, state);
        await observable_1.ObservableUtils.waitForState(model.isUpToDateObservable);
        resultPane.goToMergeRange(mergeRange, { reveal: false }); // set the resulting cursor state
    }
}
exports.MergeRangeActions = MergeRangeActions;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-amend-component.js":
/*!********************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-amend-component.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2019 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmAmendComponent = void 0;
__webpack_require__(/*! ../../src/browser/style/scm-amend-component.css */ "./node_modules/@theia/scm/src/browser/style/scm-amend-component.css");
const React = __webpack_require__(/*! @theia/core/shared/react */ "./node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "./node_modules/@theia/core/lib/common/nls.js");
const TRANSITION_TIME_MS = 300;
const REPOSITORY_STORAGE_KEY = 'scmRepository';
class ScmAmendComponent extends React.Component {
    constructor(props) {
        super(props);
        /**
         * a hint on how to animate an update, set by certain user action handlers
         * and used when updating the view based on a repository change
         */
        this.transitionHint = 'none';
        this.lastCommitHeight = 0;
        this.lastCommitScrollRef = (instance) => {
            if (instance && this.lastCommitHeight === 0) {
                this.lastCommitHeight = instance.getBoundingClientRect().height;
            }
        };
        this.toDisposeOnUnmount = new core_1.DisposableCollection();
        /**
         * This function will update the 'model' (lastCommit, amendingCommits) only
         * when the repository sees the last commit change.
         * 'render' can be called at any time, so be sure we don't update any 'model'
         * fields until we actually start the transition.
         */
        this.amend = async () => {
            if (this.state.transition.state !== 'none' && this.transitionHint !== 'none') {
                return;
            }
            this.transitionHint = 'amend';
            await this.resetAndSetMessage('HEAD~', 'HEAD');
        };
        this.unamend = async () => {
            if (this.state.transition.state !== 'none' && this.transitionHint !== 'none') {
                return;
            }
            const commitToRestore = (this.state.amendingCommits.length >= 1)
                ? this.state.amendingCommits[this.state.amendingCommits.length - 1]
                : undefined;
            const oldestAmendCommit = (this.state.amendingCommits.length >= 2)
                ? this.state.amendingCommits[this.state.amendingCommits.length - 2]
                : undefined;
            if (commitToRestore) {
                const commitToUseForMessage = oldestAmendCommit
                    ? oldestAmendCommit.commit.id
                    : undefined;
                this.transitionHint = 'unamend';
                await this.resetAndSetMessage(commitToRestore.commit.id, commitToUseForMessage);
            }
        };
        this.unamendAll = () => this.doUnamendAll();
        this.clearAmending = () => this.doClearAmending();
        this.state = {
            transition: { state: 'none' },
            amendingCommits: [],
            lastCommit: undefined
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            if (!this.toDisposeOnUnmount.disposed) {
                setState(newState);
            }
        };
    }
    async componentDidMount() {
        this.toDisposeOnUnmount.push(core_1.Disposable.create(() => { }));
        const lastCommit = await this.getLastCommit();
        this.setState({ amendingCommits: await this.buildAmendingList(lastCommit ? lastCommit.commit : undefined), lastCommit });
        if (this.toDisposeOnUnmount.disposed) {
            return;
        }
        this.toDisposeOnUnmount.push(this.props.repository.provider.onDidChange(() => this.fetchStatusAndSetState()));
    }
    componentWillUnmount() {
        this.toDisposeOnUnmount.dispose();
    }
    async fetchStatusAndSetState() {
        const storageKey = this.getStorageKey();
        const nextCommit = await this.getLastCommit();
        if (nextCommit && this.state.lastCommit && nextCommit.commit.id === this.state.lastCommit.commit.id) {
            // No change here
        }
        else if (nextCommit === undefined && this.state.lastCommit === undefined) {
            // No change here
        }
        else if (this.transitionHint === 'none') {
            // If the 'last' commit changes, but we are not expecting an 'amend'
            // or 'unamend' to occur, then we clear out the list of amended commits.
            // This is because an unexpected change has happened to the repository,
            // perhaps the user committed, merged, or something.  The amended commits
            // will no longer be valid.
            // Note that there may or may not have been a previous lastCommit (if the
            // repository was previously empty with no initial commit then lastCommit
            // will be undefined).  Either way we clear the amending commits.
            await this.clearAmendingCommits();
            // There is a change to the last commit, but no transition hint so
            // the view just updates without transition.
            this.setState({ amendingCommits: [], lastCommit: nextCommit });
        }
        else {
            const amendingCommits = this.state.amendingCommits.concat([]); // copy the array
            const direction = this.transitionHint === 'amend' ? 'up' : 'down';
            switch (this.transitionHint) {
                case 'amend':
                    if (this.state.lastCommit) {
                        amendingCommits.push(this.state.lastCommit);
                        const serializedState = JSON.stringify({
                            amendingHeadCommitSha: amendingCommits[0].commit.id,
                            latestCommitSha: nextCommit ? nextCommit.commit.id : undefined
                        });
                        this.props.storageService.setData(storageKey, serializedState);
                    }
                    break;
                case 'unamend':
                    amendingCommits.pop();
                    if (amendingCommits.length === 0) {
                        this.props.storageService.setData(storageKey, undefined);
                    }
                    else {
                        const serializedState = JSON.stringify({
                            amendingHeadCommitSha: amendingCommits[0].commit.id,
                            latestCommitSha: nextCommit ? nextCommit.commit.id : undefined
                        });
                        this.props.storageService.setData(storageKey, serializedState);
                    }
                    break;
            }
            if (this.state.lastCommit && nextCommit) {
                const transitionData = { direction, previousLastCommit: this.state.lastCommit };
                this.setState({ lastCommit: nextCommit, amendingCommits, transition: { ...transitionData, state: 'start' } });
                this.onNextFrame(() => {
                    this.setState({ transition: { ...transitionData, state: 'transitioning' } });
                });
                setTimeout(() => {
                    this.setState({ transition: { state: 'none' } });
                }, TRANSITION_TIME_MS);
            }
            else {
                // No previous last commit so no transition
                this.setState({ transition: { state: 'none' }, amendingCommits, lastCommit: nextCommit });
            }
        }
        this.transitionHint = 'none';
    }
    async clearAmendingCommits() {
        const storageKey = this.getStorageKey();
        await this.props.storageService.setData(storageKey, undefined);
    }
    async buildAmendingList(lastCommit) {
        const storageKey = this.getStorageKey();
        const storedState = await this.props.storageService.getData(storageKey, undefined);
        // Restore list of commits from saved amending head commit up through parents until the
        // current commit.  (If we don't reach the current commit, the repository has been changed in such
        // a way then unamending commits can no longer be done).
        if (storedState) {
            const { amendingHeadCommitSha, latestCommitSha } = JSON.parse(storedState);
            if (!this.commitsAreEqual(lastCommit, latestCommitSha)) {
                // The head commit in the repository has changed.  It is not the same commit that was the
                // head commit after the last 'amend'.
                return [];
            }
            const commits = await this.props.scmAmendSupport.getInitialAmendingCommits(amendingHeadCommitSha, lastCommit ? lastCommit.id : undefined);
            const amendingCommitPromises = commits.map(async (commit) => {
                const avatar = await this.props.avatarService.getAvatar(commit.authorEmail);
                return { commit, avatar };
            });
            return Promise.all(amendingCommitPromises);
        }
        else {
            return [];
        }
    }
    getStorageKey() {
        return REPOSITORY_STORAGE_KEY + ':' + this.props.repository.provider.rootUri;
    }
    /**
     * Commits are equal if the ids are equal or if both are undefined.
     * (If a commit is undefined, it represents the initial empty state of a repository,
     * before the initial commit).
     */
    commitsAreEqual(lastCommit, savedLastCommitId) {
        return lastCommit
            ? lastCommit.id === savedLastCommitId
            : savedLastCommitId === undefined;
    }
    async resetAndSetMessage(commitToRestore, commitToUseForMessage) {
        const message = commitToUseForMessage
            ? await this.props.scmAmendSupport.getMessage(commitToUseForMessage)
            : '';
        await this.props.scmAmendSupport.reset(commitToRestore);
        this.props.setCommitMessage(message);
    }
    render() {
        const neverShrink = this.state.amendingCommits.length <= 3;
        const style = neverShrink
            ? {
                ...this.props.style,
                flexShrink: 0,
            }
            : {
                ...this.props.style,
                flexShrink: 1,
                minHeight: 240 // height with three commits
            };
        return (React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_CONTAINER + ' no-select', style: style },
            this.state.amendingCommits.length > 0 || (this.state.lastCommit && this.state.transition.state !== 'none' && this.state.transition.direction === 'down')
                ? this.renderAmendingCommits()
                : '',
            this.state.lastCommit ?
                React.createElement("div", null,
                    React.createElement("div", { id: 'lastCommit', className: 'theia-scm-amend' },
                        React.createElement("div", { className: 'theia-header scm-theia-header' }, nls_1.nls.localize('theia/scm/amendHeadCommit', 'HEAD Commit')),
                        this.renderLastCommit()))
                : ''));
    }
    async getLastCommit() {
        const commit = await this.props.scmAmendSupport.getLastCommit();
        if (commit) {
            const avatar = await this.props.avatarService.getAvatar(commit.authorEmail);
            return { commit, avatar };
        }
        return undefined;
    }
    renderAmendingCommits() {
        const neverShrink = this.state.amendingCommits.length <= 3;
        const style = neverShrink
            ? {
                flexShrink: 0,
            }
            : {
                flexShrink: 1,
                // parent minHeight controls height, we just need any value smaller than
                // what the height would be when the parent is at its minHeight
                minHeight: 0
            };
        return React.createElement("div", { id: 'amendedCommits', className: 'theia-scm-amend-outer-container', style: style },
            React.createElement("div", { className: 'theia-header scm-theia-header' },
                React.createElement("div", { className: 'noWrapInfo' }, "Commits being Amended"),
                this.renderAmendCommitListButtons(),
                this.renderCommitCount(this.state.amendingCommits.length)),
            React.createElement("div", { style: this.styleAmendedCommits() },
                this.state.amendingCommits.map((commitData, index, array) => this.renderCommitBeingAmended(commitData, index === array.length - 1)),
                this.state.lastCommit && this.state.transition.state !== 'none' && this.state.transition.direction === 'down'
                    ? this.renderCommitBeingAmended(this.state.lastCommit, false)
                    : ''));
    }
    renderAmendCommitListButtons() {
        return React.createElement("div", { className: 'theia-scm-inline-actions-container' },
            React.createElement("div", { className: 'theia-scm-inline-actions' },
                React.createElement("div", { className: 'theia-scm-inline-action' },
                    React.createElement("a", { className: (0, browser_1.codicon)('dash'), title: 'Unamend All Commits', onClick: this.unamendAll })),
                React.createElement("div", { className: 'theia-scm-inline-action' },
                    React.createElement("a", { className: (0, browser_1.codicon)('close'), title: 'Clear Amending Commits', onClick: this.clearAmending }))));
    }
    renderLastCommit() {
        if (!this.state.lastCommit) {
            return '';
        }
        const canAmend = true;
        return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AND_BUTTON, style: { flexGrow: 0, flexShrink: 0 }, key: this.state.lastCommit.commit.id },
            this.renderLastCommitNoButton(this.state.lastCommit),
            canAmend
                ? React.createElement("div", { className: ScmAmendComponent.Styles.FLEX_CENTER },
                    React.createElement("button", { className: 'theia-button', title: nls_1.nls.localize('theia/scm/amendLastCommit', 'Amend last commit'), onClick: this.amend }, nls_1.nls.localize('theia/scm/amend', 'Amend')))
                : '');
    }
    renderLastCommitNoButton(lastCommit) {
        switch (this.state.transition.state) {
            case 'none':
                return React.createElement("div", { ref: this.lastCommitScrollRef, className: 'theia-scm-scrolling-container' }, this.renderCommitAvatarAndDetail(lastCommit));
            case 'start':
            case 'transitioning':
                switch (this.state.transition.direction) {
                    case 'up':
                        return React.createElement("div", { style: this.styleLastCommitMovingUp(this.state.transition.state) },
                            this.renderCommitAvatarAndDetail(this.state.transition.previousLastCommit),
                            this.renderCommitAvatarAndDetail(lastCommit));
                    case 'down':
                        return React.createElement("div", { style: this.styleLastCommitMovingDown(this.state.transition.state) },
                            this.renderCommitAvatarAndDetail(lastCommit),
                            this.renderCommitAvatarAndDetail(this.state.transition.previousLastCommit));
                }
        }
    }
    /**
     * See https://stackoverflow.com/questions/26556436/react-after-render-code
     *
     * @param callback
     */
    onNextFrame(callback) {
        setTimeout(() => window.requestAnimationFrame(callback), 0);
    }
    renderCommitAvatarAndDetail(commitData) {
        const { commit, avatar } = commitData;
        return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AVATAR_AND_TEXT, key: commit.id },
            React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_MESSAGE_AVATAR },
                React.createElement("img", { src: avatar })),
            React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_DETAILS },
                React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_MESSAGE_SUMMARY }, commit.summary),
                React.createElement("div", { className: ScmAmendComponent.Styles.LAST_COMMIT_MESSAGE_TIME }, `${commit.authorDateRelative} by ${commit.authorName}`)));
    }
    renderCommitCount(commits) {
        return React.createElement("div", { className: 'notification-count-container scm-change-count' },
            React.createElement("span", { className: 'notification-count' }, commits));
    }
    renderCommitBeingAmended(commitData, isOldestAmendCommit) {
        if (isOldestAmendCommit && this.state.transition.state !== 'none' && this.state.transition.direction === 'up') {
            return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AVATAR_AND_TEXT, style: { flexGrow: 0, flexShrink: 0 }, key: commitData.commit.id },
                React.createElement("div", { className: 'fixed-height-commit-container' }, this.renderCommitAvatarAndDetail(commitData)));
        }
        else {
            return React.createElement("div", { className: ScmAmendComponent.Styles.COMMIT_AVATAR_AND_TEXT, style: { flexGrow: 0, flexShrink: 0 }, key: commitData.commit.id },
                this.renderCommitAvatarAndDetail(commitData),
                isOldestAmendCommit
                    ? React.createElement("div", { className: ScmAmendComponent.Styles.FLEX_CENTER },
                        React.createElement("button", { className: 'theia-button', title: nls_1.nls.localize('theia/scm/unamendCommit', 'Unamend commit'), onClick: this.unamend }, nls_1.nls.localize('theia/scm/unamend', 'Unamend')))
                    : '');
        }
    }
    /*
     * The style for the <div> containing the list of commits being amended.
     * This div is scrollable.
     */
    styleAmendedCommits() {
        const base = {
            display: 'flex',
            whitespace: 'nowrap',
            width: '100%',
            minHeight: 0,
            flexShrink: 1,
            paddingTop: '2px',
        };
        switch (this.state.transition.state) {
            case 'none':
                return {
                    ...base,
                    flexDirection: 'column',
                    overflowY: 'auto',
                    marginBottom: '0',
                };
            case 'start':
            case 'transitioning':
                let startingMargin = 0;
                let endingMargin = 0;
                switch (this.state.transition.direction) {
                    case 'down':
                        startingMargin = 0;
                        endingMargin = -32;
                        break;
                    case 'up':
                        startingMargin = -32;
                        endingMargin = 0;
                        break;
                }
                switch (this.state.transition.state) {
                    case 'start':
                        return {
                            ...base,
                            flexDirection: 'column',
                            overflowY: 'hidden',
                            marginBottom: `${startingMargin}px`,
                        };
                    case 'transitioning':
                        return {
                            ...base,
                            flexDirection: 'column',
                            overflowY: 'hidden',
                            marginBottom: `${endingMargin}px`,
                            transitionProperty: 'margin-bottom',
                            transitionDuration: `${TRANSITION_TIME_MS}ms`,
                            transitionTimingFunction: 'linear'
                        };
                }
        }
    }
    styleLastCommitMovingUp(transitionState) {
        return this.styleLastCommit(transitionState, 0, -28);
    }
    styleLastCommitMovingDown(transitionState) {
        return this.styleLastCommit(transitionState, -28, 0);
    }
    styleLastCommit(transitionState, startingMarginTop, startingMarginBottom) {
        const base = {
            display: 'flex',
            width: '100%',
            overflow: 'hidden',
            paddingTop: 0,
            paddingBottom: 0,
            borderTop: 0,
            borderBottom: 0,
            height: this.lastCommitHeight * 2
        };
        // We end with top and bottom margins switched
        const endingMarginTop = startingMarginBottom;
        const endingMarginBottom = startingMarginTop;
        switch (transitionState) {
            case 'start':
                return {
                    ...base,
                    position: 'relative',
                    flexDirection: 'column',
                    marginTop: startingMarginTop,
                    marginBottom: startingMarginBottom,
                };
            case 'transitioning':
                return {
                    ...base,
                    position: 'relative',
                    flexDirection: 'column',
                    marginTop: endingMarginTop,
                    marginBottom: endingMarginBottom,
                    transitionProperty: 'margin-top margin-bottom',
                    transitionDuration: `${TRANSITION_TIME_MS}ms`,
                    transitionTimingFunction: 'linear'
                };
        }
    }
    async doUnamendAll() {
        while (this.state.amendingCommits.length > 0) {
            this.unamend();
            await new Promise(resolve => setTimeout(resolve, TRANSITION_TIME_MS));
        }
    }
    async doClearAmending() {
        await this.clearAmendingCommits();
        this.setState({ amendingCommits: [] });
    }
}
exports.ScmAmendComponent = ScmAmendComponent;
(function (ScmAmendComponent) {
    let Styles;
    (function (Styles) {
        Styles.COMMIT_CONTAINER = 'theia-scm-commit-container';
        Styles.COMMIT_AND_BUTTON = 'theia-scm-commit-and-button';
        Styles.COMMIT_AVATAR_AND_TEXT = 'theia-scm-commit-avatar-and-text';
        Styles.COMMIT_DETAILS = 'theia-scm-commit-details';
        Styles.COMMIT_MESSAGE_AVATAR = 'theia-scm-commit-message-avatar';
        Styles.COMMIT_MESSAGE_SUMMARY = 'theia-scm-commit-message-summary';
        Styles.LAST_COMMIT_MESSAGE_TIME = 'theia-scm-commit-message-time';
        Styles.FLEX_CENTER = 'theia-scm-flex-container-center';
    })(Styles = ScmAmendComponent.Styles || (ScmAmendComponent.Styles = {}));
})(ScmAmendComponent || (exports.ScmAmendComponent = ScmAmendComponent = {}));


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-amend-widget.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-amend-widget.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmAmendWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmAmendWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "./node_modules/@theia/core/lib/common/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "./node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "./node_modules/@theia/scm/lib/browser/scm-service.js");
const scm_avatar_service_1 = __webpack_require__(/*! ./scm-avatar-service */ "./node_modules/@theia/scm/lib/browser/scm-avatar-service.js");
const scm_amend_component_1 = __webpack_require__(/*! ./scm-amend-component */ "./node_modules/@theia/scm/lib/browser/scm-amend-component.js");
let ScmAmendWidget = ScmAmendWidget_1 = class ScmAmendWidget extends browser_1.ReactWidget {
    constructor(contextMenuRenderer) {
        super();
        this.contextMenuRenderer = contextMenuRenderer;
        this.shouldScrollToRow = true;
        this.setInputValue = (event) => {
            const repository = this.scmService.selectedRepository;
            if (repository) {
                repository.input.value = typeof event === 'string' ? event : event.currentTarget.value;
            }
        };
        this.scrollOptions = {
            suppressScrollX: true,
            minScrollbarLength: 35
        };
        this.id = ScmAmendWidget_1.ID;
    }
    render() {
        const repository = this.scmService.selectedRepository;
        if (repository && repository.provider.amendSupport) {
            return React.createElement(scm_amend_component_1.ScmAmendComponent, {
                key: `amend:${repository.provider.rootUri}`,
                style: { flexGrow: 0 },
                repository: repository,
                scmAmendSupport: repository.provider.amendSupport,
                setCommitMessage: this.setInputValue,
                avatarService: this.avatarService,
                storageService: this.storageService,
            });
        }
    }
};
exports.ScmAmendWidget = ScmAmendWidget;
ScmAmendWidget.ID = 'scm-amend-widget';
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmAmendWidget.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_avatar_service_1.ScmAvatarService),
    tslib_1.__metadata("design:type", scm_avatar_service_1.ScmAvatarService)
], ScmAmendWidget.prototype, "avatarService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StorageService),
    tslib_1.__metadata("design:type", Object)
], ScmAmendWidget.prototype, "storageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.SelectionService),
    tslib_1.__metadata("design:type", common_1.SelectionService)
], ScmAmendWidget.prototype, "selectionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], ScmAmendWidget.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], ScmAmendWidget.prototype, "keybindings", void 0);
exports.ScmAmendWidget = ScmAmendWidget = ScmAmendWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [browser_1.ContextMenuRenderer])
], ScmAmendWidget);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-avatar-service.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-avatar-service.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmAvatarService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const ts_md5_1 = __webpack_require__(/*! ts-md5 */ "./node_modules/ts-md5/dist/esm/index.js");
let ScmAvatarService = class ScmAvatarService {
    async getAvatar(email) {
        const hash = ts_md5_1.Md5.hashStr(email);
        return `https://www.gravatar.com/avatar/${hash}?d=robohash`;
    }
};
exports.ScmAvatarService = ScmAvatarService;
exports.ScmAvatarService = ScmAvatarService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmAvatarService);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-colors.js":
/*!***********************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-colors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {


// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmColors = void 0;
var ScmColors;
(function (ScmColors) {
    ScmColors.editorGutterModifiedBackground = 'editorGutter.modifiedBackground';
    ScmColors.editorGutterAddedBackground = 'editorGutter.addedBackground';
    ScmColors.editorGutterDeletedBackground = 'editorGutter.deletedBackground';
    ScmColors.handledConflictMinimapOverviewRulerColor = 'mergeEditor.conflict.handled.minimapOverViewRuler';
    ScmColors.unhandledConflictMinimapOverviewRulerColor = 'mergeEditor.conflict.unhandled.minimapOverViewRuler';
})(ScmColors || (exports.ScmColors = ScmColors = {}));


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-commit-widget.js":
/*!******************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-commit-widget.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmCommitWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmCommitWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "./node_modules/@theia/core/lib/common/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "./node_modules/@theia/core/shared/react/index.js");
const react_textarea_autosize_1 = __webpack_require__(/*! react-textarea-autosize */ "./node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js");
const scm_input_1 = __webpack_require__(/*! ./scm-input */ "./node_modules/@theia/scm/lib/browser/scm-input.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "./node_modules/@theia/scm/lib/browser/scm-service.js");
let ScmCommitWidget = ScmCommitWidget_1 = class ScmCommitWidget extends browser_1.ReactWidget {
    constructor(contextMenuRenderer) {
        super();
        this.contextMenuRenderer = contextMenuRenderer;
        this.toDisposeOnRepositoryChange = new core_1.DisposableCollection();
        this.shouldScrollToRow = true;
        /**
         * Don't modify DOM use React! only exposed for `focusInput`
         * Use `this.scmService.selectedRepository?.input.value` as a single source of truth!
         */
        this.inputRef = React.createRef();
        this.setInputValue = (event) => {
            const repository = this.scmService.selectedRepository;
            if (repository) {
                repository.input.value = typeof event === 'string' ? event : event.currentTarget.value;
            }
        };
        this.scrollOptions = {
            suppressScrollX: true,
            minScrollbarLength: 35
        };
        this.addClass('theia-scm-commit');
        this.id = ScmCommitWidget_1.ID;
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.refreshOnRepositoryChange();
        this.toDisposeOnDetach.push(this.scmService.onDidChangeSelectedRepository(() => {
            this.refreshOnRepositoryChange();
            this.update();
        }));
    }
    refreshOnRepositoryChange() {
        this.toDisposeOnRepositoryChange.dispose();
        const repository = this.scmService.selectedRepository;
        if (repository) {
            this.toDisposeOnRepositoryChange.push(repository.provider.onDidChange(async () => {
                this.update();
            }));
            this.toDisposeOnRepositoryChange.push(repository.provider.onDidChangeCommitTemplate(e => {
                this.setInputValue(e);
            }));
        }
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.focus();
    }
    focus() {
        (this.inputRef.current || this.node).focus();
    }
    render() {
        const repository = this.scmService.selectedRepository;
        if (repository) {
            return React.createElement('div', this.createContainerAttributes(), this.renderInput(repository.input));
        }
    }
    /**
     * Create the container attributes for the widget.
     */
    createContainerAttributes() {
        return {
            style: { flexGrow: 0 }
        };
    }
    renderInput(input) {
        let validationStatus = 'idle';
        if (input.issue) {
            switch (input.issue.type) {
                case scm_input_1.ScmInputIssueType.Error:
                    validationStatus = 'error';
                    break;
                case scm_input_1.ScmInputIssueType.Information:
                    validationStatus = 'info';
                    break;
                case scm_input_1.ScmInputIssueType.Warning:
                    validationStatus = 'warning';
                    break;
            }
        }
        const validationMessage = input.issue ? input.issue.message : '';
        const format = (value, ...args) => {
            if (args.length !== 0) {
                return value.replace(/{(\d+)}/g, (found, n) => {
                    const i = parseInt(n);
                    return isNaN(i) || i < 0 || i >= args.length ? found : args[i];
                });
            }
            return value;
        };
        const keybinding = this.keybindings.acceleratorFor(this.keybindings.getKeybindingsForCommand('scm.acceptInput')[0]).join('+');
        const message = format(input.placeholder || '', keybinding);
        const textArea = input.visible &&
            React.createElement(react_textarea_autosize_1.default, { className: `${ScmCommitWidget_1.Styles.INPUT_MESSAGE} theia-input theia-scm-input-message-${validationStatus}`, id: ScmCommitWidget_1.Styles.INPUT_MESSAGE, placeholder: message, spellCheck: false, autoFocus: true, value: input.value, disabled: !input.enabled, onChange: this.setInputValue, ref: this.inputRef, rows: 1, maxRows: 6 });
        return React.createElement("div", { className: ScmCommitWidget_1.Styles.INPUT_MESSAGE_CONTAINER },
            textArea,
            React.createElement("div", { className: `${ScmCommitWidget_1.Styles.VALIDATION_MESSAGE} ${ScmCommitWidget_1.Styles.NO_SELECT}
                    theia-scm-validation-message-${validationStatus} theia-scm-input-message-${validationStatus}`, style: {
                    display: !!input.issue ? 'block' : 'none'
                } }, validationMessage));
    }
    /**
     * Store the tree state.
     */
    storeState() {
        var _a;
        const message = (_a = this.scmService.selectedRepository) === null || _a === void 0 ? void 0 : _a.input.value;
        return { message };
    }
    /**
     * Restore the state.
     * @param oldState the old state object.
     */
    restoreState(oldState) {
        const value = oldState.message;
        if (!value) {
            return;
        }
        let repository = this.scmService.selectedRepository;
        if (repository) {
            repository.input.value = value;
        }
        else {
            const listener = this.scmService.onDidChangeSelectedRepository(() => {
                repository = this.scmService.selectedRepository;
                if (repository) {
                    listener.dispose();
                    if (!repository.input.value) {
                        repository.input.value = value;
                    }
                }
            });
            this.toDispose.push(listener);
        }
    }
};
exports.ScmCommitWidget = ScmCommitWidget;
ScmCommitWidget.ID = 'scm-commit-widget';
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmCommitWidget.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], ScmCommitWidget.prototype, "keybindings", void 0);
exports.ScmCommitWidget = ScmCommitWidget = ScmCommitWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [browser_1.ContextMenuRenderer])
], ScmCommitWidget);
(function (ScmCommitWidget) {
    let Styles;
    (function (Styles) {
        Styles.INPUT_MESSAGE_CONTAINER = 'theia-scm-input-message-container';
        Styles.INPUT_MESSAGE = 'theia-scm-input-message';
        Styles.VALIDATION_MESSAGE = 'theia-scm-input-validation-message';
        Styles.NO_SELECT = 'no-select';
    })(Styles = ScmCommitWidget.Styles || (ScmCommitWidget.Styles = {}));
})(ScmCommitWidget || (exports.ScmCommitWidget = ScmCommitWidget = {}));


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-context-key-service.js":
/*!************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-context-key-service.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "./node_modules/@theia/core/lib/browser/context-key-service.js");
let ScmContextKeyService = class ScmContextKeyService {
    get scmProvider() {
        return this._scmProvider;
    }
    get scmResourceGroup() {
        return this._scmResourceGroup;
    }
    get scmResourceGroupState() {
        return this._scmResourceGroupState;
    }
    init() {
        this._scmProvider = this.contextKeyService.createKey('scmProvider', undefined);
        this._scmResourceGroup = this.contextKeyService.createKey('scmResourceGroup', undefined);
        this._scmResourceGroupState = this.contextKeyService.createKey('scmResourceGroupState', undefined);
    }
    match(expression) {
        return !expression || this.contextKeyService.match(expression);
    }
};
exports.ScmContextKeyService = ScmContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], ScmContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmContextKeyService.prototype, "init", null);
exports.ScmContextKeyService = ScmContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmContextKeyService);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-contribution.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-contribution.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmContribution = exports.ScmColors = exports.SCM_COMMANDS = exports.ScmMenus = exports.SCM_VIEW_CONTAINER_TITLE_OPTIONS = exports.SCM_VIEW_CONTAINER_ID = exports.SCM_WIDGET_FACTORY_ID = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "./node_modules/@theia/core/lib/common/event.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "./node_modules/@theia/core/lib/common/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "./node_modules/@theia/core/lib/browser/context-key-service.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "./node_modules/@theia/scm/lib/browser/scm-service.js");
const scm_widget_1 = __webpack_require__(/*! ../browser/scm-widget */ "./node_modules/@theia/scm/lib/browser/scm-widget.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "./node_modules/@theia/core/lib/common/uri.js");
const scm_quick_open_service_1 = __webpack_require__(/*! ./scm-quick-open-service */ "./node_modules/@theia/scm/lib/browser/scm-quick-open-service.js");
const color_1 = __webpack_require__(/*! @theia/core/lib/common/color */ "./node_modules/@theia/core/lib/common/color.js");
const scm_colors_1 = __webpack_require__(/*! ./scm-colors */ "./node_modules/@theia/scm/lib/browser/scm-colors.js");
Object.defineProperty(exports, "ScmColors", ({ enumerable: true, get: function () { return scm_colors_1.ScmColors; } }));
const scm_decorations_service_1 = __webpack_require__(/*! ../browser/decorations/scm-decorations-service */ "./node_modules/@theia/scm/lib/browser/decorations/scm-decorations-service.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "./node_modules/@theia/core/lib/common/nls.js");
const theme_1 = __webpack_require__(/*! @theia/core/lib/common/theme */ "./node_modules/@theia/core/lib/common/theme.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "./node_modules/@theia/editor/lib/browser/index.js");
const dirty_diff_navigator_1 = __webpack_require__(/*! ./dirty-diff/dirty-diff-navigator */ "./node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-navigator.js");
const monaco_diff_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-diff-editor */ "./node_modules/@theia/monaco/lib/browser/monaco-diff-editor.js");
exports.SCM_WIDGET_FACTORY_ID = scm_widget_1.ScmWidget.ID;
exports.SCM_VIEW_CONTAINER_ID = 'scm-view-container';
exports.SCM_VIEW_CONTAINER_TITLE_OPTIONS = {
    label: nls_1.nls.localizeByDefault('Source Control'),
    iconClass: (0, browser_1.codicon)('source-control'),
    closeable: true
};
var ScmMenus;
(function (ScmMenus) {
    ScmMenus.CHANGES_GROUP = [...browser_2.EditorMainMenu.GO, '6_changes_group'];
})(ScmMenus || (exports.ScmMenus = ScmMenus = {}));
var SCM_COMMANDS;
(function (SCM_COMMANDS) {
    SCM_COMMANDS.CHANGE_REPOSITORY = {
        id: 'scm.change.repository',
        category: nls_1.nls.localizeByDefault('Source Control'),
        originalCategory: 'Source Control',
        label: nls_1.nls.localize('theia/scm/changeRepository', 'Change Repository...'),
        originalLabel: 'Change Repository...'
    };
    SCM_COMMANDS.ACCEPT_INPUT = {
        id: 'scm.acceptInput'
    };
    SCM_COMMANDS.TREE_VIEW_MODE = {
        id: 'scm.viewmode.tree',
        tooltip: nls_1.nls.localizeByDefault('View as Tree'),
        iconClass: (0, browser_1.codicon)('list-tree'),
        originalLabel: 'View as Tree',
        label: nls_1.nls.localizeByDefault('View as Tree')
    };
    SCM_COMMANDS.LIST_VIEW_MODE = {
        id: 'scm.viewmode.list',
        tooltip: nls_1.nls.localizeByDefault('View as List'),
        iconClass: (0, browser_1.codicon)('list-flat'),
        originalLabel: 'View as List',
        label: nls_1.nls.localizeByDefault('View as List')
    };
    SCM_COMMANDS.COLLAPSE_ALL = {
        id: 'scm.collapseAll',
        category: nls_1.nls.localizeByDefault('Source Control'),
        originalCategory: 'Source Control',
        tooltip: nls_1.nls.localizeByDefault('Collapse All'),
        iconClass: (0, browser_1.codicon)('collapse-all'),
        label: nls_1.nls.localizeByDefault('Collapse All'),
        originalLabel: 'Collapse All'
    };
    SCM_COMMANDS.GOTO_NEXT_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.editor.nextChange',
        category: 'Source Control',
        label: 'Go to Next Change',
        iconClass: (0, browser_1.codicon)('arrow-down')
    });
    SCM_COMMANDS.GOTO_PREVIOUS_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'workbench.action.editor.previousChange',
        category: 'Source Control',
        label: 'Go to Previous Change',
        iconClass: (0, browser_1.codicon)('arrow-up')
    });
    SCM_COMMANDS.SHOW_NEXT_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.action.dirtydiff.next',
        category: 'Source Control',
        label: 'Show Next Change'
    });
    SCM_COMMANDS.SHOW_PREVIOUS_CHANGE = common_1.Command.toDefaultLocalizedCommand({
        id: 'editor.action.dirtydiff.previous',
        category: 'Source Control',
        label: 'Show Previous Change'
    });
    SCM_COMMANDS.CLOSE_CHANGE_PEEK_VIEW = {
        id: 'editor.action.dirtydiff.close',
        category: nls_1.nls.localizeByDefault('Source Control'),
        originalCategory: 'Source Control',
        label: nls_1.nls.localize('theia/scm/dirtyDiff/close', 'Close Change Peek View'),
        originalLabel: 'Close Change Peek View'
    };
})(SCM_COMMANDS || (exports.SCM_COMMANDS = SCM_COMMANDS = {}));
let ScmContribution = class ScmContribution extends browser_1.AbstractViewContribution {
    constructor() {
        super({
            viewContainerId: exports.SCM_VIEW_CONTAINER_ID,
            widgetId: exports.SCM_WIDGET_FACTORY_ID,
            widgetName: exports.SCM_VIEW_CONTAINER_TITLE_OPTIONS.label,
            defaultWidgetOptions: {
                area: 'left',
                rank: 300
            },
            toggleCommandId: 'scmView:toggle',
            toggleKeybinding: 'ctrlcmd+shift+g'
        });
        this.statusBarDisposable = new common_1.DisposableCollection();
    }
    init() {
        this.scmFocus = this.contextKeys.createKey('scmFocus', false);
    }
    async initializeLayout() {
        await this.openView();
    }
    onStart() {
        this.updateStatusBar();
        this.scmService.onDidAddRepository(() => this.updateStatusBar());
        this.scmService.onDidRemoveRepository(() => this.updateStatusBar());
        this.scmService.onDidChangeSelectedRepository(() => this.updateStatusBar());
        this.scmService.onDidChangeStatusBarCommands(() => this.updateStatusBar());
        this.labelProvider.onDidChange(() => this.updateStatusBar());
        this.updateContextKeys();
        this.shell.onDidChangeCurrentWidget(() => this.updateContextKeys());
        this.scmDecorationsService.onDirtyDiffUpdate(update => this.dirtyDiffNavigator.handleDirtyDiffUpdate(update));
    }
    updateContextKeys() {
        this.scmFocus.set(this.shell.currentWidget instanceof scm_widget_1.ScmWidget);
    }
    registerCommands(commandRegistry) {
        super.registerCommands(commandRegistry);
        commandRegistry.registerCommand(SCM_COMMANDS.CHANGE_REPOSITORY, {
            execute: () => this.scmQuickOpenService.changeRepository(),
            isEnabled: () => this.scmService.repositories.length > 1
        });
        commandRegistry.registerCommand(SCM_COMMANDS.ACCEPT_INPUT, {
            execute: () => this.acceptInput(),
            isEnabled: () => !!this.scmFocus.get() && !!this.acceptInputCommand()
        });
        // Note that commands for dirty diff navigation need to be always available.
        // This is consistent with behavior in VS Code, and also with other similar commands (such as `Next Problem/Previous Problem`) in Theia.
        // See https://github.com/eclipse-theia/theia/pull/13104#discussion_r1497316614 for a detailed discussion.
        commandRegistry.registerCommand(SCM_COMMANDS.GOTO_NEXT_CHANGE, {
            execute: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    widget.editor.diffNavigator.next();
                    widget.activate();
                }
                else {
                    this.dirtyDiffNavigator.gotoNextChange();
                }
            },
            isEnabled: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    return widget.editor.diffNavigator.hasNext();
                }
                return true;
            }
        });
        commandRegistry.registerCommand(SCM_COMMANDS.GOTO_PREVIOUS_CHANGE, {
            execute: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    widget.editor.diffNavigator.previous();
                    widget.activate();
                }
                else {
                    this.dirtyDiffNavigator.gotoPreviousChange();
                }
            },
            isEnabled: widget => {
                if (widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                    return widget.editor.diffNavigator.hasPrevious();
                }
                return true;
            }
        });
        commandRegistry.registerCommand(SCM_COMMANDS.SHOW_NEXT_CHANGE, {
            execute: () => this.dirtyDiffNavigator.showNextChange()
        });
        commandRegistry.registerCommand(SCM_COMMANDS.SHOW_PREVIOUS_CHANGE, {
            execute: () => this.dirtyDiffNavigator.showPreviousChange()
        });
        commandRegistry.registerCommand(SCM_COMMANDS.CLOSE_CHANGE_PEEK_VIEW, {
            execute: () => this.dirtyDiffNavigator.closeChangePeekView()
        });
    }
    registerMenus(menus) {
        super.registerMenus(menus);
        menus.registerMenuAction(ScmMenus.CHANGES_GROUP, {
            commandId: SCM_COMMANDS.SHOW_NEXT_CHANGE.id,
            label: nls_1.nls.localizeByDefault('Next Change'),
            order: '1'
        });
        menus.registerMenuAction(ScmMenus.CHANGES_GROUP, {
            commandId: SCM_COMMANDS.SHOW_PREVIOUS_CHANGE.id,
            label: nls_1.nls.localizeByDefault('Previous Change'),
            order: '2'
        });
    }
    registerToolbarItems(registry) {
        const viewModeEmitter = new event_1.Emitter();
        const registerToggleViewItem = (command, mode) => {
            const id = command.id;
            const item = {
                id,
                command: id,
                tooltip: command.label,
                onDidChange: viewModeEmitter.event
            };
            this.commandRegistry.registerCommand({ id, iconClass: command && command.iconClass }, {
                execute: widget => {
                    if (widget instanceof scm_widget_1.ScmWidget) {
                        widget.viewMode = mode;
                        viewModeEmitter.fire();
                    }
                },
                isVisible: widget => {
                    if (widget instanceof scm_widget_1.ScmWidget) {
                        return !!this.scmService.selectedRepository
                            && widget.viewMode !== mode;
                    }
                    return false;
                },
            });
            registry.registerItem(item);
        };
        registerToggleViewItem(SCM_COMMANDS.TREE_VIEW_MODE, 'tree');
        registerToggleViewItem(SCM_COMMANDS.LIST_VIEW_MODE, 'list');
        this.commandRegistry.registerCommand(SCM_COMMANDS.COLLAPSE_ALL, {
            execute: widget => {
                if (widget instanceof scm_widget_1.ScmWidget && widget.viewMode === 'tree') {
                    widget.collapseScmTree();
                }
            },
            isVisible: widget => {
                if (widget instanceof scm_widget_1.ScmWidget) {
                    return !!this.scmService.selectedRepository && widget.viewMode === 'tree';
                }
                return false;
            }
        });
        registry.registerItem({
            id: SCM_COMMANDS.GOTO_PREVIOUS_CHANGE.id,
            command: SCM_COMMANDS.GOTO_PREVIOUS_CHANGE.id,
            isVisible: widget => widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor,
        });
        registry.registerItem({
            id: SCM_COMMANDS.GOTO_NEXT_CHANGE.id,
            command: SCM_COMMANDS.GOTO_NEXT_CHANGE.id,
            isVisible: widget => widget instanceof browser_2.EditorWidget && widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor,
        });
        registry.registerItem({
            ...SCM_COMMANDS.COLLAPSE_ALL,
            command: SCM_COMMANDS.COLLAPSE_ALL.id
        });
    }
    registerKeybindings(keybindings) {
        super.registerKeybindings(keybindings);
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.ACCEPT_INPUT.id,
            keybinding: 'ctrlcmd+enter',
            when: 'scmFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.GOTO_NEXT_CHANGE.id,
            keybinding: 'alt+f5',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.GOTO_PREVIOUS_CHANGE.id,
            keybinding: 'shift+alt+f5',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.SHOW_NEXT_CHANGE.id,
            keybinding: 'alt+f3',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.SHOW_PREVIOUS_CHANGE.id,
            keybinding: 'shift+alt+f3',
            when: 'editorTextFocus'
        });
        keybindings.registerKeybinding({
            command: SCM_COMMANDS.CLOSE_CHANGE_PEEK_VIEW.id,
            keybinding: 'esc',
            when: 'dirtyDiffVisible'
        });
    }
    async acceptInput() {
        const command = this.acceptInputCommand();
        if (command && command.command) {
            await this.commands.executeCommand(command.command, ...command.arguments ? command.arguments : []);
        }
    }
    acceptInputCommand() {
        const repository = this.scmService.selectedRepository;
        if (!repository) {
            return undefined;
        }
        return repository.provider.acceptInputCommand;
    }
    updateStatusBar() {
        this.statusBarDisposable.dispose();
        const repository = this.scmService.selectedRepository;
        if (!repository) {
            return;
        }
        const name = this.labelProvider.getName(new uri_1.default(repository.provider.rootUri));
        if (this.scmService.repositories.length > 1) {
            this.setStatusBarEntry(SCM_COMMANDS.CHANGE_REPOSITORY.id, {
                text: `$(database) ${name}`,
                tooltip: name.toString(),
                command: SCM_COMMANDS.CHANGE_REPOSITORY.id,
                alignment: browser_1.StatusBarAlignment.LEFT,
                priority: 100
            });
        }
        const label = repository.provider.rootUri ? `${name} (${repository.provider.label})` : repository.provider.label;
        this.scmService.statusBarCommands.forEach((value, index) => this.setStatusBarEntry(`scm.status.${index}`, {
            text: value.title,
            tooltip: label + (value.tooltip ? ` - ${value.tooltip}` : ''),
            command: value.command,
            arguments: value.arguments,
            alignment: browser_1.StatusBarAlignment.LEFT,
            priority: 100
        }));
    }
    setStatusBarEntry(id, entry) {
        this.statusBar.setElement(id, entry);
        this.statusBarDisposable.push(common_1.Disposable.create(() => this.statusBar.removeElement(id)));
    }
    /**
     * It should be aligned with https://github.com/microsoft/vscode/blob/0dfa355b3ad185a6289ba28a99c141ab9e72d2be/src/vs/workbench/contrib/scm/browser/dirtydiffDecorator.ts#L808
     */
    registerColors(colors) {
        colors.register({
            id: scm_colors_1.ScmColors.editorGutterModifiedBackground, defaults: {
                dark: '#1B81A8',
                light: '#2090D3',
                hcDark: '#1B81A8',
                hcLight: '#2090D3'
            }, description: 'Editor gutter background color for lines that are modified.'
        }, {
            id: scm_colors_1.ScmColors.editorGutterAddedBackground, defaults: {
                dark: '#487E02',
                light: '#48985D',
                hcDark: '#487E02',
                hcLight: '#48985D'
            }, description: 'Editor gutter background color for lines that are added.'
        }, {
            id: scm_colors_1.ScmColors.editorGutterDeletedBackground, defaults: {
                dark: 'editorError.foreground',
                light: 'editorError.foreground',
                hcDark: 'editorError.foreground',
                hcLight: 'editorError.foreground'
            }, description: 'Editor gutter background color for lines that are deleted.'
        }, {
            id: 'minimapGutter.modifiedBackground', defaults: {
                dark: 'editorGutter.modifiedBackground',
                light: 'editorGutter.modifiedBackground',
                hcDark: 'editorGutter.modifiedBackground',
                hcLight: 'editorGutter.modifiedBackground'
            }, description: 'Minimap gutter background color for lines that are modified.'
        }, {
            id: 'minimapGutter.addedBackground', defaults: {
                dark: 'editorGutter.addedBackground',
                light: 'editorGutter.addedBackground',
                hcDark: 'editorGutter.modifiedBackground',
                hcLight: 'editorGutter.modifiedBackground'
            }, description: 'Minimap gutter background color for lines that are added.'
        }, {
            id: 'minimapGutter.deletedBackground', defaults: {
                dark: 'editorGutter.deletedBackground',
                light: 'editorGutter.deletedBackground',
                hcDark: 'editorGutter.deletedBackground',
                hcLight: 'editorGutter.deletedBackground'
            }, description: 'Minimap gutter background color for lines that are deleted.'
        }, {
            id: 'editorOverviewRuler.modifiedForeground', defaults: {
                dark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6),
                light: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6),
                hcDark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6),
                hcLight: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterModifiedBackground, 0.6)
            }, description: 'Overview ruler marker color for modified content.'
        }, {
            id: 'editorOverviewRuler.addedForeground', defaults: {
                dark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6),
                light: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6),
                hcDark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6),
                hcLight: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterAddedBackground, 0.6)
            }, description: 'Overview ruler marker color for added content.'
        }, {
            id: 'editorOverviewRuler.deletedForeground', defaults: {
                dark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6),
                light: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6),
                hcDark: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6),
                hcLight: color_1.Color.transparent(scm_colors_1.ScmColors.editorGutterDeletedBackground, 0.6)
            }, description: 'Overview ruler marker color for deleted content.'
        });
    }
    registerThemeStyle(theme, collector) {
        const contrastBorder = theme.getColor('contrastBorder');
        if (contrastBorder && (0, theme_1.isHighContrast)(theme.type)) {
            collector.addRule(`
                .theia-scm-input-message-container textarea {
                    outline: var(--theia-border-width) solid ${contrastBorder};
                    outline-offset: -1px;
                }
            `);
        }
    }
};
exports.ScmContribution = ScmContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.StatusBar),
    tslib_1.__metadata("design:type", Object)
], ScmContribution.prototype, "statusBar", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmContribution.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_quick_open_service_1.ScmQuickOpenService),
    tslib_1.__metadata("design:type", scm_quick_open_service_1.ScmQuickOpenService)
], ScmContribution.prototype, "scmQuickOpenService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.LabelProvider),
    tslib_1.__metadata("design:type", browser_1.LabelProvider)
], ScmContribution.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandService),
    tslib_1.__metadata("design:type", Object)
], ScmContribution.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandRegistry),
    tslib_1.__metadata("design:type", common_1.CommandRegistry)
], ScmContribution.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], ScmContribution.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_decorations_service_1.ScmDecorationsService),
    tslib_1.__metadata("design:type", scm_decorations_service_1.ScmDecorationsService)
], ScmContribution.prototype, "scmDecorationsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(dirty_diff_navigator_1.DirtyDiffNavigator),
    tslib_1.__metadata("design:type", dirty_diff_navigator_1.DirtyDiffNavigator)
], ScmContribution.prototype, "dirtyDiffNavigator", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmContribution.prototype, "init", null);
exports.ScmContribution = ScmContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ScmContribution);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-input.js":
/*!**********************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-input.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmInput = exports.ScmInputIssueType = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const debounce = __webpack_require__(/*! p-debounce */ "./node_modules/p-debounce/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "./node_modules/@theia/core/lib/common/index.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@lumino/coreutils */ "./node_modules/@theia/core/shared/@lumino/coreutils/index.js");
var ScmInputIssueType;
(function (ScmInputIssueType) {
    ScmInputIssueType[ScmInputIssueType["Error"] = 0] = "Error";
    ScmInputIssueType[ScmInputIssueType["Warning"] = 1] = "Warning";
    ScmInputIssueType[ScmInputIssueType["Information"] = 2] = "Information";
})(ScmInputIssueType || (exports.ScmInputIssueType = ScmInputIssueType = {}));
class ScmInput {
    fireDidChange() {
        this.onDidChangeEmitter.fire(undefined);
    }
    constructor(options = {}) {
        var _a;
        this.options = options;
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.onDidFocusEmitter = new common_1.Emitter();
        this.onDidFocus = this.onDidFocusEmitter.event;
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeEmitter, this.onDidFocusEmitter);
        this._placeholder = this.options.placeholder;
        this._visible = this.options.visible;
        this._enabled = (_a = this.options.enabled) !== null && _a !== void 0 ? _a : true;
        this.validate = debounce(async () => {
            if (this.options.validator) {
                this.issue = await this.options.validator(this.value);
            }
        }, 200);
    }
    dispose() {
        this.toDispose.dispose();
    }
    get placeholder() {
        return this._placeholder;
    }
    set placeholder(placeholder) {
        if (this._placeholder === placeholder) {
            return;
        }
        this._placeholder = placeholder;
        this.fireDidChange();
    }
    get value() {
        return this._value || '';
    }
    set value(value) {
        if (this.value === value) {
            return;
        }
        this._value = value;
        this.fireDidChange();
        this.validate();
    }
    get visible() {
        var _a;
        return (_a = this._visible) !== null && _a !== void 0 ? _a : true;
    }
    set visible(visible) {
        if (this.visible === visible) {
            return;
        }
        this._visible = visible;
        this.fireDidChange();
        this.validate();
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(enabled) {
        if (this._enabled === enabled) {
            return;
        }
        this._enabled = enabled;
        this.fireDidChange();
        this.validate();
    }
    get issue() {
        return this._issue;
    }
    set issue(issue) {
        if (coreutils_1.JSONExt.deepEqual((this._issue || {}), (issue || {}))) {
            return;
        }
        this._issue = issue;
        this.fireDidChange();
    }
    focus() {
        this.onDidFocusEmitter.fire(undefined);
    }
    toJSON() {
        return {
            value: this._value,
            issue: this._issue
        };
    }
    fromJSON(data) {
        if (this._value !== undefined) {
            return;
        }
        if ('value' in data) {
            this._value = data.value;
            this._issue = data.issue;
            this.fireDidChange();
        }
    }
}
exports.ScmInput = ScmInput;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-no-repository-widget.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-no-repository-widget.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmNoRepositoryWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmNoRepositoryWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "./node_modules/@theia/core/shared/react/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const alert_message_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/alert-message */ "./node_modules/@theia/core/lib/browser/widgets/alert-message.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "./node_modules/@theia/core/lib/common/nls.js");
let ScmNoRepositoryWidget = ScmNoRepositoryWidget_1 = class ScmNoRepositoryWidget extends browser_1.ReactWidget {
    constructor() {
        super();
        this.addClass('theia-scm-no-repository');
        this.id = ScmNoRepositoryWidget_1.ID;
    }
    render() {
        return React.createElement(alert_message_1.AlertMessage, { type: 'WARNING', header: nls_1.nls.localize('theia/scm/noRepositoryFound', 'No repository found') });
    }
};
exports.ScmNoRepositoryWidget = ScmNoRepositoryWidget;
ScmNoRepositoryWidget.ID = 'scm-no-repository-widget';
exports.ScmNoRepositoryWidget = ScmNoRepositoryWidget = ScmNoRepositoryWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ScmNoRepositoryWidget);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-preferences.js":
/*!****************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-preferences.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2020 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindScmPreferences = exports.createScmPreferences = exports.ScmPreferences = exports.ScmPreferenceContribution = exports.scmPreferenceSchema = void 0;
const preferences_1 = __webpack_require__(/*! @theia/core/lib/browser/preferences */ "./node_modules/@theia/core/lib/browser/preferences/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "./node_modules/@theia/core/lib/common/nls.js");
exports.scmPreferenceSchema = {
    type: 'object',
    properties: {
        'scm.defaultViewMode': {
            type: 'string',
            enum: ['tree', 'list'],
            enumDescriptions: [
                nls_1.nls.localizeByDefault('Show the repository changes as a tree.'),
                nls_1.nls.localizeByDefault('Show the repository changes as a list.')
            ],
            description: nls_1.nls.localizeByDefault('Controls the default Source Control repository view mode.'),
            default: 'list'
        }
    }
};
exports.ScmPreferenceContribution = Symbol('ScmPreferenceContribution');
exports.ScmPreferences = Symbol('ScmPreferences');
function createScmPreferences(preferences, schema = exports.scmPreferenceSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createScmPreferences = createScmPreferences;
function bindScmPreferences(bind) {
    bind(exports.ScmPreferences).toDynamicValue((ctx) => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.ScmPreferenceContribution);
        return createScmPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.ScmPreferenceContribution).toConstantValue({ schema: exports.scmPreferenceSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.ScmPreferenceContribution);
}
exports.bindScmPreferences = bindScmPreferences;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-quick-open-service.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-quick-open-service.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmQuickOpenService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "./node_modules/@theia/core/lib/common/message-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "./node_modules/@theia/core/lib/common/uri.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "./node_modules/@theia/scm/lib/browser/scm-service.js");
const label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/label-provider */ "./node_modules/@theia/core/lib/browser/label-provider.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
let ScmQuickOpenService = class ScmQuickOpenService {
    async changeRepository() {
        var _a;
        const repositories = this.scmService.repositories;
        if (repositories.length > 1) {
            const items = await Promise.all(repositories.map(async (repository) => {
                const uri = new uri_1.default(repository.provider.rootUri);
                return {
                    label: this.labelProvider.getName(uri),
                    description: this.labelProvider.getLongName(uri),
                    execute: () => {
                        this.scmService.selectedRepository = repository;
                    }
                };
            }));
            (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.showQuickPick(items, { placeholder: 'Select repository to work with:' });
        }
    }
};
exports.ScmQuickOpenService = ScmQuickOpenService;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickInputService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", Object)
], ScmQuickOpenService.prototype, "quickInputService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(message_service_1.MessageService),
    tslib_1.__metadata("design:type", message_service_1.MessageService)
], ScmQuickOpenService.prototype, "messageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(label_provider_1.LabelProvider),
    tslib_1.__metadata("design:type", label_provider_1.LabelProvider)
], ScmQuickOpenService.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmQuickOpenService.prototype, "scmService", void 0);
exports.ScmQuickOpenService = ScmQuickOpenService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmQuickOpenService);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-repository.js":
/*!***************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-repository.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmRepository = void 0;
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "./node_modules/@theia/core/lib/common/index.js");
const scm_input_1 = __webpack_require__(/*! ./scm-input */ "./node_modules/@theia/scm/lib/browser/scm-input.js");
class ScmRepository {
    fireDidChange() {
        this.onDidChangeEmitter.fire(undefined);
    }
    constructor(provider, options = {}) {
        this.provider = provider;
        this.options = options;
        this.onDidChangeEmitter = new common_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeEmitter);
        this.toDispose.pushAll([
            this.provider,
            this.input = new scm_input_1.ScmInput(options.input),
            this.input.onDidChange(() => this.fireDidChange())
        ]);
    }
    dispose() {
        this.toDispose.dispose();
    }
}
exports.ScmRepository = ScmRepository;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-service.js":
/*!************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-service.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "./node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const scm_context_key_service_1 = __webpack_require__(/*! ./scm-context-key-service */ "./node_modules/@theia/scm/lib/browser/scm-context-key-service.js");
const scm_repository_1 = __webpack_require__(/*! ./scm-repository */ "./node_modules/@theia/scm/lib/browser/scm-repository.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "./node_modules/@theia/core/lib/common/uri.js");
let ScmService = class ScmService {
    constructor() {
        this._repositories = new Map();
        this.onDidChangeSelectedRepositoryEmitter = new common_1.Emitter();
        this.onDidChangeSelectedRepository = this.onDidChangeSelectedRepositoryEmitter.event;
        this.onDidAddRepositoryEmitter = new common_1.Emitter();
        this.onDidAddRepository = this.onDidAddRepositoryEmitter.event;
        this.onDidRemoveRepositoryEmitter = new common_1.Emitter();
        this.onDidRemoveRepository = this.onDidAddRepositoryEmitter.event;
        this.onDidChangeStatusBarCommandsEmitter = new common_1.Emitter();
        this.onDidChangeStatusBarCommands = this.onDidChangeStatusBarCommandsEmitter.event;
        this.toDisposeOnSelected = new common_1.DisposableCollection();
    }
    fireDidChangeStatusBarCommands() {
        this.onDidChangeStatusBarCommandsEmitter.fire(this.statusBarCommands);
    }
    get statusBarCommands() {
        const repository = this.selectedRepository;
        return repository && repository.provider.statusBarCommands || [];
    }
    get repositories() {
        return [...this._repositories.values()];
    }
    get selectedRepository() {
        return this._selectedRepository;
    }
    set selectedRepository(repository) {
        if (this._selectedRepository === repository) {
            return;
        }
        this.toDisposeOnSelected.dispose();
        this._selectedRepository = repository;
        if (this._selectedRepository) {
            if (this._selectedRepository.provider.onDidChangeStatusBarCommands) {
                this.toDisposeOnSelected.push(this._selectedRepository.provider.onDidChangeStatusBarCommands(() => this.fireDidChangeStatusBarCommands()));
            }
        }
        this.onDidChangeSelectedRepositoryEmitter.fire(this._selectedRepository);
        this.fireDidChangeStatusBarCommands();
    }
    findRepository(uri) {
        const reposSorted = this.repositories.sort((ra, rb) => rb.provider.rootUri.length - ra.provider.rootUri.length);
        return reposSorted.find(repo => new uri_1.default(repo.provider.rootUri).isEqualOrParent(uri));
    }
    registerScmProvider(provider, options = {}) {
        const key = provider.id + ':' + provider.rootUri;
        if (this._repositories.has(key)) {
            throw new Error(`${provider.label} provider for '${provider.rootUri}' already exists.`);
        }
        const repository = new scm_repository_1.ScmRepository(provider, options);
        const dispose = repository.dispose;
        repository.dispose = () => {
            this._repositories.delete(key);
            dispose.bind(repository)();
            this.onDidRemoveRepositoryEmitter.fire(repository);
            if (this._selectedRepository === repository) {
                this.selectedRepository = this._repositories.values().next().value;
            }
        };
        this._repositories.set(key, repository);
        this.onDidAddRepositoryEmitter.fire(repository);
        if (this._repositories.size === 1) {
            this.selectedRepository = repository;
        }
        return repository;
    }
};
exports.ScmService = ScmService;
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_context_key_service_1.ScmContextKeyService),
    tslib_1.__metadata("design:type", scm_context_key_service_1.ScmContextKeyService)
], ScmService.prototype, "contextKeys", void 0);
exports.ScmService = ScmService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmService);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-tree-model.js":
/*!***************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-tree-model.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmTreeModel = exports.ScmFileChangeNode = exports.ScmFileChangeFolderNode = exports.ScmFileChangeGroupNode = exports.ScmTreeModelProps = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "./node_modules/@theia/core/lib/browser/tree/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "./node_modules/@theia/core/lib/common/uri.js");
const scm_context_key_service_1 = __webpack_require__(/*! ./scm-context-key-service */ "./node_modules/@theia/scm/lib/browser/scm-context-key-service.js");
exports.ScmTreeModelProps = Symbol('ScmTreeModelProps');
var ScmFileChangeGroupNode;
(function (ScmFileChangeGroupNode) {
    function is(node) {
        return 'groupId' in node && 'children' in node
            && !ScmFileChangeFolderNode.is(node);
    }
    ScmFileChangeGroupNode.is = is;
})(ScmFileChangeGroupNode || (exports.ScmFileChangeGroupNode = ScmFileChangeGroupNode = {}));
var ScmFileChangeFolderNode;
(function (ScmFileChangeFolderNode) {
    function is(node) {
        return 'groupId' in node && 'sourceUri' in node && 'path' in node && 'children' in node;
    }
    ScmFileChangeFolderNode.is = is;
})(ScmFileChangeFolderNode || (exports.ScmFileChangeFolderNode = ScmFileChangeFolderNode = {}));
var ScmFileChangeNode;
(function (ScmFileChangeNode) {
    function is(node) {
        return 'sourceUri' in node
            && !ScmFileChangeFolderNode.is(node);
    }
    ScmFileChangeNode.is = is;
    function getGroupId(node) {
        const parentNode = node.parent;
        if (!(parentNode && (ScmFileChangeFolderNode.is(parentNode) || ScmFileChangeGroupNode.is(parentNode)))) {
            throw new Error('bad node');
        }
        return parentNode.groupId;
    }
    ScmFileChangeNode.getGroupId = getGroupId;
})(ScmFileChangeNode || (exports.ScmFileChangeNode = ScmFileChangeNode = {}));
let ScmTreeModel = class ScmTreeModel extends tree_1.TreeModelImpl {
    constructor() {
        super(...arguments);
        this._viewMode = 'list';
        this.compareNodes = (a, b) => this.doCompareNodes(a, b);
    }
    get languageId() {
        return this._languageId;
    }
    set viewMode(id) {
        const oldSelection = this.selectedNodes;
        this._viewMode = id;
        if (this.root) {
            this.root = this.createTree();
            for (const oldSelectedNode of oldSelection) {
                const newNode = this.getNode(oldSelectedNode.id);
                if (tree_1.SelectableTreeNode.is(newNode)) {
                    this.revealNode(newNode); // this call can run asynchronously
                }
            }
        }
    }
    get viewMode() {
        return this._viewMode;
    }
    createTree() {
        const root = {
            id: 'file-change-tree-root',
            parent: undefined,
            visible: false,
            rootUri: this.rootUri,
            children: []
        };
        const groupNodes = this.groups
            .filter(group => !!group.resources.length || !group.hideWhenEmpty)
            .map(group => this.toGroupNode(group, root));
        root.children = groupNodes;
        return root;
    }
    toGroupNode(group, parent) {
        const groupNode = {
            id: `${group.id}`,
            groupId: group.id,
            groupLabel: group.label,
            parent,
            children: [],
            expanded: true,
        };
        const sortedResources = group.resources.sort((r1, r2) => r1.sourceUri.toString().localeCompare(r2.sourceUri.toString()));
        switch (this._viewMode) {
            case 'list':
                groupNode.children = sortedResources.map(resource => this.toFileChangeNode(resource, groupNode));
                break;
            case 'tree':
                const rootUri = group.provider.rootUri;
                if (rootUri) {
                    const resourcePaths = sortedResources.map(resource => {
                        const relativePath = new uri_1.default(rootUri).relative(resource.sourceUri);
                        const pathParts = relativePath ? relativePath.toString().split('/') : [];
                        return { resource, pathParts };
                    });
                    groupNode.children = this.buildFileChangeTree(resourcePaths, 0, sortedResources.length, 0, groupNode);
                }
                break;
        }
        return groupNode;
    }
    buildFileChangeTree(sortedResources, start, end, level, parent) {
        const result = [];
        let folderStart = start;
        while (folderStart < end) {
            const firstFileChange = sortedResources[folderStart];
            if (level === firstFileChange.pathParts.length - 1) {
                result.push(this.toFileChangeNode(firstFileChange.resource, parent));
                folderStart++;
            }
            else {
                let index = folderStart + 1;
                while (index < end) {
                    if (sortedResources[index].pathParts[level] !== firstFileChange.pathParts[level]) {
                        break;
                    }
                    index++;
                }
                const folderEnd = index;
                const nestingThreshold = this.props.nestingThreshold || 1;
                if (folderEnd - folderStart < nestingThreshold) {
                    // Inline these (i.e. do not create another level in the tree)
                    for (let i = folderStart; i < folderEnd; i++) {
                        result.push(this.toFileChangeNode(sortedResources[i].resource, parent));
                    }
                }
                else {
                    const firstFileParts = firstFileChange.pathParts;
                    const lastFileParts = sortedResources[folderEnd - 1].pathParts;
                    // Multiple files with first folder.
                    // See if more folder levels match and include those if so.
                    let thisLevel = level + 1;
                    while (thisLevel < firstFileParts.length - 1 && thisLevel < lastFileParts.length - 1 && firstFileParts[thisLevel] === lastFileParts[thisLevel]) {
                        thisLevel++;
                    }
                    const nodeRelativePath = firstFileParts.slice(level, thisLevel).join('/');
                    result.push(this.toFileChangeFolderNode(sortedResources, folderStart, folderEnd, thisLevel, nodeRelativePath, parent));
                }
                folderStart = folderEnd;
            }
        }
        ;
        return result.sort(this.compareNodes);
    }
    doCompareNodes(a, b) {
        const isFolderA = ScmFileChangeFolderNode.is(a);
        const isFolderB = ScmFileChangeFolderNode.is(b);
        if (isFolderA && !isFolderB) {
            return -1;
        }
        if (isFolderB && !isFolderA) {
            return 1;
        }
        return a.sourceUri.localeCompare(b.sourceUri);
    }
    toFileChangeFolderNode(resources, start, end, level, nodeRelativePath, parent) {
        const rootUri = this.getRoot(parent).rootUri;
        let parentPath = rootUri;
        if (ScmFileChangeFolderNode.is(parent)) {
            parentPath = parent.sourceUri;
        }
        const sourceUri = new uri_1.default(parentPath).resolve(nodeRelativePath);
        const defaultExpansion = this.props.defaultExpansion ? (this.props.defaultExpansion === 'expanded') : true;
        const id = `${parent.groupId}:${String(sourceUri)}`;
        const oldNode = this.getNode(id);
        const folderNode = {
            id,
            groupId: parent.groupId,
            path: nodeRelativePath,
            sourceUri: String(sourceUri),
            children: [],
            parent,
            expanded: tree_1.ExpandableTreeNode.is(oldNode) ? oldNode.expanded : defaultExpansion,
            selected: tree_1.SelectableTreeNode.is(oldNode) && oldNode.selected,
        };
        folderNode.children = this.buildFileChangeTree(resources, start, end, level, folderNode);
        return folderNode;
    }
    getRoot(node) {
        let parent = node.parent;
        while (ScmFileChangeGroupNode.is(parent) && ScmFileChangeFolderNode.is(parent)) {
            parent = parent.parent;
        }
        return parent;
    }
    toFileChangeNode(resource, parent) {
        const id = `${resource.group.id}:${String(resource.sourceUri)}`;
        const oldNode = this.getNode(id);
        const node = {
            id,
            sourceUri: String(resource.sourceUri),
            decorations: resource.decorations,
            parent,
            selected: tree_1.SelectableTreeNode.is(oldNode) && oldNode.selected,
        };
        if (node.selected) {
            this.selectionService.addSelection(node);
        }
        return node;
    }
    async revealNode(node) {
        if (ScmFileChangeFolderNode.is(node) || ScmFileChangeNode.is(node)) {
            const parentNode = node.parent;
            if (tree_1.ExpandableTreeNode.is(parentNode)) {
                await this.revealNode(parentNode);
                if (!parentNode.expanded) {
                    await this.expandNode(parentNode);
                }
            }
        }
    }
    getResourceFromNode(node) {
        const groupId = ScmFileChangeNode.getGroupId(node);
        const group = this.findGroup(groupId);
        if (group) {
            return group.resources.find(r => String(r.sourceUri) === node.sourceUri);
        }
    }
    getResourceGroupFromNode(node) {
        return this.findGroup(node.groupId);
    }
    getResourcesFromFolderNode(node) {
        const resources = [];
        const group = this.findGroup(node.groupId);
        if (group) {
            this.collectResources(resources, node, group);
        }
        return resources;
    }
    getSelectionArgs(selectedNodes) {
        const resources = [];
        for (const node of selectedNodes) {
            if (ScmFileChangeNode.is(node)) {
                const groupId = ScmFileChangeNode.getGroupId(node);
                const group = this.findGroup(groupId);
                if (group) {
                    const selectedResource = group.resources.find(r => String(r.sourceUri) === node.sourceUri);
                    if (selectedResource) {
                        resources.push(selectedResource);
                    }
                }
            }
            if (ScmFileChangeFolderNode.is(node)) {
                const group = this.findGroup(node.groupId);
                if (group) {
                    this.collectResources(resources, node, group);
                }
            }
        }
        // Remove duplicates which may occur if user selected folder and nested folder
        return resources.filter((item1, index) => resources.findIndex(item2 => item1.sourceUri === item2.sourceUri) === index);
    }
    collectResources(resources, node, group) {
        if (ScmFileChangeFolderNode.is(node)) {
            for (const child of node.children) {
                this.collectResources(resources, child, group);
            }
        }
        else if (ScmFileChangeNode.is(node)) {
            const resource = group.resources.find(r => String(r.sourceUri) === node.sourceUri);
            resources.push(resource);
        }
    }
    execInNodeContext(node, callback) {
        var _a;
        if (!this.provider) {
            return;
        }
        let groupId;
        if (ScmFileChangeGroupNode.is(node) || ScmFileChangeFolderNode.is(node)) {
            groupId = node.groupId;
        }
        else if (ScmFileChangeNode.is(node)) {
            groupId = ScmFileChangeNode.getGroupId(node);
        }
        else {
            return;
        }
        this.contextKeys.scmProvider.set(this.provider.id);
        this.contextKeys.scmResourceGroup.set(groupId);
        this.contextKeys.scmResourceGroupState.set((_a = this.findGroup(groupId)) === null || _a === void 0 ? void 0 : _a.contextValue);
        try {
            callback();
        }
        finally {
        }
    }
    /*
     * Normally the group would always be expected to be found.  However if the tree is restored
     * in restoreState then the tree may be rendered before the groups have been created
     * in the provider.  The provider's groups property will be empty in such a situation.
     * We want to render the tree (as that is the point of restoreState, we can render
     * the tree in the saved state before the provider has provided status).  We therefore must
     * be prepared to render the tree without having the ScmResourceGroup or ScmResource
     * objects.
     */
    findGroup(groupId) {
        return this.groups.find(g => g.id === groupId);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    storeState() {
        return {
            ...super.storeState(),
            mode: this.viewMode,
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    restoreState(oldState) {
        super.restoreState(oldState);
        this.viewMode = oldState.mode === 'tree' ? 'tree' : 'list';
    }
};
exports.ScmTreeModel = ScmTreeModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(tree_1.TreeProps),
    tslib_1.__metadata("design:type", Object)
], ScmTreeModel.prototype, "props", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_context_key_service_1.ScmContextKeyService),
    tslib_1.__metadata("design:type", scm_context_key_service_1.ScmContextKeyService)
], ScmTreeModel.prototype, "contextKeys", void 0);
exports.ScmTreeModel = ScmTreeModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ScmTreeModel);


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-tree-widget.js":
/*!****************************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-tree-widget.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2020 Arm and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmTreeWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmInlineAction = exports.ScmInlineActions = exports.ScmResourceFolderElement = exports.ScmResourceGroupElement = exports.ScmResourceComponent = exports.ScmElement = exports.ScmTreeWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* eslint-disable no-null/no-null, @typescript-eslint/no-explicit-any */
const React = __webpack_require__(/*! @theia/core/shared/react */ "./node_modules/@theia/core/shared/react/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "./node_modules/@theia/core/lib/common/uri.js");
const os_1 = __webpack_require__(/*! @theia/core/lib/common/os */ "./node_modules/@theia/core/lib/common/os.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "./node_modules/@theia/core/lib/common/disposable.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree */ "./node_modules/@theia/core/lib/browser/tree/index.js");
const scm_tree_model_1 = __webpack_require__(/*! ./scm-tree-model */ "./node_modules/@theia/scm/lib/browser/scm-tree-model.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "./node_modules/@theia/core/lib/common/menu/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const scm_context_key_service_1 = __webpack_require__(/*! ./scm-context-key-service */ "./node_modules/@theia/scm/lib/browser/scm-context-key-service.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "./node_modules/@theia/editor/lib/browser/index.js");
const icon_theme_service_1 = __webpack_require__(/*! @theia/core/lib/browser/icon-theme-service */ "./node_modules/@theia/core/lib/browser/icon-theme-service.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "./node_modules/@theia/core/lib/browser/color-registry.js");
const decorations_service_1 = __webpack_require__(/*! @theia/core/lib/browser/decorations-service */ "./node_modules/@theia/core/lib/browser/decorations-service.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "./node_modules/@theia/filesystem/lib/common/files.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "./node_modules/@theia/core/lib/browser/theming.js");
let ScmTreeWidget = ScmTreeWidget_1 = class ScmTreeWidget extends tree_1.TreeWidget {
    constructor(props, treeModel, contextMenuRenderer) {
        super(props, treeModel, contextMenuRenderer);
        this.id = ScmTreeWidget_1.ID;
        this.addClass('groups-outer-container');
    }
    init() {
        super.init();
        this.toDispose.push(this.themeService.onDidColorThemeChange(() => this.update()));
    }
    set viewMode(id) {
        // Close the search box because the structure of the tree will change dramatically
        // and the search results will be out of date.
        this.searchBox.hide();
        this.model.viewMode = id;
    }
    get viewMode() {
        return this.model.viewMode;
    }
    /**
     * Render the node given the tree node and node properties.
     * @param node the tree node.
     * @param props the node properties.
     */
    renderNode(node, props) {
        var _a;
        if (!tree_1.TreeNode.isVisible(node)) {
            return undefined;
        }
        const attributes = this.createNodeAttributes(node, props);
        const label = this.labelProvider.getName(node);
        const searchHighlights = (_a = this.searchHighlights) === null || _a === void 0 ? void 0 : _a.get(node.id);
        // The group nodes should not be subject to highlighting.
        const caption = (searchHighlights && !scm_tree_model_1.ScmFileChangeGroupNode.is(node)) ? this.toReactNode(label, searchHighlights) : label;
        if (scm_tree_model_1.ScmFileChangeGroupNode.is(node)) {
            const content = React.createElement(ScmResourceGroupElement, { key: `${node.groupId}`, model: this.model, treeNode: node, renderExpansionToggle: () => this.renderExpansionToggle(node, props), contextMenuRenderer: this.contextMenuRenderer, menus: this.menus, contextKeys: this.contextKeys, labelProvider: this.labelProvider, corePreferences: this.corePreferences, caption: caption });
            return React.createElement('div', attributes, content);
        }
        if (scm_tree_model_1.ScmFileChangeFolderNode.is(node)) {
            const content = React.createElement(ScmResourceFolderElement, { key: String(node.sourceUri), model: this.model, treeNode: node, sourceUri: node.sourceUri, renderExpansionToggle: () => this.renderExpansionToggle(node, props), contextMenuRenderer: this.contextMenuRenderer, menus: this.menus, contextKeys: this.contextKeys, labelProvider: this.labelProvider, corePreferences: this.corePreferences, caption: caption });
            return React.createElement('div', attributes, content);
        }
        if (scm_tree_model_1.ScmFileChangeNode.is(node)) {
            const parentPath = (node.parent && scm_tree_model_1.ScmFileChangeFolderNode.is(node.parent))
                ? new uri_1.default(node.parent.sourceUri) : new uri_1.default(this.model.rootUri);
            const content = React.createElement(ScmResourceComponent, { key: node.sourceUri, model: this.model, treeNode: node, contextMenuRenderer: this.contextMenuRenderer, menus: this.menus, contextKeys: this.contextKeys, labelProvider: this.labelProvider, corePreferences: this.corePreferences, caption: caption, ...this.props,
                parentPath,
                sourceUri: node.sourceUri,
                decoration: this.decorationsService.getDecoration(new uri_1.default(node.sourceUri), true)[0],
                colors: this.colors,
                isLightTheme: this.isCurrentThemeLight(),
                renderExpansionToggle: () => this.renderExpansionToggle(node, props) });
            return React.createElement('div', attributes, content);
        }
        return super.renderNode(node, props);
    }
    createContainerAttributes() {
        if (this.model.canTabToWidget()) {
            return {
                ...super.createContainerAttributes(),
                tabIndex: 0
            };
        }
        return super.createContainerAttributes();
    }
    /**
     * The ARROW_LEFT key controls both the movement around the file tree and also
     * the movement through the change chunks within a file.
     *
     * If the selected tree node is a folder then the ARROW_LEFT key behaves exactly
     * as it does in explorer.  It collapses the tree node if the folder is expanded and
     * it moves the selection up to the parent folder if the folder is collapsed (no-op if no parent folder, as
     * group headers are not selectable).  This behavior is the default behavior implemented
     * in the TreeWidget super class.
     *
     * If the selected tree node is a file then the ARROW_LEFT key moves up through the
     * change chunks within each file.  If the selected chunk is the first chunk in the file
     * then the file selection is moved to the previous file (no-op if no previous file).
     *
     * Note that when cursoring through change chunks, the ARROW_LEFT key cannot be used to
     * move up through the parent folders of the file tree.  If users want to do this, using
     * keys only, then they must press ARROW_UP repeatedly until the selected node is the folder
     * node and then press ARROW_LEFT.
     */
    async handleLeft(event) {
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (!selectedResource) {
                    return super.handleLeft(event);
                }
                const widget = await this.openResource(selectedResource);
                if (widget) {
                    const diffNavigator = this.diffNavigatorProvider(widget.editor);
                    if (diffNavigator.hasPrevious()) {
                        diffNavigator.previous();
                    }
                    else {
                        const previousNode = this.moveToPreviousFileNode();
                        if (previousNode) {
                            const previousResource = this.model.getResourceFromNode(previousNode);
                            if (previousResource) {
                                this.openResource(previousResource);
                            }
                        }
                    }
                    return;
                }
            }
        }
        return super.handleLeft(event);
    }
    /**
     * The ARROW_RIGHT key controls both the movement around the file tree and also
     * the movement through the change chunks within a file.
     *
     * If the selected tree node is a folder then the ARROW_RIGHT key behaves exactly
     * as it does in explorer.  It expands the tree node if the folder is collapsed and
     * it moves the selection to the first child node if the folder is expanded.
     * This behavior is the default behavior implemented
     * in the TreeWidget super class.
     *
     * If the selected tree node is a file then the ARROW_RIGHT key moves down through the
     * change chunks within each file.  If the selected chunk is the last chunk in the file
     * then the file selection is moved to the next file (no-op if no next file).
     */
    async handleRight(event) {
        if (this.model.selectedNodes.length === 0) {
            const firstNode = this.getFirstSelectableNode();
            // Selects the first visible resource as none are selected.
            if (!firstNode) {
                return;
            }
            this.model.selectNode(firstNode);
            return;
        }
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (!selectedResource) {
                    return super.handleRight(event);
                }
                const widget = await this.openResource(selectedResource);
                if (widget) {
                    const diffNavigator = this.diffNavigatorProvider(widget.editor);
                    if (diffNavigator.hasNext()) {
                        diffNavigator.next();
                    }
                    else {
                        const nextNode = this.moveToNextFileNode();
                        if (nextNode) {
                            const nextResource = this.model.getResourceFromNode(nextNode);
                            if (nextResource) {
                                this.openResource(nextResource);
                            }
                        }
                    }
                }
                return;
            }
        }
        return super.handleRight(event);
    }
    handleEnter(event) {
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (selectedResource) {
                    this.openResource(selectedResource);
                }
                return;
            }
        }
        super.handleEnter(event);
    }
    async goToPreviousChange() {
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                    const selectedResource = this.model.getResourceFromNode(selectedNode);
                    if (!selectedResource) {
                        return;
                    }
                    const widget = await this.openResource(selectedResource);
                    if (widget) {
                        const diffNavigator = this.diffNavigatorProvider(widget.editor);
                        if (diffNavigator.hasPrevious()) {
                            diffNavigator.previous();
                        }
                        else {
                            const previousNode = this.moveToPreviousFileNode();
                            if (previousNode) {
                                const previousResource = this.model.getResourceFromNode(previousNode);
                                if (previousResource) {
                                    this.openResource(previousResource);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    async goToNextChange() {
        if (this.model.selectedNodes.length === 0) {
            const firstNode = this.getFirstSelectableNode();
            // Selects the first visible resource as none are selected.
            if (!firstNode) {
                return;
            }
            this.model.selectNode(firstNode);
            return;
        }
        if (this.model.selectedNodes.length === 1) {
            const selectedNode = this.model.selectedNodes[0];
            if (scm_tree_model_1.ScmFileChangeNode.is(selectedNode)) {
                const selectedResource = this.model.getResourceFromNode(selectedNode);
                if (!selectedResource) {
                    return;
                }
                const widget = await this.openResource(selectedResource);
                if (widget) {
                    const diffNavigator = this.diffNavigatorProvider(widget.editor);
                    if (diffNavigator.hasNext()) {
                        diffNavigator.next();
                    }
                    else {
                        const nextNode = this.moveToNextFileNode();
                        if (nextNode) {
                            const nextResource = this.model.getResourceFromNode(nextNode);
                            if (nextResource) {
                                this.openResource(nextResource);
                            }
                        }
                    }
                }
            }
        }
    }
    selectNodeByUri(uri) {
        for (const group of this.model.groups) {
            const sourceUri = new uri_1.default(uri.path.toString());
            const id = `${group.id}:${sourceUri.toString()}`;
            const node = this.model.getNode(id);
            if (tree_1.SelectableTreeNode.is(node)) {
                this.model.selectNode(node);
                return;
            }
        }
    }
    getFirstSelectableNode() {
        if (this.model.root) {
            const root = this.model.root;
            const groupNode = root.children[0];
            return groupNode.children[0];
        }
    }
    moveToPreviousFileNode() {
        let previousNode = this.model.getPrevSelectableNode();
        while (previousNode) {
            if (scm_tree_model_1.ScmFileChangeNode.is(previousNode)) {
                this.model.selectNode(previousNode);
                return previousNode;
            }
            previousNode = this.model.getPrevSelectableNode(previousNode);
        }
        ;
    }
    moveToNextFileNode() {
        let nextNode = this.model.getNextSelectableNode();
        while (nextNode) {
            if (scm_tree_model_1.ScmFileChangeNode.is(nextNode)) {
                this.model.selectNode(nextNode);
                return nextNode;
            }
            nextNode = this.model.getNextSelectableNode(nextNode);
        }
        ;
    }
    async openResource(resource) {
        try {
            await resource.open();
        }
        catch (e) {
            console.error('Failed to open a SCM resource', e);
            return undefined;
        }
        let standaloneEditor;
        const resourcePath = resource.sourceUri.path.toString();
        for (const widget of this.editorManager.all) {
            const resourceUri = widget.editor.document.uri;
            const editorResourcePath = new uri_1.default(resourceUri).path.toString();
            if (resourcePath === editorResourcePath) {
                if (widget.editor.uri.scheme === browser_1.DiffUris.DIFF_SCHEME) {
                    // prefer diff editor
                    return widget;
                }
                else {
                    standaloneEditor = widget;
                }
            }
            if (widget.editor.uri.scheme === browser_1.DiffUris.DIFF_SCHEME
                && resourceUri === resource.sourceUri.toString()) {
                return widget;
            }
        }
        // fallback to standalone editor
        return standaloneEditor;
    }
    getPaddingLeft(node, props) {
        if (this.viewMode === 'list') {
            if (props.depth === 1) {
                return this.props.expansionTogglePadding;
            }
        }
        return super.getPaddingLeft(node, props);
    }
    getDepthPadding(depth) {
        return super.getDepthPadding(depth) + 5;
    }
    isCurrentThemeLight() {
        const type = this.themeService.getCurrentTheme().type;
        return type.toLocaleLowerCase().includes('light');
    }
    needsExpansionTogglePadding(node) {
        const theme = this.iconThemeService.getDefinition(this.iconThemeService.current);
        if (theme && (theme.hidesExplorerArrows || (theme.hasFileIcons && !theme.hasFolderIcons))) {
            return false;
        }
        return super.needsExpansionTogglePadding(node);
    }
};
exports.ScmTreeWidget = ScmTreeWidget;
ScmTreeWidget.ID = 'scm-resource-widget';
ScmTreeWidget.RESOURCE_GROUP_CONTEXT_MENU = ['RESOURCE_GROUP_CONTEXT_MENU'];
ScmTreeWidget.RESOURCE_GROUP_INLINE_MENU = ['RESOURCE_GROUP_CONTEXT_MENU', 'inline'];
ScmTreeWidget.RESOURCE_FOLDER_CONTEXT_MENU = ['RESOURCE_FOLDER_CONTEXT_MENU'];
ScmTreeWidget.RESOURCE_FOLDER_INLINE_MENU = ['RESOURCE_FOLDER_CONTEXT_MENU', 'inline'];
ScmTreeWidget.RESOURCE_CONTEXT_MENU = ['RESOURCE_CONTEXT_MENU'];
ScmTreeWidget.RESOURCE_INLINE_MENU = ['RESOURCE_CONTEXT_MENU', 'inline'];
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], ScmTreeWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_context_key_service_1.ScmContextKeyService),
    tslib_1.__metadata("design:type", scm_context_key_service_1.ScmContextKeyService)
], ScmTreeWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.EditorManager),
    tslib_1.__metadata("design:type", browser_2.EditorManager)
], ScmTreeWidget.prototype, "editorManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.DiffNavigatorProvider),
    tslib_1.__metadata("design:type", Function)
], ScmTreeWidget.prototype, "diffNavigatorProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(icon_theme_service_1.IconThemeService),
    tslib_1.__metadata("design:type", icon_theme_service_1.IconThemeService)
], ScmTreeWidget.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(decorations_service_1.DecorationsService),
    tslib_1.__metadata("design:type", Object)
], ScmTreeWidget.prototype, "decorationsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], ScmTreeWidget.prototype, "colors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], ScmTreeWidget.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmTreeWidget.prototype, "init", null);
exports.ScmTreeWidget = ScmTreeWidget = ScmTreeWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(tree_1.TreeProps)),
    tslib_1.__param(1, (0, inversify_1.inject)(tree_1.TreeModel)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.ContextMenuRenderer)),
    tslib_1.__metadata("design:paramtypes", [Object, scm_tree_model_1.ScmTreeModel,
        browser_1.ContextMenuRenderer])
], ScmTreeWidget);
(function (ScmTreeWidget) {
    let Styles;
    (function (Styles) {
        Styles.NO_SELECT = 'no-select';
    })(Styles = ScmTreeWidget.Styles || (ScmTreeWidget.Styles = {}));
})(ScmTreeWidget || (exports.ScmTreeWidget = ScmTreeWidget = {}));
class ScmElement extends React.Component {
    constructor(props) {
        super(props);
        this.toDisposeOnUnmount = new disposable_1.DisposableCollection();
        this.detectHover = (element) => {
            if (element) {
                window.requestAnimationFrame(() => {
                    const hover = element.matches(':hover');
                    this.setState({ hover });
                });
            }
        };
        this.showHover = () => this.setState({ hover: true });
        this.hideHover = () => this.setState({ hover: false });
        this.renderContextMenu = (event) => {
            event.preventDefault();
            const { treeNode: node, contextMenuRenderer } = this.props;
            this.props.model.execInNodeContext(node, () => {
                contextMenuRenderer.render({
                    menuPath: this.contextMenuPath,
                    anchor: event.nativeEvent,
                    args: this.contextMenuArgs,
                    context: event.currentTarget
                });
            });
        };
        this.state = {
            hover: false
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            if (!this.toDisposeOnUnmount.disposed) {
                setState(newState);
            }
        };
    }
    componentDidMount() {
        this.toDisposeOnUnmount.push(disposable_1.Disposable.create(() => { }));
    }
    componentWillUnmount() {
        this.toDisposeOnUnmount.dispose();
    }
}
exports.ScmElement = ScmElement;
class ScmResourceComponent extends ScmElement {
    constructor() {
        super(...arguments);
        this.open = () => {
            const resource = this.props.model.getResourceFromNode(this.props.treeNode);
            if (resource) {
                resource.open();
            }
        };
        this.contextMenuPath = ScmTreeWidget.RESOURCE_CONTEXT_MENU;
        /**
         * Handle the single clicking of nodes present in the widget.
         */
        this.handleClick = (event) => {
            if (!this.hasCtrlCmdOrShiftMask(event)) {
                // Determine the behavior based on the preference value.
                const isSingle = this.props.corePreferences && this.props.corePreferences['workbench.list.openMode'] === 'singleClick';
                if (isSingle) {
                    this.open();
                }
            }
        };
        /**
         * Handle the double clicking of nodes present in the widget.
         */
        this.handleDoubleClick = () => {
            // Determine the behavior based on the preference value.
            const isDouble = this.props.corePreferences && this.props.corePreferences['workbench.list.openMode'] === 'doubleClick';
            // Nodes should only be opened through double clicking if the correct preference is set.
            if (isDouble) {
                this.open();
            }
        };
    }
    render() {
        var _a;
        const { hover } = this.state;
        const { model, treeNode, colors, parentPath, sourceUri, decoration, labelProvider, menus, contextKeys, caption, isLightTheme } = this.props;
        const resourceUri = new uri_1.default(sourceUri);
        const decorationIcon = treeNode.decorations;
        const themedIcon = isLightTheme ? decorationIcon === null || decorationIcon === void 0 ? void 0 : decorationIcon.icon : decorationIcon === null || decorationIcon === void 0 ? void 0 : decorationIcon.iconDark;
        const classNames = themedIcon ? ['decoration-icon', themedIcon] : ['decoration-icon', 'status'];
        const icon = labelProvider.getIcon(resourceUri);
        const color = decoration && decoration.colorId && !themedIcon ? `var(${colors.toCssVariableName(decoration.colorId)})` : '';
        const letter = decoration && decoration.letter && !themedIcon ? decoration.letter : '';
        const tooltip = decoration && decoration.tooltip || '';
        const textDecoration = ((_a = treeNode.decorations) === null || _a === void 0 ? void 0 : _a.strikeThrough) === true ? 'line-through' : 'normal';
        const relativePath = parentPath.relative(resourceUri.parent);
        const path = relativePath ? relativePath.fsPath() : labelProvider.getLongName(resourceUri.parent);
        const title = tooltip.length !== 0
            ? `${resourceUri.path.fsPath()} • ${tooltip}`
            : resourceUri.path.fsPath();
        return React.createElement("div", { key: sourceUri, className: `scmItem ${tree_1.TREE_NODE_SEGMENT_CLASS} ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}`, onContextMenu: this.renderContextMenu, onMouseEnter: this.showHover, onMouseLeave: this.hideHover, ref: this.detectHover, title: title, onClick: this.handleClick, onDoubleClick: this.handleDoubleClick },
            React.createElement("span", { className: icon + ' file-icon' }),
            this.props.renderExpansionToggle(),
            React.createElement("div", { className: `noWrapInfo ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}` },
                React.createElement("span", { className: 'name', style: { textDecoration } }, caption),
                React.createElement("span", { className: 'path', style: { textDecoration } }, path)),
            React.createElement(ScmInlineActions, { hover,
                menu: menus.getMenu(ScmTreeWidget.RESOURCE_INLINE_MENU),
                menuPath: ScmTreeWidget.RESOURCE_INLINE_MENU,
                args: this.contextMenuArgs,
                contextKeys,
                model,
                treeNode },
                React.createElement("div", { title: tooltip, className: classNames.join(' '), style: { color } }, letter)));
    }
    get contextMenuArgs() {
        if (!this.props.model.selectedNodes.some(node => scm_tree_model_1.ScmFileChangeNode.is(node) && node === this.props.treeNode)) {
            // Clicked node is not in selection, so ignore selection and action on just clicked node
            return this.singleNodeArgs;
        }
        else {
            return this.props.model.getSelectionArgs(this.props.model.selectedNodes);
        }
    }
    get singleNodeArgs() {
        const selectedResource = this.props.model.getResourceFromNode(this.props.treeNode);
        if (selectedResource) {
            return [selectedResource];
        }
        else {
            // Repository status not yet available. Empty args disables the action.
            return [];
        }
    }
    hasCtrlCmdOrShiftMask(event) {
        const { metaKey, ctrlKey, shiftKey } = event;
        return (os_1.isOSX && metaKey) || ctrlKey || shiftKey;
    }
}
exports.ScmResourceComponent = ScmResourceComponent;
class ScmResourceGroupElement extends ScmElement {
    constructor() {
        super(...arguments);
        this.contextMenuPath = ScmTreeWidget.RESOURCE_GROUP_CONTEXT_MENU;
    }
    render() {
        const { hover } = this.state;
        const { model, treeNode, menus, contextKeys, caption } = this.props;
        return React.createElement("div", { className: `theia-header scm-theia-header ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}`, onContextMenu: this.renderContextMenu, onMouseEnter: this.showHover, onMouseLeave: this.hideHover, ref: this.detectHover },
            this.props.renderExpansionToggle(),
            React.createElement("div", { className: `noWrapInfo ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}` }, caption),
            React.createElement(ScmInlineActions, { hover,
                args: this.contextMenuArgs,
                menu: menus.getMenu(ScmTreeWidget.RESOURCE_GROUP_INLINE_MENU),
                menuPath: ScmTreeWidget.RESOURCE_GROUP_INLINE_MENU,
                contextKeys,
                model,
                treeNode }, this.renderChangeCount()));
    }
    renderChangeCount() {
        const group = this.props.model.getResourceGroupFromNode(this.props.treeNode);
        return React.createElement("div", { className: 'notification-count-container scm-change-count' },
            React.createElement("span", { className: 'notification-count' }, group ? group.resources.length : 0));
    }
    get contextMenuArgs() {
        const group = this.props.model.getResourceGroupFromNode(this.props.treeNode);
        if (group) {
            return [group];
        }
        else {
            // Repository status not yet available. Empty args disables the action.
            return [];
        }
    }
}
exports.ScmResourceGroupElement = ScmResourceGroupElement;
class ScmResourceFolderElement extends ScmElement {
    constructor() {
        super(...arguments);
        this.contextMenuPath = ScmTreeWidget.RESOURCE_FOLDER_CONTEXT_MENU;
    }
    render() {
        const { hover } = this.state;
        const { model, treeNode, sourceUri, labelProvider, menus, contextKeys, caption } = this.props;
        const sourceFileStat = files_1.FileStat.dir(sourceUri);
        const icon = labelProvider.getIcon(sourceFileStat);
        const title = new uri_1.default(sourceUri).path.fsPath();
        return React.createElement("div", { key: sourceUri, className: `scmItem  ${tree_1.TREE_NODE_SEGMENT_CLASS} ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS} ${ScmTreeWidget.Styles.NO_SELECT}`, title: title, onContextMenu: this.renderContextMenu, onMouseEnter: this.showHover, onMouseLeave: this.hideHover, ref: this.detectHover },
            this.props.renderExpansionToggle(),
            React.createElement("span", { className: icon + ' file-icon' }),
            React.createElement("div", { className: `noWrapInfo ${tree_1.TREE_NODE_SEGMENT_GROW_CLASS}` },
                React.createElement("span", { className: 'name' }, caption)),
            React.createElement(ScmInlineActions, { hover,
                menu: menus.getMenu(ScmTreeWidget.RESOURCE_FOLDER_INLINE_MENU),
                menuPath: ScmTreeWidget.RESOURCE_FOLDER_INLINE_MENU,
                args: this.contextMenuArgs,
                contextKeys,
                model,
                treeNode }));
    }
    get contextMenuArgs() {
        if (!this.props.model.selectedNodes.some(node => scm_tree_model_1.ScmFileChangeFolderNode.is(node) && node.sourceUri === this.props.sourceUri)) {
            // Clicked node is not in selection, so ignore selection and action on just clicked node
            return this.singleNodeArgs;
        }
        else {
            return this.props.model.getSelectionArgs(this.props.model.selectedNodes);
        }
    }
    get singleNodeArgs() {
        return this.props.model.getResourcesFromFolderNode(this.props.treeNode);
    }
}
exports.ScmResourceFolderElement = ScmResourceFolderElement;
class ScmInlineActions extends React.Component {
    render() {
        const { hover, menu, menuPath, args, model, treeNode, contextKeys, children } = this.props;
        return React.createElement("div", { className: 'theia-scm-inline-actions-container' },
            React.createElement("div", { className: 'theia-scm-inline-actions' }, hover && (menu === null || menu === void 0 ? void 0 : menu.children.map((node, index) => menu_1.CommandMenu.is(node) &&
                React.createElement(ScmInlineAction, { key: index, node, menuPath, args, model, treeNode, contextKeys })))),
            children);
    }
}
exports.ScmInlineActions = ScmInlineActions;
class ScmInlineAction extends React.Component {
    constructor() {
        super(...arguments);
        this.execute = (event) => {
            event.stopPropagation();
            const { node, menuPath, args } = this.props;
            node.run(menuPath, ...args);
        };
    }
    render() {
        const { node, menuPath, model, treeNode, args, contextKeys } = this.props;
        let isActive = false;
        model.execInNodeContext(treeNode, () => {
            isActive = node.isVisible(menuPath, contextKeys, undefined, ...args);
        });
        if (!isActive) {
            return false;
        }
        return React.createElement("div", { className: 'theia-scm-inline-action' },
            React.createElement("a", { className: `${node.icon} ${browser_1.ACTION_ITEM}`, title: node.label, onClick: this.execute }));
    }
}
exports.ScmInlineAction = ScmInlineAction;


/***/ }),

/***/ "./node_modules/@theia/scm/lib/browser/scm-widget.js":
/*!***********************************************************!*\
  !*** ./node_modules/@theia/scm/lib/browser/scm-widget.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var ScmWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "./node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "./node_modules/@theia/core/lib/common/disposable.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "./node_modules/@theia/core/lib/browser/index.js");
const scm_commit_widget_1 = __webpack_require__(/*! ./scm-commit-widget */ "./node_modules/@theia/scm/lib/browser/scm-commit-widget.js");
const scm_amend_widget_1 = __webpack_require__(/*! ./scm-amend-widget */ "./node_modules/@theia/scm/lib/browser/scm-amend-widget.js");
const scm_no_repository_widget_1 = __webpack_require__(/*! ./scm-no-repository-widget */ "./node_modules/@theia/scm/lib/browser/scm-no-repository-widget.js");
const scm_service_1 = __webpack_require__(/*! ./scm-service */ "./node_modules/@theia/scm/lib/browser/scm-service.js");
const scm_tree_widget_1 = __webpack_require__(/*! ./scm-tree-widget */ "./node_modules/@theia/scm/lib/browser/scm-tree-widget.js");
const scm_preferences_1 = __webpack_require__(/*! ./scm-preferences */ "./node_modules/@theia/scm/lib/browser/scm-preferences.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "./node_modules/@theia/core/lib/common/nls.js");
let ScmWidget = ScmWidget_1 = class ScmWidget extends browser_1.BaseWidget {
    set viewMode(mode) {
        this.resourceWidget.viewMode = mode;
    }
    get viewMode() {
        return this.resourceWidget.viewMode;
    }
    constructor() {
        super();
        this.toDisposeOnRefresh = new disposable_1.DisposableCollection();
        this.node.tabIndex = 0;
        this.id = ScmWidget_1.ID;
        this.addClass('theia-scm');
        this.addClass('theia-scm-main-container');
    }
    init() {
        const layout = new browser_1.PanelLayout();
        this.layout = layout;
        this.panel = new browser_1.Panel({
            layout: new browser_1.PanelLayout({})
        });
        this.panel.node.tabIndex = -1;
        this.panel.node.setAttribute('class', 'theia-scm-panel');
        layout.addWidget(this.panel);
        this.containerLayout.addWidget(this.commitWidget);
        this.containerLayout.addWidget(this.resourceWidget);
        this.containerLayout.addWidget(this.amendWidget);
        this.containerLayout.addWidget(this.noRepositoryWidget);
        this.refresh();
        this.toDispose.push(this.scmService.onDidChangeSelectedRepository(() => this.refresh()));
        this.updateViewMode(this.scmPreferences.get('scm.defaultViewMode'));
        this.toDispose.push(this.scmPreferences.onPreferenceChanged(e => {
            if (e.preferenceName === 'scm.defaultViewMode') {
                this.updateViewMode(e.newValue);
            }
        }));
        this.toDispose.push(this.shell.onDidChangeCurrentWidget(({ newValue }) => {
            const uri = browser_1.NavigatableWidget.getUri(newValue || undefined);
            if (uri) {
                this.resourceWidget.selectNodeByUri(uri);
            }
        }));
    }
    get containerLayout() {
        return this.panel.layout;
    }
    /**
     * Updates the view mode based on the preference value.
     * @param preference the view mode preference.
     */
    updateViewMode(preference) {
        this.viewMode = preference;
    }
    refresh() {
        this.toDisposeOnRefresh.dispose();
        this.toDispose.push(this.toDisposeOnRefresh);
        const repository = this.scmService.selectedRepository;
        this.title.label = repository ? repository.provider.label : nls_1.nls.localize('theia/scm/noRepositoryFound', 'No repository found');
        this.title.caption = this.title.label;
        this.update();
        if (repository) {
            this.toDisposeOnRefresh.push(repository.onDidChange(() => this.update()));
            // render synchronously to avoid cursor jumping
            // see https://stackoverflow.com/questions/28922275/in-reactjs-why-does-setstate-behave-differently-when-called-synchronously/28922465#28922465
            this.toDisposeOnRefresh.push(repository.input.onDidChange(() => this.updateImmediately()));
            this.toDisposeOnRefresh.push(repository.input.onDidFocus(() => this.focusInput()));
            this.commitWidget.show();
            this.resourceWidget.show();
            this.amendWidget.show();
            this.noRepositoryWidget.hide();
        }
        else {
            this.commitWidget.hide();
            this.resourceWidget.hide();
            this.amendWidget.hide();
            this.noRepositoryWidget.show();
        }
    }
    updateImmediately() {
        this.onUpdateRequest(browser_1.Widget.Msg.UpdateRequest);
    }
    onUpdateRequest(msg) {
        browser_1.MessageLoop.sendMessage(this.commitWidget, msg);
        browser_1.MessageLoop.sendMessage(this.resourceWidget, msg);
        browser_1.MessageLoop.sendMessage(this.amendWidget, msg);
        browser_1.MessageLoop.sendMessage(this.noRepositoryWidget, msg);
        super.onUpdateRequest(msg);
    }
    onAfterAttach(msg) {
        this.node.appendChild(this.commitWidget.node);
        this.node.appendChild(this.resourceWidget.node);
        this.node.appendChild(this.amendWidget.node);
        this.node.appendChild(this.noRepositoryWidget.node);
        super.onAfterAttach(msg);
        this.update();
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.refresh();
        if (this.commitWidget.isVisible) {
            this.commitWidget.focus();
        }
        else {
            this.node.focus();
        }
    }
    focusInput() {
        this.commitWidget.focus();
    }
    storeState() {
        const state = {
            commitState: this.commitWidget.storeState(),
            changesTreeState: this.resourceWidget.storeState(),
        };
        return state;
    }
    restoreState(oldState) {
        const { commitState, changesTreeState } = oldState;
        this.commitWidget.restoreState(commitState);
        this.resourceWidget.restoreState(changesTreeState);
    }
    collapseScmTree() {
        const { model } = this.resourceWidget;
        const root = model.root;
        if (browser_1.CompositeTreeNode.is(root)) {
            root.children.map(group => {
                if (browser_1.CompositeTreeNode.is(group)) {
                    group.children.map(folderNode => {
                        if (browser_1.CompositeTreeNode.is(folderNode)) {
                            model.collapseAll(folderNode);
                        }
                        if (browser_1.SelectableTreeNode.isSelected(folderNode)) {
                            model.toggleNode(folderNode);
                        }
                    });
                }
            });
        }
    }
};
exports.ScmWidget = ScmWidget;
ScmWidget.ID = 'scm-view';
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], ScmWidget.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], ScmWidget.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_commit_widget_1.ScmCommitWidget),
    tslib_1.__metadata("design:type", scm_commit_widget_1.ScmCommitWidget)
], ScmWidget.prototype, "commitWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_tree_widget_1.ScmTreeWidget),
    tslib_1.__metadata("design:type", scm_tree_widget_1.ScmTreeWidget)
], ScmWidget.prototype, "resourceWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_amend_widget_1.ScmAmendWidget),
    tslib_1.__metadata("design:type", scm_amend_widget_1.ScmAmendWidget)
], ScmWidget.prototype, "amendWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_no_repository_widget_1.ScmNoRepositoryWidget),
    tslib_1.__metadata("design:type", scm_no_repository_widget_1.ScmNoRepositoryWidget)
], ScmWidget.prototype, "noRepositoryWidget", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_preferences_1.ScmPreferences),
    tslib_1.__metadata("design:type", Object)
], ScmWidget.prototype, "scmPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ScmWidget.prototype, "init", null);
exports.ScmWidget = ScmWidget = ScmWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ScmWidget);


/***/ }),

/***/ "./node_modules/@theia/scm/src/browser/style/scm-amend-component.css":
/*!***************************************************************************!*\
  !*** ./node_modules/@theia/scm/src/browser/style/scm-amend-component.css ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_scm_amend_component_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js!./scm-amend-component.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/@theia/scm/src/browser/style/scm-amend-component.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_scm_amend_component_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_scm_amend_component_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/@theia/scm/src/browser/style/scm-amend-component.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/@theia/scm/src/browser/style/scm-amend-component.css ***!
  \*****************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-scm-commit-container {
  display: flex;
  flex-direction: column;
  border-top: 1px solid var(--theia-sideBarSectionHeader-border);
  width: 100%;
  padding-top: 6px;
}

.theia-scm-amend-outer-container {
  display: flex;
  flex-direction: column;
  width: 100%;
  overflow: auto;
}

.theia-scm-commit-and-button {
  display: flex;
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
}

.theia-scm-commit-avatar-and-text {
  display: flex;
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
  padding-top: 2px;
}

.theia-scm-commit-avatar-and-text img {
  width: 27px;
}

.theia-scm-commit-details {
  display: flex;
  flex-direction: column;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
}

.theia-scm-commit-message-avatar {
  margin-right: 5px;
}

.theia-scm-commit-message-summary {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.theia-scm-commit-message-time {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: var(--theia-descriptionForeground);
  font-size: smaller;
}

.theia-scm-flex-container-center {
  display: flex;
  align-items: center;
}

.theia-scm-scrolling-container {
  position: relative;
  width: 100%;
  overflow: hidden;

  margin-top: 0;
  margin-bottom: 0;
  padding-top: 0;
  padding-bottom: 0;
  border-top: 0;
  border-bottom: 0;
}
`, "",{"version":3,"sources":["webpack://./node_modules/@theia/scm/src/browser/style/scm-amend-component.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,aAAa;EACb,sBAAsB;EACtB,8DAA8D;EAC9D,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,WAAW;EACX,cAAc;AAChB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,gBAAgB;EAChB,WAAW;AACb;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,gBAAgB;EAChB,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;EACvB,WAAW;AACb;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;AACzB;;AAEA;EACE,mBAAmB;EACnB,gBAAgB;EAChB,uBAAuB;EACvB,yCAAyC;EACzC,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,gBAAgB;;EAEhB,aAAa;EACb,gBAAgB;EAChB,cAAc;EACd,iBAAiB;EACjB,aAAa;EACb,gBAAgB;AAClB","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-scm-commit-container {\n  display: flex;\n  flex-direction: column;\n  border-top: 1px solid var(--theia-sideBarSectionHeader-border);\n  width: 100%;\n  padding-top: 6px;\n}\n\n.theia-scm-amend-outer-container {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  overflow: auto;\n}\n\n.theia-scm-commit-and-button {\n  display: flex;\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%;\n}\n\n.theia-scm-commit-avatar-and-text {\n  display: flex;\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%;\n  padding-top: 2px;\n}\n\n.theia-scm-commit-avatar-and-text img {\n  width: 27px;\n}\n\n.theia-scm-commit-details {\n  display: flex;\n  flex-direction: column;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  width: 100%;\n}\n\n.theia-scm-commit-message-avatar {\n  margin-right: 5px;\n}\n\n.theia-scm-commit-message-summary {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.theia-scm-commit-message-time {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  color: var(--theia-descriptionForeground);\n  font-size: smaller;\n}\n\n.theia-scm-flex-container-center {\n  display: flex;\n  align-items: center;\n}\n\n.theia-scm-scrolling-container {\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n\n  margin-top: 0;\n  margin-bottom: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  border-top: 0;\n  border-bottom: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/diff/lib/convert/dmp.js":
/*!**********************************************!*\
  !*** ./node_modules/diff/lib/convert/dmp.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertChangesToDMP = convertChangesToDMP;

/*istanbul ignore end*/
// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change,
      operation;

  for (var i = 0; i < changes.length; i++) {
    change = changes[i];

    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }

  return ret;
}


/***/ }),

/***/ "./node_modules/diff/lib/convert/xml.js":
/*!**********************************************!*\
  !*** ./node_modules/diff/lib/convert/xml.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.convertChangesToXML = convertChangesToXML;

/*istanbul ignore end*/
function convertChangesToXML(changes) {
  var ret = [];

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }

  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');
  return n;
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/array.js":
/*!*********************************************!*\
  !*** ./node_modules/diff/lib/diff/array.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffArrays = diffArrays;
exports.arrayDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var arrayDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.arrayDiff = arrayDiff;

/*istanbul ignore end*/
arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/base.js":
/*!********************************************!*\
  !*** ./node_modules/diff/lib/diff/base.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var _options$timeout;

    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;

    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }

    var maxExecutionTime =
    /*istanbul ignore start*/
    (_options$timeout =
    /*istanbul ignore end*/
    options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: undefined
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Once we hit the right edge of the edit graph on some diagonal k, we can
    // definitely reach the end of the edit graph in no more than k edits, so
    // there's no point in considering any moves to diagonal k+1 any more (from
    // which we're guaranteed to need at least k+1 more edits).
    // Similarly, once we've reached the bottom of the edit graph, there's no
    // point considering moves to lower diagonals.
    // We record this fact by setting minDiagonalToConsider and
    // maxDiagonalToConsider to some finite value once we've hit the edge of
    // the edit graph.
    // This optimization is not faithful to the original algorithm presented in
    // Myers's paper, which instead pointlessly extends D-paths off the end of
    // the edit graph - see page 7 of Myers's paper which notes this point
    // explicitly and illustrates it with a diagram. This has major performance
    // implications for some common scenarios. For instance, to compute a diff
    // where the new text simply appends d characters on the end of the
    // original text of length n, the true Myers algorithm will take O(n+d^2)
    // time while this optimization needs only O(n+d) time.


    var minDiagonalToConsider = -Infinity,
        maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.

    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;
        var removePath = bestPath[diagonalPath - 1],
            addPath = bestPath[diagonalPath + 1];

        if (removePath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = false;

        if (addPath) {
          // what newPos will be after we do an insertion:
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }

        var canRemove = removePath && removePath.oldPos + 1 < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the old string is the farthest from the origin
        // and does not pass the bounds of the diff graph
        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm
        //       and prefer to order removals before insertions.


        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, undefined, 0);
        } else {
          basePath = self.addToPath(removePath, undefined, true, 1);
        }

        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          // If we have hit the end of both strings, then we are done
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;

          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }

          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced, or until the edit length exceeds options.maxEditLength (if given),
    // in which case it will return undefined.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  addToPath: function addToPath(path, added, removed, oldPosInc) {
    var last = path.lastComponent;

    if (last && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added: added,
          removed: removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added: added,
          removed: removed,
          previousComponent: last
        }
      };
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        oldPos = basePath.oldPos,
        newPos = oldPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }

    basePath.oldPos = oldPos;
    return newPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {
  // First we convert our linked list of components in reverse order to an
  // array in the right order:
  var components = [];
  var nextComponent;

  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }

  components.reverse();
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var finalComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }

  return components;
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/character.js":
/*!*************************************************!*\
  !*** ./node_modules/diff/lib/diff/character.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffChars = diffChars;
exports.characterDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.characterDiff = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/css.js":
/*!*******************************************!*\
  !*** ./node_modules/diff/lib/diff/css.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffCss = diffCss;
exports.cssDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var cssDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.cssDiff = cssDiff;

/*istanbul ignore end*/
cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/json.js":
/*!********************************************!*\
  !*** ./node_modules/diff/lib/diff/json.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffJson = diffJson;
exports.canonicalize = canonicalize;
exports.jsonDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ./line */ "./node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*istanbul ignore end*/
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
](); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

/*istanbul ignore start*/
exports.jsonDiff = jsonDiff;

/*istanbul ignore end*/
jsonDiff.useLongestToken = true;
jsonDiff.tokenize =
/*istanbul ignore start*/
_line
/*istanbul ignore end*/
.
/*istanbul ignore start*/
lineDiff
/*istanbul ignore end*/
.tokenize;

jsonDiff.castInput = function (value) {
  /*istanbul ignore start*/
  var _this$options =
  /*istanbul ignore end*/
  this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v)
  /*istanbul ignore start*/
  {
    return (
      /*istanbul ignore end*/
      typeof v === 'undefined' ? undefinedReplacement : v
    );
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return (
    /*istanbul ignore start*/
    _base
    /*istanbul ignore end*/
    [
    /*istanbul ignore start*/
    "default"
    /*istanbul ignore end*/
    ].prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
  );
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer


function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (
  /*istanbul ignore start*/
  _typeof(
  /*istanbul ignore end*/
  obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/line.js":
/*!********************************************!*\
  !*** ./node_modules/diff/lib/diff/line.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffLines = diffLines;
exports.diffTrimmedLines = diffTrimmedLines;
exports.lineDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_params = __webpack_require__(/*! ../util/params */ "./node_modules/diff/lib/util/params.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var lineDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.lineDiff = lineDiff;

/*istanbul ignore end*/
lineDiff.tokenize = function (value) {
  if (this.options.stripTrailingCr) {
    // remove one \r before \n to match GNU diff's --strip-trailing-cr behavior
    value = value.replace(/\r\n/g, '\n');
  }

  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}

function diffTrimmedLines(oldStr, newStr, callback) {
  var options =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _params
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  generateOptions)
  /*istanbul ignore end*/
  (callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/sentence.js":
/*!************************************************!*\
  !*** ./node_modules/diff/lib/diff/sentence.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffSentences = diffSentences;
exports.sentenceDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
var sentenceDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.sentenceDiff = sentenceDiff;

/*istanbul ignore end*/
sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}


/***/ }),

/***/ "./node_modules/diff/lib/diff/word.js":
/*!********************************************!*\
  !*** ./node_modules/diff/lib/diff/word.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diffWords = diffWords;
exports.diffWordsWithSpace = diffWordsWithSpace;
exports.wordDiff = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_params = __webpack_require__(/*! ../util/params */ "./node_modules/diff/lib/util/params.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
//
// Ranges and exceptions:
// Latin-1 Supplement, 0080–00FF
//  - U+00D7  × Multiplication sign
//  - U+00F7  ÷ Division sign
// Latin Extended-A, 0100–017F
// Latin Extended-B, 0180–024F
// IPA Extensions, 0250–02AF
// Spacing Modifier Letters, 02B0–02FF
//  - U+02C7  ˇ &#711;  Caron
//  - U+02D8  ˘ &#728;  Breve
//  - U+02D9  ˙ &#729;  Dot Above
//  - U+02DA  ˚ &#730;  Ring Above
//  - U+02DB  ˛ &#731;  Ogonek
//  - U+02DC  ˜ &#732;  Small Tilde
//  - U+02DD  ˝ &#733;  Double Acute Accent
// Latin Extended Additional, 1E00–1EFF
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();

/*istanbul ignore start*/
exports.wordDiff = wordDiff;

/*istanbul ignore end*/
wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  // All whitespace symbols except newline group into one token, each newline - in separate token
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _params
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  generateOptions)
  /*istanbul ignore end*/
  (options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}

function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ "./node_modules/diff/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/diff/lib/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Diff", ({
  enumerable: true,
  get: function get() {
    return _base["default"];
  }
}));
Object.defineProperty(exports, "diffChars", ({
  enumerable: true,
  get: function get() {
    return _character.diffChars;
  }
}));
Object.defineProperty(exports, "diffWords", ({
  enumerable: true,
  get: function get() {
    return _word.diffWords;
  }
}));
Object.defineProperty(exports, "diffWordsWithSpace", ({
  enumerable: true,
  get: function get() {
    return _word.diffWordsWithSpace;
  }
}));
Object.defineProperty(exports, "diffLines", ({
  enumerable: true,
  get: function get() {
    return _line.diffLines;
  }
}));
Object.defineProperty(exports, "diffTrimmedLines", ({
  enumerable: true,
  get: function get() {
    return _line.diffTrimmedLines;
  }
}));
Object.defineProperty(exports, "diffSentences", ({
  enumerable: true,
  get: function get() {
    return _sentence.diffSentences;
  }
}));
Object.defineProperty(exports, "diffCss", ({
  enumerable: true,
  get: function get() {
    return _css.diffCss;
  }
}));
Object.defineProperty(exports, "diffJson", ({
  enumerable: true,
  get: function get() {
    return _json.diffJson;
  }
}));
Object.defineProperty(exports, "canonicalize", ({
  enumerable: true,
  get: function get() {
    return _json.canonicalize;
  }
}));
Object.defineProperty(exports, "diffArrays", ({
  enumerable: true,
  get: function get() {
    return _array.diffArrays;
  }
}));
Object.defineProperty(exports, "applyPatch", ({
  enumerable: true,
  get: function get() {
    return _apply.applyPatch;
  }
}));
Object.defineProperty(exports, "applyPatches", ({
  enumerable: true,
  get: function get() {
    return _apply.applyPatches;
  }
}));
Object.defineProperty(exports, "parsePatch", ({
  enumerable: true,
  get: function get() {
    return _parse.parsePatch;
  }
}));
Object.defineProperty(exports, "merge", ({
  enumerable: true,
  get: function get() {
    return _merge.merge;
  }
}));
Object.defineProperty(exports, "reversePatch", ({
  enumerable: true,
  get: function get() {
    return _reverse.reversePatch;
  }
}));
Object.defineProperty(exports, "structuredPatch", ({
  enumerable: true,
  get: function get() {
    return _create.structuredPatch;
  }
}));
Object.defineProperty(exports, "createTwoFilesPatch", ({
  enumerable: true,
  get: function get() {
    return _create.createTwoFilesPatch;
  }
}));
Object.defineProperty(exports, "createPatch", ({
  enumerable: true,
  get: function get() {
    return _create.createPatch;
  }
}));
Object.defineProperty(exports, "formatPatch", ({
  enumerable: true,
  get: function get() {
    return _create.formatPatch;
  }
}));
Object.defineProperty(exports, "convertChangesToDMP", ({
  enumerable: true,
  get: function get() {
    return _dmp.convertChangesToDMP;
  }
}));
Object.defineProperty(exports, "convertChangesToXML", ({
  enumerable: true,
  get: function get() {
    return _xml.convertChangesToXML;
  }
}));

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(/*! ./diff/base */ "./node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_character = __webpack_require__(/*! ./diff/character */ "./node_modules/diff/lib/diff/character.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_word = __webpack_require__(/*! ./diff/word */ "./node_modules/diff/lib/diff/word.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ./diff/line */ "./node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_sentence = __webpack_require__(/*! ./diff/sentence */ "./node_modules/diff/lib/diff/sentence.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_css = __webpack_require__(/*! ./diff/css */ "./node_modules/diff/lib/diff/css.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_json = __webpack_require__(/*! ./diff/json */ "./node_modules/diff/lib/diff/json.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_array = __webpack_require__(/*! ./diff/array */ "./node_modules/diff/lib/diff/array.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_apply = __webpack_require__(/*! ./patch/apply */ "./node_modules/diff/lib/patch/apply.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./patch/parse */ "./node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_merge = __webpack_require__(/*! ./patch/merge */ "./node_modules/diff/lib/patch/merge.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_reverse = __webpack_require__(/*! ./patch/reverse */ "./node_modules/diff/lib/patch/reverse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_create = __webpack_require__(/*! ./patch/create */ "./node_modules/diff/lib/patch/create.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_dmp = __webpack_require__(/*! ./convert/dmp */ "./node_modules/diff/lib/convert/dmp.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_xml = __webpack_require__(/*! ./convert/xml */ "./node_modules/diff/lib/convert/xml.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/


/***/ }),

/***/ "./node_modules/diff/lib/patch/apply.js":
/*!**********************************************!*\
  !*** ./node_modules/diff/lib/patch/apply.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyPatch = applyPatch;
exports.applyPatches = applyPatches;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./parse */ "./node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_distanceIterator = _interopRequireDefault(__webpack_require__(/*! ../util/distance-iterator */ "./node_modules/diff/lib/util/distance-iterator.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*istanbul ignore end*/
function applyPatch(source, uniDiff) {
  /*istanbul ignore start*/
  var
  /*istanbul ignore end*/
  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof uniDiff === 'string') {
    uniDiff =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _parse
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    parsePatch)
    /*istanbul ignore end*/
    (uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  } // Apply the diff to the input


  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent)
  /*istanbul ignore start*/
  {
    return (
      /*istanbul ignore end*/
      line === patchContent
    );
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL,
      addEOFNL;
  /**
   * Checks if the hunk exactly fits on the provided location
   */


  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line;

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }

        toPos++;
      }
    }

    return true;
  } // Search best fit offsets for each hunk based on the previous ones


  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;
    var iterator =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _distanceIterator
    /*istanbul ignore end*/
    [
    /*istanbul ignore start*/
    "default"
    /*istanbul ignore end*/
    ])(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    } // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text


    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  } // Apply patch hunks


  var diffOffset = 0;

  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

    diffOffset += _hunk.newLines - _hunk.oldLines;

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line,
          delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\n';

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
        lines.splice(_toPos, 0, content);
        delimiters.splice(_toPos, 0, delimiter);
        _toPos++;
      } else if (operation === '\\') {
        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

        if (previousOperation === '+') {
          removeEOFNL = true;
        } else if (previousOperation === '-') {
          addEOFNL = true;
        }
      }
    }
  } // Handle EOFNL insertion/removal


  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }

  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }

  return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.


function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _parse
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    parsePatch)
    /*istanbul ignore end*/
    (uniDiff);
  }

  var currentIndex = 0;

  function processIndex() {
    var index = uniDiff[currentIndex++];

    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }

  processIndex();
}


/***/ }),

/***/ "./node_modules/diff/lib/patch/create.js":
/*!***********************************************!*\
  !*** ./node_modules/diff/lib/patch/create.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.structuredPatch = structuredPatch;
exports.formatPatch = formatPatch;
exports.createTwoFilesPatch = createTwoFilesPatch;
exports.createPatch = createPatch;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_line = __webpack_require__(/*! ../diff/line */ "./node_modules/diff/lib/diff/line.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*istanbul ignore end*/
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }

  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff =
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _line
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  diffLines)
  /*istanbul ignore end*/
  (oldStr, newStr, options);

  if (!diff) {
    return;
  }

  diff.push({
    value: '',
    lines: []
  }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;

  /*istanbul ignore start*/
  var _loop = function _loop(
  /*istanbul ignore end*/
  i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      /*istanbul ignore start*/
      var _curRange;

      /*istanbul ignore end*/
      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      } // Output our changes


      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_curRange =
      /*istanbul ignore end*/
      curRange).push.apply(
      /*istanbul ignore start*/
      _curRange
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      }))); // Track the updated file position


      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          /*istanbul ignore start*/
          var _curRange2;

          /*istanbul ignore end*/
          // Overlapping

          /*istanbul ignore start*/

          /*istanbul ignore end*/

          /*istanbul ignore start*/
          (_curRange2 =
          /*istanbul ignore end*/
          curRange).push.apply(
          /*istanbul ignore start*/
          _curRange2
          /*istanbul ignore end*/
          ,
          /*istanbul ignore start*/
          _toConsumableArray(
          /*istanbul ignore end*/
          contextLines(lines)));
        } else {
          /*istanbul ignore start*/
          var _curRange3;

          /*istanbul ignore end*/
          // end the range and output
          var contextSize = Math.min(lines.length, options.context);

          /*istanbul ignore start*/

          /*istanbul ignore end*/

          /*istanbul ignore start*/
          (_curRange3 =
          /*istanbul ignore end*/
          curRange).push.apply(
          /*istanbul ignore start*/
          _curRange3
          /*istanbul ignore end*/
          ,
          /*istanbul ignore start*/
          _toConsumableArray(
          /*istanbul ignore end*/
          contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };

          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              // however, if the old file is empty, do not output the no-nl line
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            }

            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }

          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }

      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    /*istanbul ignore start*/
    _loop(
    /*istanbul ignore end*/
    i);
  }

  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}

function formatPatch(diff) {
  if (Array.isArray(diff)) {
    return diff.map(formatPatch).join('\n');
  }

  var ret = [];

  if (diff.oldFileName == diff.newFileName) {
    ret.push('Index: ' + diff.oldFileName);
  }

  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }

    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}

function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}

function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}


/***/ }),

/***/ "./node_modules/diff/lib/patch/merge.js":
/*!**********************************************!*\
  !*** ./node_modules/diff/lib/patch/merge.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.calcLineCount = calcLineCount;
exports.merge = merge;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_create = __webpack_require__(/*! ./create */ "./node_modules/diff/lib/patch/create.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_parse = __webpack_require__(/*! ./parse */ "./node_modules/diff/lib/patch/parse.js")
/*istanbul ignore end*/
;

var
/*istanbul ignore start*/
_array = __webpack_require__(/*! ../util/array */ "./node_modules/diff/lib/util/array.js")
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*istanbul ignore end*/
function calcLineCount(hunk) {
  /*istanbul ignore start*/
  var _calcOldNewLineCount =
  /*istanbul ignore end*/
  calcOldNewLineCount(hunk.lines),
      oldLines = _calcOldNewLineCount.oldLines,
      newLines = _calcOldNewLineCount.newLines;

  if (oldLines !== undefined) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }

  if (newLines !== undefined) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}

function merge(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
  // Leaving sanity checks on this to the API consumer that may know more about the
  // meaning in their own context.

  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }

  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      // No header or no change in ours, use theirs (and ours if theirs does not exist)
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      // No header or no change in theirs, use ours
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      // Both changed... figure it out
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }

  ret.hunks = [];
  var mineIndex = 0,
      theirsIndex = 0,
      mineOffset = 0,
      theirsOffset = 0;

  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    },
        theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };

    if (hunkBefore(mineCurrent, theirsCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      // Overlap, merge as best we can
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }

  return ret;
}

function loadPatch(param, base) {
  if (typeof param === 'string') {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return (
        /*istanbul ignore start*/
        (0,
        /*istanbul ignore end*/

        /*istanbul ignore start*/
        _parse
        /*istanbul ignore end*/
        .
        /*istanbul ignore start*/
        parsePatch)
        /*istanbul ignore end*/
        (param)[0]
      );
    }

    if (!base) {
      throw new Error('Must provide a base reference or pass in a patch');
    }

    return (
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/

      /*istanbul ignore start*/
      _create
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      structuredPatch)
      /*istanbul ignore end*/
      (undefined, undefined, base, param)
    );
  }

  return param;
}

function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}

function selectField(index, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index.conflict = true;
    return {
      mine: mine,
      theirs: theirs
    };
  }
}

function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}

function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}

function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  // This will generally result in a conflicted hunk, but there are cases where the context
  // is the only overlap where we can successfully merge the content here.
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  },
      their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  }; // Handle any leading content

  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index],
        theirCurrent = their.lines[their.index];

    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
      // Both modified ...
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
      /*istanbul ignore start*/
      var _hunk$lines;

      /*istanbul ignore end*/
      // Mine inserted

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      collectChange(mine)));
    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
      /*istanbul ignore start*/
      var _hunk$lines2;

      /*istanbul ignore end*/
      // Theirs inserted

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines2 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines2
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      collectChange(their)));
    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
      // Mine removed or edited
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
      // Their removed or edited
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      // Context identity
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      // Context mismatch
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  } // Now push anything that may be remaining


  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}

function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine),
      theirChanges = collectChange(their);

  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    // Special case for remove changes that are supersets of one another
    if (
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _array
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    arrayStartsWith)
    /*istanbul ignore end*/
    (myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      /*istanbul ignore start*/
      var _hunk$lines3;

      /*istanbul ignore end*/

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines3 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines3
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      myChanges));

      return;
    } else if (
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/

    /*istanbul ignore start*/
    _array
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    arrayStartsWith)
    /*istanbul ignore end*/
    (theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      /*istanbul ignore start*/
      var _hunk$lines4;

      /*istanbul ignore end*/

      /*istanbul ignore start*/

      /*istanbul ignore end*/

      /*istanbul ignore start*/
      (_hunk$lines4 =
      /*istanbul ignore end*/
      hunk.lines).push.apply(
      /*istanbul ignore start*/
      _hunk$lines4
      /*istanbul ignore end*/
      ,
      /*istanbul ignore start*/
      _toConsumableArray(
      /*istanbul ignore end*/
      theirChanges));

      return;
    }
  } else if (
  /*istanbul ignore start*/
  (0,
  /*istanbul ignore end*/

  /*istanbul ignore start*/
  _array
  /*istanbul ignore end*/
  .
  /*istanbul ignore start*/
  arrayEqual)
  /*istanbul ignore end*/
  (myChanges, theirChanges)) {
    /*istanbul ignore start*/
    var _hunk$lines5;

    /*istanbul ignore end*/

    /*istanbul ignore start*/

    /*istanbul ignore end*/

    /*istanbul ignore start*/
    (_hunk$lines5 =
    /*istanbul ignore end*/
    hunk.lines).push.apply(
    /*istanbul ignore start*/
    _hunk$lines5
    /*istanbul ignore end*/
    ,
    /*istanbul ignore start*/
    _toConsumableArray(
    /*istanbul ignore end*/
    myChanges));

    return;
  }

  conflict(hunk, myChanges, theirChanges);
}

function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine),
      theirChanges = collectContext(their, myChanges);

  if (theirChanges.merged) {
    /*istanbul ignore start*/
    var _hunk$lines6;

    /*istanbul ignore end*/

    /*istanbul ignore start*/

    /*istanbul ignore end*/

    /*istanbul ignore start*/
    (_hunk$lines6 =
    /*istanbul ignore end*/
    hunk.lines).push.apply(
    /*istanbul ignore start*/
    _hunk$lines6
    /*istanbul ignore end*/
    ,
    /*istanbul ignore start*/
    _toConsumableArray(
    /*istanbul ignore end*/
    theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}

function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine: mine,
    theirs: their
  });
}

function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}

function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}

function collectChange(state) {
  var ret = [],
      operation = state.lines[state.index][0];

  while (state.index < state.lines.length) {
    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

    if (operation === '-' && line[0] === '+') {
      operation = '+';
    }

    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }

  return ret;
}

function collectContext(state, matchChanges) {
  var changes = [],
      merged = [],
      matchIndex = 0,
      contextChanges = false,
      conflicted = false;

  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index],
        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

    if (match[0] === '+') {
      break;
    }

    contextChanges = contextChanges || change[0] !== ' ';
    merged.push(match);
    matchIndex++; // Consume any additions in the other block as a conflict to attempt
    // to pull in the remaining context after this

    if (change[0] === '+') {
      conflicted = true;

      while (change[0] === '+') {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }

    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }

  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
    conflicted = true;
  }

  if (conflicted) {
    return changes;
  }

  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }

  return {
    merged: merged,
    changes: changes
  };
}

function allRemoves(changes) {
  return changes.reduce(function (prev, change) {
    return prev && change[0] === '-';
  }, true);
}

function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

    if (state.lines[state.index + i] !== ' ' + changeContent) {
      return false;
    }
  }

  state.index += delta;
  return true;
}

function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function (line) {
    if (typeof line !== 'string') {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);

      if (oldLines !== undefined) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = undefined;
        }
      }

      if (newLines !== undefined) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = undefined;
        }
      }
    } else {
      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
        newLines++;
      }

      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
        oldLines++;
      }
    }
  });
  return {
    oldLines: oldLines,
    newLines: newLines
  };
}


/***/ }),

/***/ "./node_modules/diff/lib/patch/parse.js":
/*!**********************************************!*\
  !*** ./node_modules/diff/lib/patch/parse.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parsePatch = parsePatch;

/*istanbul ignore end*/
function parsePatch(uniDiff) {
  /*istanbul ignore start*/
  var
  /*istanbul ignore end*/
  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index); // Parse diff metadata

    while (i < diffstr.length) {
      var line = diffstr[i]; // File header found, end parsing diff metadata

      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      } // Diff index


      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

      if (header) {
        index.index = header[1];
      }

      i++;
    } // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header


    parseFileHeader(index);
    parseFileHeader(index); // Parse hunks

    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  } // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.


  function parseFileHeader(index) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      var data = fileHeader[2].split('\t', 2);
      var fileName = data[0].replace(/\\\\/g, '\\');

      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }

      index[keyPrefix + 'FileName'] = fileName;
      index[keyPrefix + 'Header'] = (data[1] || '').trim();
      i++;
    }
  } // Parses a hunk
  // This assumes that we are at the start of a hunk.


  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],
      lines: [],
      linedelimiters: []
    }; // Unified Diff Format quirk: If the chunk size is 0,
    // the first number is one lower than one would expect.
    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293

    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }

    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }

    var addCount = 0,
        removeCount = 0;

    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }

      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    } // Handle the empty block count case


    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }

    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    } // Perform optional sanity checking


    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }

      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}


/***/ }),

/***/ "./node_modules/diff/lib/patch/reverse.js":
/*!************************************************!*\
  !*** ./node_modules/diff/lib/patch/reverse.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.reversePatch = reversePatch;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*istanbul ignore end*/
function reversePatch(structuredPatch) {
  if (Array.isArray(structuredPatch)) {
    return structuredPatch.map(reversePatch).reverse();
  }

  return (
    /*istanbul ignore start*/
    _objectSpread(_objectSpread({},
    /*istanbul ignore end*/
    structuredPatch), {}, {
      oldFileName: structuredPatch.newFileName,
      oldHeader: structuredPatch.newHeader,
      newFileName: structuredPatch.oldFileName,
      newHeader: structuredPatch.oldHeader,
      hunks: structuredPatch.hunks.map(function (hunk) {
        return {
          oldLines: hunk.newLines,
          oldStart: hunk.newStart,
          newLines: hunk.oldLines,
          newStart: hunk.oldStart,
          linedelimiters: hunk.linedelimiters,
          lines: hunk.lines.map(function (l) {
            if (l.startsWith('-')) {
              return (
                /*istanbul ignore start*/
                "+".concat(
                /*istanbul ignore end*/
                l.slice(1))
              );
            }

            if (l.startsWith('+')) {
              return (
                /*istanbul ignore start*/
                "-".concat(
                /*istanbul ignore end*/
                l.slice(1))
              );
            }

            return l;
          })
        };
      })
    })
  );
}


/***/ }),

/***/ "./node_modules/diff/lib/util/array.js":
/*!*********************************************!*\
  !*** ./node_modules/diff/lib/util/array.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayEqual = arrayEqual;
exports.arrayStartsWith = arrayStartsWith;

/*istanbul ignore end*/
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return arrayStartsWith(a, b);
}

function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }

  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }

  return true;
}


/***/ }),

/***/ "./node_modules/diff/lib/util/distance-iterator.js":
/*!*********************************************************!*\
  !*** ./node_modules/diff/lib/util/distance-iterator.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;

/*istanbul ignore end*/
// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function
/*istanbul ignore start*/
_default
/*istanbul ignore end*/
(start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      } // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)


      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      } // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location


      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined

  };
}


/***/ }),

/***/ "./node_modules/diff/lib/util/params.js":
/*!**********************************************!*\
  !*** ./node_modules/diff/lib/util/params.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.generateOptions = generateOptions;

/*istanbul ignore end*/
function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}


/***/ }),

/***/ "./node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ index)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var use_latest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-latest */ "./node_modules/use-latest/dist/use-latest.esm.js");
/* harmony import */ var use_composed_ref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-composed-ref */ "./node_modules/use-composed-ref/dist/use-composed-ref.esm.js");






var HIDDEN_TEXTAREA_STYLE = {
  'min-height': '0',
  'max-height': 'none',
  height: '0',
  visibility: 'hidden',
  overflow: 'hidden',
  position: 'absolute',
  'z-index': '-1000',
  top: '0',
  right: '0',
  display: 'block'
};
var forceHiddenStyles = function forceHiddenStyles(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function (key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], 'important');
  });
};
var forceHiddenStyles$1 = forceHiddenStyles;

var hiddenTextarea = null;
var getHeight = function getHeight(node, sizingData) {
  var height = node.scrollHeight;
  if (sizingData.sizingStyle.boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    return height + sizingData.borderSize;
  }

  // remove padding, since height = content
  return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  if (minRows === void 0) {
    minRows = 1;
  }
  if (maxRows === void 0) {
    maxRows = Infinity;
  }
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    hiddenTextarea.setAttribute('tabindex', '-1');
    hiddenTextarea.setAttribute('aria-hidden', 'true');
    forceHiddenStyles$1(hiddenTextarea);
  }
  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }
  var paddingSize = sizingData.paddingSize,
    borderSize = sizingData.borderSize,
    sizingStyle = sizingData.sizingStyle;
  var boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function (_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles$1(hiddenTextarea);
  hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData);
  // Double set and calc due to Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1795904
  hiddenTextarea.value = value;
  height = getHeight(hiddenTextarea, sizingData);

  // measure height of a textarea with a single row
  hiddenTextarea.value = 'x';
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  var minHeight = rowHeight * minRows;
  if (boxSizing === 'border-box') {
    minHeight = minHeight + paddingSize + borderSize;
  }
  height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;
  if (boxSizing === 'border-box') {
    maxHeight = maxHeight + paddingSize + borderSize;
  }
  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}

var noop = function noop() {};
var pick = function pick(props, obj) {
  return props.reduce(function (acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
};

var SIZING_STYLE = ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'boxSizing', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'lineHeight', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop',
// non-standard
'tabSize', 'textIndent',
// non-standard
'textRendering', 'textTransform', 'width', 'wordBreak', 'wordSpacing', 'scrollbarGutter'];
var isIE = !!document.documentElement.currentStyle ;
var getSizingData = function getSizingData(node) {
  var style = window.getComputedStyle(node);
  if (style === null) {
    return null;
  }
  var sizingStyle = pick(SIZING_STYLE, style);
  var boxSizing = sizingStyle.boxSizing;

  // probably node is detached from DOM, can't read computed dimensions
  if (boxSizing === '') {
    return null;
  }

  // IE (Edge has already correct behaviour) returns content width as computed width
  // so we need to add manually padding and border widths
  if (isIE && boxSizing === 'border-box') {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + 'px';
  }
  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize
  };
};
var getSizingData$1 = getSizingData;

function useListener(target, type, listener) {
  var latestListener = (0,use_latest__WEBPACK_IMPORTED_MODULE_3__["default"])(listener);
  react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect(function () {
    var handler = function handler(ev) {
      return latestListener.current(ev);
    };
    // might happen if document.fonts is not defined, for instance
    if (!target) {
      return;
    }
    target.addEventListener(type, handler);
    return function () {
      return target.removeEventListener(type, handler);
    };
  }, []);
}
var useFormResetListener = function useFormResetListener(libRef, listener) {
  useListener(document.body, 'reset', function (ev) {
    if (libRef.current.form === ev.target) {
      listener(ev);
    }
  });
};
var useWindowResizeListener = function useWindowResizeListener(listener) {
  useListener(window, 'resize', listener);
};
var useFontsLoadedListener = function useFontsLoadedListener(listener) {
  useListener(document.fonts, 'loadingdone', listener);
};

var _excluded = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"];
var TextareaAutosize = function TextareaAutosize(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements,
    maxRows = _ref.maxRows,
    minRows = _ref.minRows,
    _ref$onChange = _ref.onChange,
    onChange = _ref$onChange === void 0 ? noop : _ref$onChange,
    _ref$onHeightChange = _ref.onHeightChange,
    onHeightChange = _ref$onHeightChange === void 0 ? noop : _ref$onHeightChange,
    props = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, _excluded);
  if (props.style) {
    if ('maxHeight' in props.style) {
      throw new Error('Using `style.maxHeight` for <TextareaAutosize/> is not supported. Please use `maxRows`.');
    }
    if ('minHeight' in props.style) {
      throw new Error('Using `style.minHeight` for <TextareaAutosize/> is not supported. Please use `minRows`.');
    }
  }
  var isControlled = props.value !== undefined;
  var libRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);
  var ref = (0,use_composed_ref__WEBPACK_IMPORTED_MODULE_4__["default"])(libRef, userRef);
  var heightRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(0);
  var measurementsCacheRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef();
  var resizeTextarea = function resizeTextarea() {
    var node = libRef.current;
    var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
    if (!nodeSizingData) {
      return;
    }
    measurementsCacheRef.current = nodeSizingData;
    var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || 'x', minRows, maxRows),
      height = _calculateNodeHeight[0],
      rowHeight = _calculateNodeHeight[1];
    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty('height', height + "px", 'important');
      onHeightChange(height, {
        rowHeight: rowHeight
      });
    }
  };
  var handleChange = function handleChange(event) {
    if (!isControlled) {
      resizeTextarea();
    }
    onChange(event);
  };
  {
    react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect(resizeTextarea);
    useFormResetListener(libRef, function () {
      if (!isControlled) {
        var currentValue = libRef.current.value;
        requestAnimationFrame(function () {
          var node = libRef.current;
          if (node && currentValue !== node.value) {
            resizeTextarea();
          }
        });
      }
    });
    useWindowResizeListener(resizeTextarea);
    useFontsLoadedListener(resizeTextarea);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement("textarea", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
      onChange: handleChange,
      ref: ref
    }));
  }
};
var index = /* #__PURE__ */react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(TextareaAutosize);




/***/ }),

/***/ "./node_modules/use-composed-ref/dist/use-composed-ref.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-composed-ref/dist/use-composed-ref.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ useComposedRef)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


// basically Exclude<React.ClassAttributes<T>["ref"], string>

var updateRef = function updateRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
    return;
  }
  ref.current = value;
};
var useComposedRef = function useComposedRef(libRef, userRef) {
  var prevUserRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();
  return react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (instance) {
    libRef.current = instance;
    if (prevUserRef.current) {
      updateRef(prevUserRef.current, null);
    }
    prevUserRef.current = userRef;
    if (!userRef) {
      return;
    }
    updateRef(userRef, instance);
  }, [userRef]);
};




/***/ }),

/***/ "./node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ index)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var index = react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect ;




/***/ }),

/***/ "./node_modules/use-latest/dist/use-latest.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/use-latest/dist/use-latest.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ useLatest)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-isomorphic-layout-effect */ "./node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js");



var useLatest = function useLatest(value) {
  var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(value);
  (0,use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
    ref.current = value;
  });
  return ref;
};




/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_theia_scm_lib_browser_merge-editor_merge-editor_js-node_modules_theia_sc-59ad23.js.map